title: $:/boot/preamble.tid
type: text/html
tags: $:/tags/RawMarkup

<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
<script>
	$tw = Object.create(null);
// Copyright (c) 2012 Niklas von Hertzen 
// MIT License
// https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts
/** @type {typeof import("fflate")} */
var fflate = $tw.node ? (global.fflate || require("./fflate.js")) : window.fflate

$tw.fflate = Object.create(null);

$tw.fflate.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
$tw.fflate.lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for(let i = 0; i < $tw.fflate.chars.length; i++) { $tw.fflate.lookup[$tw.fflate.chars.charCodeAt(i)] = i; }

/** 
 * @typedef BufferLike
 * @property {number} BYTES_PER_ELEMENT
 * @property {ArrayBuffer} buffer
 * @property {number} byteLength
 * @property {number} byteOffset
 */
/**
 *  
 * @param {BufferLike} buf 
 * @returns {string}
 */
$tw.fflate.bufferToBase64 = (buf) => {
	let bytes = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength),
		i,
		len = bytes.length,
		base64 = '';

	for (i = 0; i < len; i += 3) {
		base64 += $tw.fflate.chars[bytes[i] >> 2];
		base64 += $tw.fflate.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
		base64 += $tw.fflate.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
		base64 += $tw.fflate.chars[bytes[i + 2] & 63];
	}

	if (len % 3 === 2) {
		base64 = base64.substring(0, base64.length - 1) + '=';
	} else if (len % 3 === 1) {
		base64 = base64.substring(0, base64.length - 2) + '==';
	}

	return base64;
};



/**
 * 
 * @param {string} base64 
 * @returns {Uint8Array}
 */
$tw.fflate.bufferFromBase64 = function (base64) {
	if (!base64.charCodeAt) console.log(base64);
	let bufferLength = base64.length * 0.75,
		len = base64.length,
		i,
		p = 0,
		encoded1,
		encoded2,
		encoded3,
		encoded4;

	if (base64[base64.length - 1] === '=') {
		bufferLength--;
		if (base64[base64.length - 2] === '=') {
			bufferLength--;
		}
	}

	const arraybuffer = new ArrayBuffer(bufferLength),
		bytes = new Uint8Array(arraybuffer);

	for (i = 0; i < len; i += 4) {
		encoded1 = $tw.fflate.lookup[base64.charCodeAt(i)];
		encoded2 = $tw.fflate.lookup[base64.charCodeAt(i + 1)];
		encoded3 = $tw.fflate.lookup[base64.charCodeAt(i + 2)];
		encoded4 = $tw.fflate.lookup[base64.charCodeAt(i + 3)];

		bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
		bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
		bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	}

	return bytes;
};


$tw.fflate.parse_json_gzip_base64 = function(text){
	try { return JSON.parse($tw.fflate.parse_gzip_base64(text)); } catch (e) { }
}

$tw.fflate.parse_gzip_base64 = function(text){
	const compressed2 = $tw.fflate.bufferFromBase64(text);
	const decom = fflate.gunzipSync(compressed2);
	return fflate.strFromU8(decom);
}

$tw.fflate.stringify_json_gzip_base64 = function(data){
	return $tw.fflate.to_gzip_base64(JSON.stringify(data));
}

$tw.fflate.to_gzip_base64 = function(text){
	const buf = fflate.strToU8(text);
	const compressed = fflate.compressSync(buf, { level: 4, mem:5 });
	return $tw.fflate.bufferToBase64(compressed);
}
</script>