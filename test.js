exports.tiddlywiki = function($tw){ 
	function _copyContext(moduleInfo, require){
		// var _exports = {},
		contextValues = [
			{exports: moduleInfo.exports },
			moduleInfo.exports,
			console,
			setInterval,
			clearInterval,
			setTimeout,
			clearTimeout,
			$tw.browser ? undefined : Buffer,
			$tw,
			require
		];
		return contextValues;
	}
	function _define(title, moduleType, definer){
		$tw.modules.define(title, moduleType, (moduleInfo, exports, require) => {
			definer.apply(null, _copyContext(moduleInfo, require));
		});
	}	
	
		











_define("$:/core/modules/commander.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commander.js
type: application/javascript
module-type: global

The $tw.Commander class is a command interpreter

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Parse a sequence of commands
	commandTokens: an array of command string tokens
	wiki: reference to the wiki store object
	streams: {output:, error:}, each of which has a write(string) method
	callback: a callback invoked as callback(err) where err is null if there was no error
*/
var Commander = function(commandTokens,callback,wiki,streams) {
	var path = require("path");
	this.commandTokens = commandTokens;
	this.nextToken = 0;
	this.callback = callback;
	this.wiki = wiki;
	this.streams = streams;
	this.outputPath = path.resolve($tw.boot.wikiPath,$tw.config.wikiOutputSubDir);
};

/*
Log a string if verbose flag is set
*/
Commander.prototype.log = function(str) {
	if(this.verbose) {
		this.streams.output.write(str + "\n");
	}
};

/*
Write a string if verbose flag is set
*/
Commander.prototype.write = function(str) {
	if(this.verbose) {
		this.streams.output.write(str);
	}
};

/*
Add a string of tokens to the command queue
*/
Commander.prototype.addCommandTokens = function(commandTokens) {
	var params = commandTokens.slice(0);
	params.unshift(0);
	params.unshift(this.nextToken);
	Array.prototype.splice.apply(this.commandTokens,params);
};

/*
Execute the sequence of commands and invoke a callback on completion
*/
Commander.prototype.execute = function() {
	this.executeNextCommand();
};

/*
Execute the next command in the sequence
*/
Commander.prototype.executeNextCommand = function() {
	var self = this;
	// Invoke the callback if there are no more commands
	if(this.nextToken >= this.commandTokens.length) {
		this.callback(null);
	} else {
		// Get and check the command token
		var commandName = this.commandTokens[this.nextToken++];
		if(commandName.substr(0,2) !== "--") {
			this.callback("Missing command: " + commandName);
		} else {
			commandName = commandName.substr(2); // Trim off the --
			// Accumulate the parameters to the command
			var params = [];
			while(this.nextToken < this.commandTokens.length && 
				this.commandTokens[this.nextToken].substr(0,2) !== "--") {
				params.push(this.commandTokens[this.nextToken++]);
			}
			// Get the command info
			var command = $tw.commands[commandName],
				c,err;
			if(!command) {
				this.callback("Unknown command: " + commandName);
			} else {
				if(this.verbose) {
					this.streams.output.write("Executing command: " + commandName + " " + params.join(" ") + "\n");
				}
				// Parse named parameters if required
				if(command.info.namedParameterMode) {
					params = this.extractNamedParameters(params,command.info.mandatoryParameters);
					if(typeof params === "string") {
						return this.callback(params);
					}
				}
				if(command.info.synchronous) {
					// Synchronous command
					c = new command.Command(params,this);
					err = c.execute();
					if(err) {
						this.callback(err);
					} else {
						this.executeNextCommand();
					}
				} else {
					// Asynchronous command
					c = new command.Command(params,this,function(err) {
						if(err) {
							self.callback(err);
						} else {
							self.executeNextCommand();
						}
					});
					err = c.execute();
					if(err) {
						this.callback(err);
					}
				}
			}
		}
	}
};

/*
Given an array of parameter strings `params` in name:value format, and an array of mandatory parameter names in `mandatoryParameters`, returns a hashmap of values or a string if error
*/
Commander.prototype.extractNamedParameters = function(params,mandatoryParameters) {
	mandatoryParameters = mandatoryParameters || [];
	var errors = [],
		paramsByName = Object.create(null);
	// Extract the parameters
	$tw.utils.each(params,function(param) {
		var index = param.indexOf("=");
		if(index < 1) {
			errors.push("malformed named parameter: '" + param + "'");
		}
		paramsByName[param.slice(0,index)] = $tw.utils.trim(param.slice(index+1));
	});
	// Check the mandatory parameters are present
	$tw.utils.each(mandatoryParameters,function(mandatoryParameter) {
		if(!$tw.utils.hop(paramsByName,mandatoryParameter)) {
			errors.push("missing mandatory parameter: '" + mandatoryParameter + "'");
		}
	});
	// Return any errors
	if(errors.length > 0) {
		return errors.join(" and\n");
	} else {
		return paramsByName;		
	}
};

Commander.initCommands = function(moduleType) {
	moduleType = moduleType || "command";
	$tw.commands = {};
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		var c = $tw.commands[module.info.name] = {};
		// Add the methods defined by the module
		for(var f in module) {
			if($tw.utils.hop(module,f)) {
				c[f] = module[f];
			}
		}
	});
};

exports.Commander = Commander;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/build.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/build.js
type: application/javascript
module-type: command

Command to build a build target

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "build",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	// Get the build targets defined in the wiki
	var buildTargets = $tw.boot.wikiInfo.build;
	if(!buildTargets) {
		return "No build targets defined";
	}
	// Loop through each of the specified targets
	var targets;
	if(this.params.length > 0) {
		targets = this.params;
	} else {
		targets = Object.keys(buildTargets);
	}
	for(var targetIndex=0; targetIndex<targets.length; targetIndex++) {
		var target = targets[targetIndex],
			commands = buildTargets[target];
		if(!commands) {
			return "Build target '" + target + "' not found";
		}
		// Add the commands to the queue
		this.commander.addCommandTokens(commands);
	}
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/clearpassword.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/clearpassword.js
type: application/javascript
module-type: command

Clear password for crypto operations

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "clearpassword",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	$tw.crypto.setPassword(null);
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/deletetiddlers.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/deletetiddlers.js
type: application/javascript
module-type: command

Command to delete tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "deletetiddlers",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing filter";
	}
	var self = this,
		wiki = this.commander.wiki,
		filter = this.params[0],
		tiddlers = wiki.filterTiddlers(filter);
	$tw.utils.each(tiddlers,function(title) {
		wiki.deleteTiddler(title);
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/editions.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/editions.js
type: application/javascript
module-type: command

Command to list the available editions

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "editions",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	var self = this;
	// Output the list
	this.commander.streams.output.write("Available editions:\n\n");
	var editionInfo = $tw.utils.getEditionInfo();
	$tw.utils.each(editionInfo,function(info,name) {
		self.commander.streams.output.write("    " + name + ": " + info.description + "\n");
	});
	this.commander.streams.output.write("\n");
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/fetch.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/fetch.js
type: application/javascript
module-type: command

Commands to fetch external tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "fetch",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing subcommand and url";
	}
	switch(this.params[0]) {
		case "raw-file":
			return this.fetchFiles({
				raw: true,
				url: this.params[1],
				transformFilter: this.params[2] || "",
				callback: this.callback
			});
			break;
		case "file":
			return this.fetchFiles({
				url: this.params[1],
				importFilter: this.params[2],
				transformFilter: this.params[3] || "",
				callback: this.callback
			});
			break;
		case "raw-files":
			return this.fetchFiles({
				raw: true,
				urlFilter: this.params[1],
				transformFilter: this.params[2] || "",
				callback: this.callback
			});
			break;
		case "files":
			return this.fetchFiles({
				urlFilter: this.params[1],
				importFilter: this.params[2],
				transformFilter: this.params[3] || "",
				callback: this.callback
			});
			break;
	}
	return null;
};

Command.prototype.fetchFiles = function(options) {
	var self = this;
	// Get the list of URLs
	var urls;
	if(options.url) {
		urls = [options.url]
	} else if(options.urlFilter) {
		urls = $tw.wiki.filterTiddlers(options.urlFilter);
	} else {
		return "Missing URL";
	}
	// Process each URL in turn
	var next = 0;
	var getNextFile = function(err) {
		if(err) {
			return options.callback(err);
		}
		if(next < urls.length) {
			self.fetchFile(urls[next++],options,getNextFile);
		} else {
			options.callback(null);
		}
	};
	getNextFile(null);
	// Success
	return null;
};

Command.prototype.fetchFile = function(url,options,callback,redirectCount) {
	if(redirectCount > 10) {
		return callback("Error too many redirects retrieving " + url);
	}
	var self = this,
		lib = url.substr(0,8) === "https://" ? require("https") : require("http");
	lib.get(url).on("response",function(response) {
	    var type = (response.headers["content-type"] || "").split(";")[0],
	    	data = [];
	    self.commander.write("Reading " + url + ": ");
	    response.on("data",function(chunk) {
	        data.push(chunk);
	        self.commander.write(".");
	    });
	    response.on("end",function() {
	        self.commander.write("\n");
	        if(response.statusCode === 200) {
		        self.processBody(Buffer.concat(data),type,options,url);
		        callback(null);
	        } else {
	        	if(response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
	        		return self.fetchFile(response.headers.location,options,callback,redirectCount + 1);
	        	} else {
		        	return callback("Error " + response.statusCode + " retrieving " + url)	        		
	        	}
	        }
	   	});
	   	response.on("error",function(e) {
			console.log("Error on GET request: " + e);
			callback(e);
	   	});
	});
	return null;
};

Command.prototype.processBody = function(body,type,options,url) {
	var self = this;
	// Collect the tiddlers in a wiki
	var incomingWiki = new $tw.Wiki();
	if(options.raw) {
		var typeInfo = type ? $tw.config.contentTypeInfo[type] : null,
			encoding = typeInfo ? typeInfo.encoding : "utf8";
		incomingWiki.addTiddler(new $tw.Tiddler({
			title: url,
			type: type,
			text: body.toString(encoding)
		}));
	} else {
		// Deserialise the file to extract the tiddlers
		var tiddlers = this.commander.wiki.deserializeTiddlers(type || "text/html",body.toString("utf8"),{});
		$tw.utils.each(tiddlers,function(tiddler) {
			incomingWiki.addTiddler(new $tw.Tiddler(tiddler));
		});
	}
	// Filter the tiddlers to select the ones we want
	var filteredTitles = incomingWiki.filterTiddlers(options.importFilter || "[all[tiddlers]]");
	// Import the selected tiddlers
	var count = 0;
	incomingWiki.each(function(tiddler,title) {
		if(filteredTitles.indexOf(title) !== -1) {
			var newTiddler;
			if(options.transformFilter) {
				var transformedTitle = (incomingWiki.filterTiddlers(options.transformFilter,null,self.commander.wiki.makeTiddlerIterator([title])) || [""])[0];
				if(transformedTitle) {
					self.commander.log("Importing " + title + " as " + transformedTitle)
					newTiddler = new $tw.Tiddler(tiddler,{title: transformedTitle});
				}
			} else {
				self.commander.log("Importing " + title)
				newTiddler = tiddler;
			}
			self.commander.wiki.importTiddler(newTiddler);
			count++;
		}
	});
	self.commander.log("Imported " + count + " tiddlers")
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/help.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/help.js
type: application/javascript
module-type: command

Help command

\*/
(function(){

/*jshint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "help",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	var subhelp = this.params[0] || "default",
		helpBase = "$:/language/Help/",
		text;
	if(!this.commander.wiki.getTiddler(helpBase + subhelp)) {
		subhelp = "notfound";
	}
	// Wikify the help as formatted text (ie block elements generate newlines)
	text = this.commander.wiki.renderTiddler("text/plain-formatted",helpBase + subhelp);
	// Remove any leading linebreaks
	text = text.replace(/^(\r?\n)*/g,"");
	this.commander.streams.output.write(text);
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/import.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/import.js
type: application/javascript
module-type: command

Command to import tiddlers from a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "import",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var self = this,
		fs = require("fs"),
		path = require("path");
	if(this.params.length < 2) {
		return "Missing parameters";
	}
	var filename = self.params[0],
		deserializer = self.params[1],
		title = self.params[2] || filename,
		encoding = self.params[3] || "utf8",
		text = fs.readFileSync(filename,encoding),
		tiddlers = this.commander.wiki.deserializeTiddlers(null,text,{title: title},{deserializer: deserializer});
	$tw.utils.each(tiddlers,function(tiddler) {
		self.commander.wiki.importTiddler(new $tw.Tiddler(tiddler));
	});
	this.commander.log(tiddlers.length + " tiddler(s) imported");
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/init.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/init.js
type: application/javascript
module-type: command

Command to initialise an empty wiki folder

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "init",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	var fs = require("fs"),
		path = require("path");
	// Check that we don't already have a valid wiki folder
	if($tw.boot.wikiTiddlersPath || ($tw.utils.isDirectory($tw.boot.wikiPath) && !$tw.utils.isDirectoryEmpty($tw.boot.wikiPath))) {
		return "Wiki folder is not empty";
	}
	// Loop through each of the specified editions
	var editions = this.params.length > 0 ? this.params : ["empty"];
	for(var editionIndex=0; editionIndex<editions.length; editionIndex++) {
		var editionName = editions[editionIndex];
		// Check the edition exists
		var editionPath = $tw.findLibraryItem(editionName,$tw.getLibraryItemSearchPaths($tw.config.editionsPath,$tw.config.editionsEnvVar));
		if(!$tw.utils.isDirectory(editionPath)) {
			return "Edition '" + editionName + "' not found";
		}
		// Copy the edition content
		var err = $tw.utils.copyDirectory(editionPath,$tw.boot.wikiPath);
		if(!err) {
			this.commander.streams.output.write("Copied edition '" + editionName + "' to " + $tw.boot.wikiPath + "\n");
		} else {
			return err;
		}
	}
	// Tweak the tiddlywiki.info to remove any included wikis
	var packagePath = $tw.boot.wikiPath + "/tiddlywiki.info",
		packageJson = JSON.parse(fs.readFileSync(packagePath));
	delete packageJson.includeWikis;
	fs.writeFileSync(packagePath,JSON.stringify(packageJson,null,$tw.config.preferences.jsonSpaces));
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/listen.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/listen.js
type: application/javascript
module-type: command

Listen for HTTP requests and serve tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Server = require("$:/core/modules/server/server.js").Server;

exports.info = {
	name: "listen",
	synchronous: true,
	namedParameterMode: true,
	mandatoryParameters: [],
};

var Command = function(params,commander,callback) {
	var self = this;
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var self = this;
	if(!$tw.boot.wikiTiddlersPath) {
		$tw.utils.warning("Warning: Wiki folder '" + $tw.boot.wikiPath + "' does not exist or is missing a tiddlywiki.info file");
	}
	// Set up server
	this.server = new Server({
		wiki: this.commander.wiki,
		variables: self.params
	});
	var nodeServer = this.server.listen();
	$tw.hooks.invokeHook("th-server-command-post-start",this.server,nodeServer,"tiddlywiki");
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/load.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/load.js
type: application/javascript
module-type: command

Command to load tiddlers from a file or directory

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "load",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var self = this,
		fs = require("fs"),
		path = require("path");
	if(this.params.length < 1) {
		return "Missing filename";
	}
	var tiddlers = $tw.loadTiddlersFromPath(self.params[0]),
		count = 0;
	$tw.utils.each(tiddlers,function(tiddlerInfo) {
		$tw.utils.each(tiddlerInfo.tiddlers,function(tiddler) {
			self.commander.wiki.importTiddler(new $tw.Tiddler(tiddler));
			count++;
		});
	});
	if(!count && self.params[1] !== "noerror") {
		self.callback("No tiddlers found in file \"" + self.params[0] + "\"");
	} else {
		self.callback(null);
	}
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/makelibrary.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/makelibrary.js
type: application/javascript
module-type: command

Command to pack all of the plugins in the library into a plugin tiddler of type "library"

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "makelibrary",
	synchronous: true
};

var UPGRADE_LIBRARY_TITLE = "$:/UpgradeLibrary";

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var wiki = this.commander.wiki,
		fs = require("fs"),
		path = require("path"),
		upgradeLibraryTitle = this.params[0] || UPGRADE_LIBRARY_TITLE,
		tiddlers = {};
	// Collect up the library plugins
	var collectPlugins = function(folder) {
			var pluginFolders = fs.readdirSync(folder);
			for(var p=0; p<pluginFolders.length; p++) {
				if(!$tw.boot.excludeRegExp.test(pluginFolders[p])) {
					pluginFields = $tw.loadPluginFolder(path.resolve(folder,"./" + pluginFolders[p]));
					if(pluginFields && pluginFields.title) {
						tiddlers[pluginFields.title] = pluginFields;
					}
				}
			}
		},
		collectPublisherPlugins = function(folder) {
			var publisherFolders = fs.readdirSync(folder);
			for(var t=0; t<publisherFolders.length; t++) {
				if(!$tw.boot.excludeRegExp.test(publisherFolders[t])) {
					collectPlugins(path.resolve(folder,"./" + publisherFolders[t]));
				}
			}
		};
	collectPublisherPlugins(path.resolve($tw.boot.corePath,$tw.config.pluginsPath));
	collectPublisherPlugins(path.resolve($tw.boot.corePath,$tw.config.themesPath));
	collectPlugins(path.resolve($tw.boot.corePath,$tw.config.languagesPath));
	// Save the upgrade library tiddler
	var pluginFields = {
		title: upgradeLibraryTitle,
		type: "application/json",
		"plugin-type": "library",
		"text": JSON.stringify({tiddlers: tiddlers},null,$tw.config.preferences.jsonSpaces)
	};
	wiki.addTiddler(new $tw.Tiddler(pluginFields));
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/output.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/output.js
type: application/javascript
module-type: command

Command to set the default output location (defaults to current working directory)

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "output",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var fs = require("fs"),
		path = require("path");
	if(this.params.length < 1) {
		return "Missing output path";
	}
	this.commander.outputPath = path.resolve(process.cwd(),this.params[0]);
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/password.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/password.js
type: application/javascript
module-type: command

Save password for crypto operations

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "password",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing password";
	}
	$tw.crypto.setPassword(this.params[0]);
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/render.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/render.js
type: application/javascript
module-type: command

Render individual tiddlers and save the results to the specified files

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

exports.info = {
	name: "render",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing tiddler filter";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		wiki = this.commander.wiki,
		tiddlerFilter = this.params[0],
		filenameFilter = this.params[1] || "[is[tiddler]addsuffix[.html]]",
		type = this.params[2] || "text/html",
		template = this.params[3],
		varName = this.params[4],
		varValue = this.params[5],
		tiddlers = wiki.filterTiddlers(tiddlerFilter);
	$tw.utils.each(tiddlers,function(title) {
		var parser = wiki.parseTiddler(template || title),
			variables = {currentTiddler: title};
		if(varName) {
			variables[varName] = varValue || "";
		}
		var widgetNode = wiki.makeWidget(parser,{variables: variables}),
			container = $tw.fakeDocument.createElement("div");
		widgetNode.render(container,null);
		var text = type === "text/html" ? container.innerHTML : container.textContent,
			filepath = path.resolve(self.commander.outputPath,wiki.filterTiddlers(filenameFilter,$tw.rootWidget,wiki.makeTiddlerIterator([title]))[0]);
		if(self.commander.verbose) {
			console.log("Rendering \"" + title + "\" to \"" + filepath + "\"");
		}
		$tw.utils.createFileDirectories(filepath);
		fs.writeFileSync(filepath,text,"utf8");
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/rendertiddler.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/rendertiddler.js
type: application/javascript
module-type: command

Command to render a tiddler and save it to a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "rendertiddler",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		title = this.params[0],
		filename = path.resolve(this.commander.outputPath,this.params[1]),
		type = this.params[2] || "text/html",
		template = this.params[3],
		name = this.params[4],
		value = this.params[5],
		variables = {};
	$tw.utils.createFileDirectories(filename);
	if(template) {
		variables.currentTiddler = title;
		title = template;
	}
	if(name && value) {
		variables[name] = value;
	}
	fs.writeFile(filename,this.commander.wiki.renderTiddler(type,title,{variables: variables}),"utf8",function(err) {
		self.callback(err);
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/rendertiddlers.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/rendertiddlers.js
type: application/javascript
module-type: command

Command to render several tiddlers to a folder of files

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

exports.info = {
	name: "rendertiddlers",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		wiki = this.commander.wiki,
		filter = this.params[0],
		template = this.params[1],
		outputPath = this.commander.outputPath,
		pathname = path.resolve(outputPath,this.params[2]),		
		type = this.params[3] || "text/html",
		extension = this.params[4] || ".html",
		deleteDirectory = (this.params[5] || "").toLowerCase() !== "noclean",
		tiddlers = wiki.filterTiddlers(filter);
	if(deleteDirectory) {
		$tw.utils.deleteDirectory(pathname);
	}
	$tw.utils.each(tiddlers,function(title) {
		var parser = wiki.parseTiddler(template),
			widgetNode = wiki.makeWidget(parser,{variables: {currentTiddler: title}}),
			container = $tw.fakeDocument.createElement("div");
		widgetNode.render(container,null);
		var text = type === "text/html" ? container.innerHTML : container.textContent,
			exportPath = null;
		if($tw.utils.hop($tw.macros,"tv-get-export-path")) {
			var macroPath = $tw.macros["tv-get-export-path"].run.apply(self,[title]);
			if(macroPath) {
				exportPath = path.resolve(outputPath,macroPath + extension);
			}
		}
		var finalPath = exportPath || path.resolve(pathname,encodeURIComponent(title) + extension);
		$tw.utils.createFileDirectories(finalPath);
		fs.writeFileSync(finalPath,text,"utf8");
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/save.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/save.js
type: application/javascript
module-type: command

Saves individual tiddlers in their raw text or binary format to the specified files

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "save",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing filename filter";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		wiki = this.commander.wiki,
		tiddlerFilter = this.params[0],
		filenameFilter = this.params[1] || "[is[tiddler]]",
		tiddlers = wiki.filterTiddlers(tiddlerFilter);
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = self.commander.wiki.getTiddler(title),
			type = tiddler.fields.type || "text/vnd.tiddlywiki",
			contentTypeInfo = $tw.config.contentTypeInfo[type] || {encoding: "utf8"},
			filepath = path.resolve(self.commander.outputPath,wiki.filterTiddlers(filenameFilter,$tw.rootWidget,wiki.makeTiddlerIterator([title]))[0]);
		if(self.commander.verbose) {
			console.log("Saving \"" + title + "\" to \"" + filepath + "\"");
		}
		$tw.utils.createFileDirectories(filepath);
		fs.writeFileSync(filepath,tiddler.fields.text,contentTypeInfo.encoding);
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/savelibrarytiddlers.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/savelibrarytiddlers.js
type: application/javascript
module-type: command

Command to save the subtiddlers of a bundle tiddler as a series of JSON files

--savelibrarytiddlers <tiddler> <pathname> <skinnylisting>

The tiddler identifies the bundle tiddler that contains the subtiddlers.

The pathname specifies the pathname to the folder in which the JSON files should be saved. The filename is the URL encoded title of the subtiddler.

The skinnylisting specifies the title of the tiddler to which a JSON catalogue of the subtiddlers will be saved. The JSON file contains the same data as the bundle tiddler but with the `text` field removed.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "savelibrarytiddlers",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		containerTitle = this.params[0],
		filter = this.params[1],
		basepath = this.params[2],
		skinnyListTitle = this.params[3];
	// Get the container tiddler as data
	var containerData = self.commander.wiki.getTiddlerDataCached(containerTitle,undefined);
	if(!containerData) {
		return "'" + containerTitle + "' is not a tiddler bundle";
	}
	// Filter the list of plugins
	var pluginList = [];
	$tw.utils.each(containerData.tiddlers,function(tiddler,title) {
		pluginList.push(title);
	});
	var filteredPluginList;
	if(filter) {
		filteredPluginList = self.commander.wiki.filterTiddlers(filter,null,self.commander.wiki.makeTiddlerIterator(pluginList));
	} else {
		filteredPluginList = pluginList;
	}
	// Iterate through the plugins
	var skinnyList = [];
	$tw.utils.each(filteredPluginList,function(title) {
		var tiddler = containerData.tiddlers[title];
		// Save each JSON file and collect the skinny data
		var pathname = path.resolve(self.commander.outputPath,basepath + encodeURIComponent(title) + ".json");
		$tw.utils.createFileDirectories(pathname);
		fs.writeFileSync(pathname,JSON.stringify(tiddler,null,$tw.config.preferences.jsonSpaces),"utf8");
		// Collect the skinny list data
		var pluginTiddlers = JSON.parse(tiddler.text),
			readmeContent = (pluginTiddlers.tiddlers[title + "/readme"] || {}).text,
			iconTiddler = pluginTiddlers.tiddlers[title + "/icon"] || {},
			iconType = iconTiddler.type,
			iconText = iconTiddler.text,
			iconContent;
		if(iconType && iconText) {
			iconContent = $tw.utils.makeDataUri(iconText,iconType);
		}
		skinnyList.push($tw.utils.extend({},tiddler,{text: undefined, readme: readmeContent, icon: iconContent}));
	});
	// Save the catalogue tiddler
	if(skinnyListTitle) {
		self.commander.wiki.setTiddlerData(skinnyListTitle,skinnyList);
	}
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/savetiddler.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/savetiddler.js
type: application/javascript
module-type: command

Command to save the content of a tiddler to a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "savetiddler",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		title = this.params[0],
		filename = path.resolve(this.commander.outputPath,this.params[1]),
		tiddler = this.commander.wiki.getTiddler(title);
	if(tiddler) {
		var type = tiddler.fields.type || "text/vnd.tiddlywiki",
			contentTypeInfo = $tw.config.contentTypeInfo[type] || {encoding: "utf8"};
		$tw.utils.createFileDirectories(filename);
		fs.writeFile(filename,tiddler.fields.text,contentTypeInfo.encoding,function(err) {
			self.callback(err);
		});
	} else {
		return "Missing tiddler: " + title;
	}
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/savetiddlers.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/savetiddlers.js
type: application/javascript
module-type: command

Command to save several tiddlers to a folder of files

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

exports.info = {
	name: "savetiddlers",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		wiki = this.commander.wiki,
		filter = this.params[0],
		pathname = path.resolve(this.commander.outputPath,this.params[1]),
		deleteDirectory = (this.params[2] || "").toLowerCase() !== "noclean",
		tiddlers = wiki.filterTiddlers(filter);
	if(deleteDirectory) {
		$tw.utils.deleteDirectory(pathname);
	}
	$tw.utils.createDirectory(pathname);
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = self.commander.wiki.getTiddler(title),
			type = tiddler.fields.type || "text/vnd.tiddlywiki",
			contentTypeInfo = $tw.config.contentTypeInfo[type] || {encoding: "utf8"},
			filename = path.resolve(pathname,encodeURIComponent(title));
		fs.writeFileSync(filename,tiddler.fields.text,contentTypeInfo.encoding);
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/savewikifolder.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/savewikifolder.js
type: application/javascript
module-type: command

Command to save the current wiki as a wiki folder

--savewikifolder <wikifolderpath> [<filter>]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "savewikifolder",
	synchronous: true
};

var fs,path;
if($tw.node) {
	fs = require("fs");
	path = require("path");
}

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing wiki folder path";
	}
	var wikifoldermaker = new WikiFolderMaker(this.params[0],this.params[1],this.commander);
	return wikifoldermaker.save();
};

function WikiFolderMaker(wikiFolderPath,wikiFilter,commander) {
	this.wikiFolderPath = wikiFolderPath;
	this.wikiFilter = wikiFilter || "[all[tiddlers]]";
	this.commander = commander;
	this.wiki = commander.wiki;
	this.savedPaths = []; // So that we can detect filename clashes
}

WikiFolderMaker.prototype.log = function(str) {
	if(this.commander.verbose) {
		console.log(str);
	}
};

WikiFolderMaker.prototype.tiddlersToIgnore = [
	"$:/boot/boot.css",
	"$:/boot/boot.js",
	"$:/boot/bootprefix.js",
	"$:/core",
	"$:/library/sjcl.js",
	"$:/temp/info-plugin"
];

/*
Returns null if successful, or an error string if there was an error
*/
WikiFolderMaker.prototype.save = function() {
	var self = this;
	// Check that the output directory doesn't exist
	if(fs.existsSync(this.wikiFolderPath) && !$tw.utils.isDirectoryEmpty(this.wikiFolderPath)) {
		return "The unpackwiki command requires that the output wiki folder be empty";
	}
	// Get the tiddlers from the source wiki
	var tiddlerTitles = this.wiki.filterTiddlers(this.wikiFilter);
	// Initialise a new tiddlwiki.info file
	var newWikiInfo = {};
	// Process each incoming tiddler in turn
	$tw.utils.each(tiddlerTitles,function(title) {
		var tiddler = self.wiki.getTiddler(title);
		if(tiddler) {
			if(self.tiddlersToIgnore.indexOf(title) !== -1) {
				// Ignore the core plugin and the ephemeral info plugin
				self.log("Ignoring tiddler: " + title);
			} else {
				var type = tiddler.fields.type,
					pluginType = tiddler.fields["plugin-type"];
				if(type === "application/json" && pluginType) {
					// Plugin tiddler
					var libraryDetails = self.findPluginInLibrary(title);
					if(libraryDetails) {
						// A plugin from the core library
						self.log("Adding built-in plugin: " + libraryDetails.name);
						newWikiInfo[libraryDetails.type] = newWikiInfo[libraryDetails.type]  || [];
						$tw.utils.pushTop(newWikiInfo[libraryDetails.type],libraryDetails.name);
					} else {
						// A custom plugin
						self.log("Processing custom plugin: " + title);
						self.saveCustomPlugin(tiddler);
					}				
				} else {
					// Ordinary tiddler
					self.saveTiddler("tiddlers",tiddler);
				}
			}
		}
	});
	// Save the tiddlywiki.info file
	this.saveJSONFile("tiddlywiki.info",newWikiInfo);
	self.log("Writing tiddlywiki.info: " + JSON.stringify(newWikiInfo,null,$tw.config.preferences.jsonSpaces));
	return null;
};

/*
Test whether the specified tiddler is a plugin in the plugin library
*/
WikiFolderMaker.prototype.findPluginInLibrary = function(title) {
	var parts = title.split("/"),
		pluginPath, type, name;
	if(parts[0] === "$:") {
		if(parts[1] === "languages" && parts.length === 3) {
			pluginPath = "languages" + path.sep + parts[2];
			type = parts[1];
			name = parts[2];
		} else if(parts[1] === "plugins" || parts[1] === "themes" && parts.length === 4) {
			pluginPath = parts[1] + path.sep + parts[2] + path.sep + parts[3];
			type = parts[1];
			name = parts[2] + "/" + parts[3];
		}
	}
	if(pluginPath && type && name) {
		pluginPath = path.resolve($tw.boot.bootPath,"..",pluginPath);
		if(fs.existsSync(pluginPath)) {
			return {
				pluginPath: pluginPath,
				type: type,
				name: name
			};
		}
	}
	return false;
};

WikiFolderMaker.prototype.saveCustomPlugin = function(pluginTiddler) {
	var self = this,
		pluginTitle = pluginTiddler.fields.title,
		titleParts = pluginTitle.split("/"),
		directory = $tw.utils.generateTiddlerFilepath(titleParts[titleParts.length - 1],{
			directory: path.resolve(this.wikiFolderPath,pluginTiddler.fields["plugin-type"] + "s")
		}),
		pluginInfo = pluginTiddler.getFieldStrings({exclude: ["text","type"]});
	this.saveJSONFile(directory + path.sep + "plugin.info",pluginInfo);
	self.log("Writing " + directory + path.sep + "plugin.info: " + JSON.stringify(pluginInfo,null,$tw.config.preferences.jsonSpaces));
	var pluginTiddlers = JSON.parse(pluginTiddler.fields.text).tiddlers; // A hashmap of tiddlers in the plugin
	$tw.utils.each(pluginTiddlers,function(tiddler) {
		self.saveTiddler(directory,new $tw.Tiddler(tiddler));
	});
};

WikiFolderMaker.prototype.saveTiddler = function(directory,tiddler) {
	var fileInfo = $tw.utils.generateTiddlerFileInfo(tiddler,{
		directory: path.resolve(this.wikiFolderPath,directory),
		wiki: this.wiki
	});
	$tw.utils.saveTiddlerToFileSync(tiddler,fileInfo);
};

WikiFolderMaker.prototype.saveJSONFile = function(filename,json) {
	this.saveTextFile(filename,JSON.stringify(json,null,$tw.config.preferences.jsonSpaces));
};

WikiFolderMaker.prototype.saveTextFile = function(filename,data) {
	this.saveFile(filename,"utf8",data);
};

WikiFolderMaker.prototype.saveFile = function(filename,encoding,data) {
	var filepath = path.resolve(this.wikiFolderPath,filename);
	$tw.utils.createFileDirectories(filepath);
	fs.writeFileSync(filepath,data,encoding);
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/server.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/server.js
type: application/javascript
module-type: command

Deprecated legacy command for serving tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Server = require("$:/core/modules/server/server.js").Server;

exports.info = {
	name: "server",
	synchronous: true
};

var Command = function(params,commander,callback) {
	var self = this;
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(!$tw.boot.wikiTiddlersPath) {
		$tw.utils.warning("Warning: Wiki folder '" + $tw.boot.wikiPath + "' does not exist or is missing a tiddlywiki.info file");
	}
	// Set up server
	this.server = new Server({
		wiki: this.commander.wiki,
		variables: {
			port: this.params[0],
			host: this.params[6],
			"root-tiddler": this.params[1],
			"root-render-type": this.params[2],
			"root-serve-type": this.params[3],
			username: this.params[4],
			password: this.params[5],
			"path-prefix": this.params[7],
			"debug-level": this.params[8]
		}
	});
	var nodeServer = this.server.listen();
	$tw.hooks.invokeHook("th-server-command-post-start",this.server,nodeServer,"tiddlywiki");
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/setfield.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/setfield.js
type: application/javascript
module-type: command

Command to modify selected tiddlers to set a field to the text of a template tiddler that has been wikified with the selected tiddler as the current tiddler.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

exports.info = {
	name: "setfield",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 4) {
		return "Missing parameters";
	}
	var self = this,
		wiki = this.commander.wiki,
		filter = this.params[0],
		fieldname = this.params[1] || "text",
		templatetitle = this.params[2],
		rendertype = this.params[3] || "text/plain",
		tiddlers = wiki.filterTiddlers(filter);
	$tw.utils.each(tiddlers,function(title) {
		var parser = wiki.parseTiddler(templatetitle),
			newFields = {},
			tiddler = wiki.getTiddler(title);
		if(parser) {
			var widgetNode = wiki.makeWidget(parser,{variables: {currentTiddler: title}});
			var container = $tw.fakeDocument.createElement("div");
			widgetNode.render(container,null);
			newFields[fieldname] = rendertype === "text/html" ? container.innerHTML : container.textContent;
		} else {
			newFields[fieldname] = undefined;
		}
		wiki.addTiddler(new $tw.Tiddler(tiddler,newFields));
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/unpackplugin.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/unpackplugin.js
type: application/javascript
module-type: command

Command to extract the shadow tiddlers from within a plugin

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "unpackplugin",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing plugin name";
	}
	var self = this,
		title = this.params[0],
		pluginData = this.commander.wiki.getTiddlerDataCached(title);
	if(!pluginData) {
		return "Plugin '" + title + "' not found";
	}
	$tw.utils.each(pluginData.tiddlers,function(tiddler) {
		self.commander.wiki.addTiddler(new $tw.Tiddler(tiddler));
	});
	return null;
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/verbose.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/verbose.js
type: application/javascript
module-type: command

Verbose command

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "verbose",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	this.commander.verbose = true;
	// Output the boot message log
	this.commander.streams.output.write("Boot log:\n  " + $tw.boot.logMessages.join("\n  ") + "\n");
	return null; // No error
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/commands/version.js","command",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/commands/version.js
type: application/javascript
module-type: command

Version command

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "version",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	this.commander.streams.output.write($tw.version + "\n");
	return null; // No error
};

exports.Command = Command;

})();

;})();
return exports;
}));
_define("$:/core/modules/config.js","config",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/config.js
type: application/javascript
module-type: config

Core configuration constants

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.preferences = {};

exports.preferences.notificationDuration = 3 * 1000;
exports.preferences.jsonSpaces = 4;

exports.textPrimitives = {
	upperLetter: "[A-Z\u00c0-\u00d6\u00d8-\u00de\u0150\u0170]",
	lowerLetter: "[a-z\u00df-\u00f6\u00f8-\u00ff\u0151\u0171]",
	anyLetter:   "[A-Za-z0-9\u00c0-\u00d6\u00d8-\u00de\u00df-\u00f6\u00f8-\u00ff\u0150\u0170\u0151\u0171]",
	blockPrefixLetters:	"[A-Za-z0-9-_\u00c0-\u00d6\u00d8-\u00de\u00df-\u00f6\u00f8-\u00ff\u0150\u0170\u0151\u0171]"
};

exports.textPrimitives.unWikiLink = "~";
exports.textPrimitives.wikiLink = exports.textPrimitives.upperLetter + "+" +
	exports.textPrimitives.lowerLetter + "+" +
	exports.textPrimitives.upperLetter +
	exports.textPrimitives.anyLetter + "*";

exports.htmlEntities = {quot:34, amp:38, apos:39, lt:60, gt:62, nbsp:160, iexcl:161, cent:162, pound:163, curren:164, yen:165, brvbar:166, sect:167, uml:168, copy:169, ordf:170, laquo:171, not:172, shy:173, reg:174, macr:175, deg:176, plusmn:177, sup2:178, sup3:179, acute:180, micro:181, para:182, middot:183, cedil:184, sup1:185, ordm:186, raquo:187, frac14:188, frac12:189, frac34:190, iquest:191, Agrave:192, Aacute:193, Acirc:194, Atilde:195, Auml:196, Aring:197, AElig:198, Ccedil:199, Egrave:200, Eacute:201, Ecirc:202, Euml:203, Igrave:204, Iacute:205, Icirc:206, Iuml:207, ETH:208, Ntilde:209, Ograve:210, Oacute:211, Ocirc:212, Otilde:213, Ouml:214, times:215, Oslash:216, Ugrave:217, Uacute:218, Ucirc:219, Uuml:220, Yacute:221, THORN:222, szlig:223, agrave:224, aacute:225, acirc:226, atilde:227, auml:228, aring:229, aelig:230, ccedil:231, egrave:232, eacute:233, ecirc:234, euml:235, igrave:236, iacute:237, icirc:238, iuml:239, eth:240, ntilde:241, ograve:242, oacute:243, ocirc:244, otilde:245, ouml:246, divide:247, oslash:248, ugrave:249, uacute:250, ucirc:251, uuml:252, yacute:253, thorn:254, yuml:255, OElig:338, oelig:339, Scaron:352, scaron:353, Yuml:376, fnof:402, circ:710, tilde:732, Alpha:913, Beta:914, Gamma:915, Delta:916, Epsilon:917, Zeta:918, Eta:919, Theta:920, Iota:921, Kappa:922, Lambda:923, Mu:924, Nu:925, Xi:926, Omicron:927, Pi:928, Rho:929, Sigma:931, Tau:932, Upsilon:933, Phi:934, Chi:935, Psi:936, Omega:937, alpha:945, beta:946, gamma:947, delta:948, epsilon:949, zeta:950, eta:951, theta:952, iota:953, kappa:954, lambda:955, mu:956, nu:957, xi:958, omicron:959, pi:960, rho:961, sigmaf:962, sigma:963, tau:964, upsilon:965, phi:966, chi:967, psi:968, omega:969, thetasym:977, upsih:978, piv:982, ensp:8194, emsp:8195, thinsp:8201, zwnj:8204, zwj:8205, lrm:8206, rlm:8207, ndash:8211, mdash:8212, lsquo:8216, rsquo:8217, sbquo:8218, ldquo:8220, rdquo:8221, bdquo:8222, dagger:8224, Dagger:8225, bull:8226, hellip:8230, permil:8240, prime:8242, Prime:8243, lsaquo:8249, rsaquo:8250, oline:8254, frasl:8260, euro:8364, image:8465, weierp:8472, real:8476, trade:8482, alefsym:8501, larr:8592, uarr:8593, rarr:8594, darr:8595, harr:8596, crarr:8629, lArr:8656, uArr:8657, rArr:8658, dArr:8659, hArr:8660, forall:8704, part:8706, exist:8707, empty:8709, nabla:8711, isin:8712, notin:8713, ni:8715, prod:8719, sum:8721, minus:8722, lowast:8727, radic:8730, prop:8733, infin:8734, ang:8736, and:8743, or:8744, cap:8745, cup:8746, int:8747, there4:8756, sim:8764, cong:8773, asymp:8776, ne:8800, equiv:8801, le:8804, ge:8805, sub:8834, sup:8835, nsub:8836, sube:8838, supe:8839, oplus:8853, otimes:8855, perp:8869, sdot:8901, lceil:8968, rceil:8969, lfloor:8970, rfloor:8971, lang:9001, rang:9002, loz:9674, spades:9824, clubs:9827, hearts:9829, diams:9830 };

exports.htmlVoidElements = "area,base,br,col,command,embed,hr,img,input,keygen,link,meta,param,source,track,wbr".split(",");

exports.htmlBlockElements = "address,article,aside,audio,blockquote,canvas,dd,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,li,noscript,ol,output,p,pre,section,table,tfoot,ul,video".split(",");

exports.htmlUnsafeElements = "script".split(",");

})();

;})();
return exports;
}));
_define("$:/core/modules/deserializers.js","tiddlerdeserializer",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/deserializers.js
type: application/javascript
module-type: tiddlerdeserializer

Functions to deserialise tiddlers from a block of text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Utility function to parse an old-style tiddler DIV in a *.tid file. It looks like this:

<div title="Title" creator="JoeBloggs" modifier="JoeBloggs" created="201102111106" modified="201102111310" tags="myTag [[my long tag]]">
<pre>The text of the tiddler (without the expected HTML encoding).
</pre>
</div>

Note that the field attributes are HTML encoded, but that the body of the <PRE> tag is not encoded.

When these tiddler DIVs are encountered within a TiddlyWiki HTML file then the body is encoded in the usual way.
*/
var parseTiddlerDiv = function(text /* [,fields] */) {
	// Slot together the default results
	var result = {};
	if(arguments.length > 1) {
		for(var f=1; f<arguments.length; f++) {
			var fields = arguments[f];
			for(var t in fields) {
				result[t] = fields[t];		
			}
		}
	}
	// Parse the DIV body
	var startRegExp = /^\s*<div\s+([^>]*)>(\s*<pre>)?/gi,
		endRegExp,
		match = startRegExp.exec(text);
	if(match) {
		// Old-style DIVs don't have the <pre> tag
		if(match[2]) {
			endRegExp = /<\/pre>\s*<\/div>\s*$/gi;
		} else {
			endRegExp = /<\/div>\s*$/gi;
		}
		var endMatch = endRegExp.exec(text);
		if(endMatch) {
			// Extract the text
			result.text = text.substring(match.index + match[0].length,endMatch.index);
			// Process the attributes
			var attrRegExp = /\s*([^=\s]+)\s*=\s*(?:"([^"]*)"|'([^']*)')/gi,
				attrMatch;
			do {
				attrMatch = attrRegExp.exec(match[1]);
				if(attrMatch) {
					var name = attrMatch[1];
					var value = attrMatch[2] !== undefined ? attrMatch[2] : attrMatch[3];
					result[name] = value;
				}
			} while(attrMatch);
			return result;
		}
	}
	return undefined;
};

exports["application/x-tiddler-html-div"] = function(text,fields) {
	return [parseTiddlerDiv(text,fields)];
};

exports["application/json"] = function(text,fields) {
	var incoming,
		results = [];
	try {
		incoming = JSON.parse(text);
	} catch(e) {
		incoming = [{
			title: "JSON error: " + e,
			text: ""
		}]
	}
	if(!$tw.utils.isArray(incoming)) {
		incoming = [incoming];
	}
	for(var t=0; t<incoming.length; t++) {
		var incomingFields = incoming[t],
			fields = {};
		for(var f in incomingFields) {
			if(typeof incomingFields[f] === "string") {
				fields[f] = incomingFields[f];
			}
		}
		results.push(fields);
	}
	return results;
};

/*
Parse an HTML file into tiddlers. There are three possibilities:
# A TiddlyWiki classic HTML file containing `text/x-tiddlywiki` tiddlers
# A TiddlyWiki5 HTML file containing `text/vnd.tiddlywiki` tiddlers
# An ordinary HTML file
*/
exports["text/html"] = function(text,fields) {
	// Check if we've got a store area
	var storeAreaMarkerRegExp = /<div id=["']?storeArea['"]?( style=["']?display:none;["']?)?>/gi,
		match = storeAreaMarkerRegExp.exec(text);
	if(match) {
		// If so, it's either a classic TiddlyWiki file or an unencrypted TW5 file
		// First read the normal tiddlers
		var results = deserializeTiddlyWikiFile(text,storeAreaMarkerRegExp.lastIndex,!!match[1],fields);
		// Then any system tiddlers
		var systemAreaMarkerRegExp = /<div id=["']?systemArea['"]?( style=["']?display:none;["']?)?>/gi,
			sysMatch = systemAreaMarkerRegExp.exec(text);
		if(sysMatch) {
			results.push.apply(results,deserializeTiddlyWikiFile(text,systemAreaMarkerRegExp.lastIndex,!!sysMatch[1],fields));
		}
		return results;
	} else {
		// Check whether we've got an encrypted file
		var encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(text);
		if(encryptedStoreArea) {
			// If so, attempt to decrypt it using the current password
			return $tw.utils.decryptStoreArea(encryptedStoreArea);
		} else {
			// It's not a TiddlyWiki so we'll return the entire HTML file as a tiddler
			return deserializeHtmlFile(text,fields);
		}
	}
};

function deserializeHtmlFile(text,fields) {
	var result = {};
	$tw.utils.each(fields,function(value,name) {
		result[name] = value;
	});
	result.text = text;
	result.type = "text/html";
	return [result];
}

function deserializeTiddlyWikiFile(text,storeAreaEnd,isTiddlyWiki5,fields) {
	var results = [],
		endOfDivRegExp = /(<\/div>\s*)/gi,
		startPos = storeAreaEnd,
		defaultType = isTiddlyWiki5 ? undefined : "text/x-tiddlywiki";
	endOfDivRegExp.lastIndex = startPos;
	var match = endOfDivRegExp.exec(text);
	while(match) {
		var endPos = endOfDivRegExp.lastIndex,
			tiddlerFields = parseTiddlerDiv(text.substring(startPos,endPos),fields,{type: defaultType});
		if(!tiddlerFields) {
			break;
		}
		$tw.utils.each(tiddlerFields,function(value,name) {
			if(typeof value === "string") {
				tiddlerFields[name] = $tw.utils.htmlDecode(value);
			}
		});
		if(tiddlerFields.text !== null) {
			results.push(tiddlerFields);
		}
		startPos = endPos;
		match = endOfDivRegExp.exec(text);
	}
	return results;
}

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/engines/framed.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/engines/framed.js
type: application/javascript
module-type: library

Text editor engine based on a simple input or textarea within an iframe. This is done so that the selection is preserved even when clicking away from the textarea

\*/
(function(){

/*jslint node: true,browser: true */
/*global $tw: false */
"use strict";

var HEIGHT_VALUE_TITLE = "$:/config/TextEditor/EditorHeight/Height";

function FramedEngine(options) {
	// Save our options
	options = options || {};
	this.widget = options.widget;
	this.value = options.value;
	this.parentNode = options.parentNode;
	this.nextSibling = options.nextSibling;
	// Create our hidden dummy text area for reading styles
	this.dummyTextArea = this.widget.document.createElement("textarea");
	if(this.widget.editClass) {
		this.dummyTextArea.className = this.widget.editClass;
	}
	this.dummyTextArea.setAttribute("hidden","true");
	this.parentNode.insertBefore(this.dummyTextArea,this.nextSibling);
	this.widget.domNodes.push(this.dummyTextArea);
	// Create the iframe
	this.iframeNode = this.widget.document.createElement("iframe");
	this.parentNode.insertBefore(this.iframeNode,this.nextSibling);
	this.iframeDoc = this.iframeNode.contentWindow.document;
	// (Firefox requires us to put some empty content in the iframe)
	this.iframeDoc.open();
	this.iframeDoc.write("");
	this.iframeDoc.close();
	// Style the iframe
	this.iframeNode.className = this.dummyTextArea.className;
	this.iframeNode.style.border = "none";
	this.iframeNode.style.padding = "0";
	this.iframeNode.style.resize = "none";
	this.iframeNode.style["background-color"] = this.widget.wiki.extractTiddlerDataItem(this.widget.wiki.getTiddlerText("$:/palette"),"tiddler-editor-background");
	this.iframeDoc.body.style.margin = "0";
	this.iframeDoc.body.style.padding = "0";
	this.widget.domNodes.push(this.iframeNode);
	// Construct the textarea or input node
	var tag = this.widget.editTag;
	if($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {
		tag = "input";
	}
	this.domNode = this.iframeDoc.createElement(tag);
	// Set the text
	if(this.widget.editTag === "textarea") {
		this.domNode.appendChild(this.iframeDoc.createTextNode(this.value));
	} else {
		this.domNode.value = this.value;
	}
	// Set the attributes
	if(this.widget.editType) {
		this.domNode.setAttribute("type",this.widget.editType);
	}
	if(this.widget.editPlaceholder) {
		this.domNode.setAttribute("placeholder",this.widget.editPlaceholder);
	}
	if(this.widget.editSize) {
		this.domNode.setAttribute("size",this.widget.editSize);
	}
	if(this.widget.editRows) {
		this.domNode.setAttribute("rows",this.widget.editRows);
	}
	if(this.widget.editTabIndex) {
		this.iframeNode.setAttribute("tabindex",this.widget.editTabIndex);
	}
	// Copy the styles from the dummy textarea
	this.copyStyles();
	// Add event listeners
	$tw.utils.addEventListeners(this.domNode,[
		{name: "click",handlerObject: this,handlerMethod: "handleClickEvent"},
		{name: "focus",handlerObject: this,handlerMethod: "handleFocusEvent"},
		{name: "input",handlerObject: this,handlerMethod: "handleInputEvent"},
		{name: "keydown",handlerObject: this.widget,handlerMethod: "handleKeydownEvent"}
	]);
	// Insert the element into the DOM
	this.iframeDoc.body.appendChild(this.domNode);
}

/*
Copy styles from the dummy text area to the textarea in the iframe
*/
FramedEngine.prototype.copyStyles = function() {
	// Copy all styles
	$tw.utils.copyStyles(this.dummyTextArea,this.domNode);
	// Override the ones that should not be set the same as the dummy textarea
	this.domNode.style.display = "block";
	this.domNode.style.width = "100%";
	this.domNode.style.margin = "0";
	this.domNode.style["background-color"] = this.widget.wiki.extractTiddlerDataItem(this.widget.wiki.getTiddlerText("$:/palette"),"tiddler-editor-background");
	// In Chrome setting -webkit-text-fill-color overrides the placeholder text colour
	this.domNode.style["-webkit-text-fill-color"] = "currentcolor";
};

/*
Set the text of the engine if it doesn't currently have focus
*/
FramedEngine.prototype.setText = function(text,type) {
	if(!this.domNode.isTiddlyWikiFakeDom) {
		if(this.domNode.ownerDocument.activeElement !== this.domNode) {
			this.domNode.value = text;
		}
		// Fix the height if needed
		this.fixHeight();
	}
};

/*
Get the text of the engine
*/
FramedEngine.prototype.getText = function() {
	return this.domNode.value;
};

/*
Fix the height of textarea to fit content
*/
FramedEngine.prototype.fixHeight = function() {
	// Make sure styles are updated
	this.copyStyles();
	// Adjust height
	if(this.widget.editTag === "textarea") {
		if(this.widget.editAutoHeight) {
			if(this.domNode && !this.domNode.isTiddlyWikiFakeDom) {
				var newHeight = $tw.utils.resizeTextAreaToFit(this.domNode,this.widget.editMinHeight);
				this.iframeNode.style.height = (newHeight + 14) + "px"; // +14 for the border on the textarea
			}
		} else {
			var fixedHeight = parseInt(this.widget.wiki.getTiddlerText(HEIGHT_VALUE_TITLE,"400px"),10);
			fixedHeight = Math.max(fixedHeight,20);
			this.domNode.style.height = fixedHeight + "px";
			this.iframeNode.style.height = (fixedHeight + 14) + "px";
		}
	}
};

/*
Focus the engine node
*/
FramedEngine.prototype.focus  = function() {
	if(this.domNode.focus && this.domNode.select) {
		this.domNode.focus();
		this.domNode.select();
	}
};
	
/*
Handle the focus event
*/
FramedEngine.prototype.handleFocusEvent = function(event) {
	this.widget.cancelPopups();
	return true;
};

/*
Handle a click
*/
FramedEngine.prototype.handleClickEvent = function(event) {
	this.fixHeight();
	return true;
};

/*
Handle a dom "input" event which occurs when the text has changed
*/
FramedEngine.prototype.handleInputEvent = function(event) {
	this.widget.saveChanges(this.getText());
	this.fixHeight();
	return true;
};

/*
Create a blank structure representing a text operation
*/
FramedEngine.prototype.createTextOperation = function() {
	var operation = {
		text: this.domNode.value,
		selStart: this.domNode.selectionStart,
		selEnd: this.domNode.selectionEnd,
		cutStart: null,
		cutEnd: null,
		replacement: null,
		newSelStart: null,
		newSelEnd: null
	};
	operation.selection = operation.text.substring(operation.selStart,operation.selEnd);
	return operation;
};

/*
Execute a text operation
*/
FramedEngine.prototype.executeTextOperation = function(operation) {
	// Perform the required changes to the text area and the underlying tiddler
	var newText = operation.text;
	if(operation.replacement !== null) {
		newText = operation.text.substring(0,operation.cutStart) + operation.replacement + operation.text.substring(operation.cutEnd);
		// Attempt to use a execCommand to modify the value of the control
		if(this.iframeDoc.queryCommandSupported("insertText") && this.iframeDoc.queryCommandSupported("delete") && !$tw.browser.isFirefox) {
			this.domNode.focus();
			this.domNode.setSelectionRange(operation.cutStart,operation.cutEnd);
			if(operation.replacement === "") {
				this.iframeDoc.execCommand("delete",false,"");
			} else {
				this.iframeDoc.execCommand("insertText",false,operation.replacement);
			}
		} else {
			this.domNode.value = newText;
		}
		this.domNode.focus();
		this.domNode.setSelectionRange(operation.newSelStart,operation.newSelEnd);
	}
	this.domNode.focus();
	return newText;
};

exports.FramedEngine = FramedEngine;

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/engines/simple.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/engines/simple.js
type: application/javascript
module-type: library

Text editor engine based on a simple input or textarea tag

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var HEIGHT_VALUE_TITLE = "$:/config/TextEditor/EditorHeight/Height";

function SimpleEngine(options) {
	// Save our options
	options = options || {};
	this.widget = options.widget;
	this.value = options.value;
	this.parentNode = options.parentNode;
	this.nextSibling = options.nextSibling;
	// Construct the textarea or input node
	var tag = this.widget.editTag;
	if($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {
		tag = "input";
	}
	this.domNode = this.widget.document.createElement(tag);
	// Set the text
	if(this.widget.editTag === "textarea") {
		this.domNode.appendChild(this.widget.document.createTextNode(this.value));
	} else {
		this.domNode.value = this.value;
	}
	// Set the attributes
	if(this.widget.editType) {
		this.domNode.setAttribute("type",this.widget.editType);
	}
	if(this.widget.editPlaceholder) {
		this.domNode.setAttribute("placeholder",this.widget.editPlaceholder);
	}
	if(this.widget.editSize) {
		this.domNode.setAttribute("size",this.widget.editSize);
	}
	if(this.widget.editRows) {
		this.domNode.setAttribute("rows",this.widget.editRows);
	}
	if(this.widget.editClass) {
		this.domNode.className = this.widget.editClass;
	}
	if(this.widget.editTabIndex) {
		this.domNode.setAttribute("tabindex",this.widget.editTabIndex);
	}
	// Add an input event handler
	$tw.utils.addEventListeners(this.domNode,[
		{name: "focus", handlerObject: this, handlerMethod: "handleFocusEvent"},
		{name: "input", handlerObject: this, handlerMethod: "handleInputEvent"}
	]);
	// Insert the element into the DOM
	this.parentNode.insertBefore(this.domNode,this.nextSibling);
	this.widget.domNodes.push(this.domNode);
}

/*
Set the text of the engine if it doesn't currently have focus
*/
SimpleEngine.prototype.setText = function(text,type) {
	if(!this.domNode.isTiddlyWikiFakeDom) {
		if(this.domNode.ownerDocument.activeElement !== this.domNode || text === "") {
			this.domNode.value = text;
		}
		// Fix the height if needed
		this.fixHeight();
	}
};

/*
Get the text of the engine
*/
SimpleEngine.prototype.getText = function() {
	return this.domNode.value;
};

/*
Fix the height of textarea to fit content
*/
SimpleEngine.prototype.fixHeight = function() {
	if(this.widget.editTag === "textarea") {
		if(this.widget.editAutoHeight) {
			if(this.domNode && !this.domNode.isTiddlyWikiFakeDom) {
				$tw.utils.resizeTextAreaToFit(this.domNode,this.widget.editMinHeight);
			}
		} else {
			var fixedHeight = parseInt(this.widget.wiki.getTiddlerText(HEIGHT_VALUE_TITLE,"400px"),10);
			fixedHeight = Math.max(fixedHeight,20);
			this.domNode.style.height = fixedHeight + "px";
		}
	}
};

/*
Focus the engine node
*/
SimpleEngine.prototype.focus  = function() {
	if(this.domNode.focus && this.domNode.select) {
		this.domNode.focus();
		this.domNode.select();
	}
};

/*
Handle a dom "input" event which occurs when the text has changed
*/
SimpleEngine.prototype.handleInputEvent = function(event) {
	this.widget.saveChanges(this.getText());
	this.fixHeight();
	return true;
};

/*
Handle a dom "focus" event
*/
SimpleEngine.prototype.handleFocusEvent = function(event) {
	this.widget.cancelPopups();
	if(this.widget.editFocusPopup) {
		$tw.popup.triggerPopup({
			domNode: this.domNode,
			title: this.widget.editFocusPopup,
			wiki: this.widget.wiki,
			force: true
		});
	}
	return true;
};

/*
Create a blank structure representing a text operation
*/
SimpleEngine.prototype.createTextOperation = function() {
	return null;
};

/*
Execute a text operation
*/
SimpleEngine.prototype.executeTextOperation = function(operation) {
};

exports.SimpleEngine = SimpleEngine;

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/factory.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/factory.js
type: application/javascript
module-type: library

Factory for constructing text editor widgets with specified engines for the toolbar and non-toolbar cases

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var DEFAULT_MIN_TEXT_AREA_HEIGHT = "100px"; // Minimum height of textareas in pixels

// Configuration tiddlers
var HEIGHT_MODE_TITLE = "$:/config/TextEditor/EditorHeight/Mode";
var ENABLE_TOOLBAR_TITLE = "$:/config/TextEditor/EnableToolbar";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

function editTextWidgetFactory(toolbarEngine,nonToolbarEngine) {

	var EditTextWidget = function(parseTreeNode,options) {
		// Initialise the editor operations if they've not been done already
		if(!this.editorOperations) {
			EditTextWidget.prototype.editorOperations = {};
			$tw.modules.applyMethods("texteditoroperation",this.editorOperations);
		}
		this.initialise(parseTreeNode,options);
	};

	/*
	Inherit from the base widget class
	*/
	EditTextWidget.prototype = new Widget();

	/*
	Render this widget into the DOM
	*/
	EditTextWidget.prototype.render = function(parent,nextSibling) {
		// Save the parent dom node
		this.parentDomNode = parent;
		// Compute our attributes
		this.computeAttributes();
		// Execute our logic
		this.execute();
		// Create the wrapper for the toolbar and render its content
		if(this.editShowToolbar) {
			this.toolbarNode = this.document.createElement("div");
			this.toolbarNode.className = "tc-editor-toolbar";
			parent.insertBefore(this.toolbarNode,nextSibling);
			this.renderChildren(this.toolbarNode,null);
			this.domNodes.push(this.toolbarNode);
		}
		// Create our element
		var editInfo = this.getEditInfo(),
			Engine = this.editShowToolbar ? toolbarEngine : nonToolbarEngine;
		this.engine = new Engine({
				widget: this,
				value: editInfo.value,
				type: editInfo.type,
				parentNode: parent,
				nextSibling: nextSibling
			});
		// Call the postRender hook
		if(this.postRender) {
			this.postRender();
		}
		// Fix height
		this.engine.fixHeight();
		// Focus if required
		if(this.editFocus === "true" || this.editFocus === "yes") {
			this.engine.focus();
		}
		// Add widget message listeners
		this.addEventListeners([
			{type: "tm-edit-text-operation", handler: "handleEditTextOperationMessage"}
		]);
	};

	/*
	Get the tiddler being edited and current value
	*/
	EditTextWidget.prototype.getEditInfo = function() {
		// Get the edit value
		var self = this,
			value,
			type = "text/plain",
			update;
		if(this.editIndex) {
			value = this.wiki.extractTiddlerDataItem(this.editTitle,this.editIndex,this.editDefault);
			update = function(value) {
				var data = self.wiki.getTiddlerData(self.editTitle,{});
				if(data[self.editIndex] !== value) {
					data[self.editIndex] = value;
					self.wiki.setTiddlerData(self.editTitle,data);
				}
			};
		} else {
			// Get the current tiddler and the field name
			var tiddler = this.wiki.getTiddler(this.editTitle);
			if(tiddler) {
				// If we've got a tiddler, the value to display is the field string value
				value = tiddler.getFieldString(this.editField);
				if(this.editField === "text") {
					type = tiddler.fields.type || "text/vnd.tiddlywiki";
				}
			} else {
				// Otherwise, we need to construct a default value for the editor
				switch(this.editField) {
					case "text":
						value = "Type the text for the tiddler '" + this.editTitle + "'";
						type = "text/vnd.tiddlywiki";
						break;
					case "title":
						value = this.editTitle;
						break;
					default:
						value = "";
						break;
				}
				if(this.editDefault !== undefined) {
					value = this.editDefault;
				}
			}
			update = function(value) {
				var tiddler = self.wiki.getTiddler(self.editTitle),
					updateFields = {
						title: self.editTitle
					};
				updateFields[self.editField] = value;
				self.wiki.addTiddler(new $tw.Tiddler(self.wiki.getCreationFields(),tiddler,updateFields,self.wiki.getModificationFields()));
			};
		}
		if(this.editType) {
			type = this.editType;
		}
		return {value: value || "", type: type, update: update};
	};

	/*
	Handle an edit text operation message from the toolbar
	*/
	EditTextWidget.prototype.handleEditTextOperationMessage = function(event) {
		// Prepare information about the operation
		var operation = this.engine.createTextOperation();
		// Invoke the handler for the selected operation
		var handler = this.editorOperations[event.param];
		if(handler) {
			handler.call(this,event,operation);
		}
		// Execute the operation via the engine
		var newText = this.engine.executeTextOperation(operation);
		// Fix the tiddler height and save changes
		this.engine.fixHeight();
		this.saveChanges(newText);
	};

	/*
	Compute the internal state of the widget
	*/
	EditTextWidget.prototype.execute = function() {
		// Get our parameters
		this.editTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
		this.editField = this.getAttribute("field","text");
		this.editIndex = this.getAttribute("index");
		this.editDefault = this.getAttribute("default");
		this.editClass = this.getAttribute("class");
		this.editPlaceholder = this.getAttribute("placeholder");
		this.editSize = this.getAttribute("size");
		this.editRows = this.getAttribute("rows");
		this.editAutoHeight = this.wiki.getTiddlerText(HEIGHT_MODE_TITLE,"auto");
		this.editAutoHeight = this.getAttribute("autoHeight",this.editAutoHeight === "auto" ? "yes" : "no") === "yes";
		this.editMinHeight = this.getAttribute("minHeight",DEFAULT_MIN_TEXT_AREA_HEIGHT);
		this.editFocusPopup = this.getAttribute("focusPopup");
		this.editFocus = this.getAttribute("focus");
		this.editTabIndex = this.getAttribute("tabindex");
		// Get the default editor element tag and type
		var tag,type;
		if(this.editField === "text") {
			tag = "textarea";
		} else {
			tag = "input";
			var fieldModule = $tw.Tiddler.fieldModules[this.editField];
			if(fieldModule && fieldModule.editTag) {
				tag = fieldModule.editTag;
			}
			if(fieldModule && fieldModule.editType) {
				type = fieldModule.editType;
			}
			type = type || "text";
		}
		// Get the rest of our parameters
		this.editTag = this.getAttribute("tag",tag);
		this.editType = this.getAttribute("type",type);
		// Make the child widgets
		this.makeChildWidgets();
		// Determine whether to show the toolbar
		this.editShowToolbar = this.wiki.getTiddlerText(ENABLE_TOOLBAR_TITLE,"yes");
		this.editShowToolbar = (this.editShowToolbar === "yes") && !!(this.children && this.children.length > 0) && (!this.document.isTiddlyWikiFakeDom);
	};

	/*
	Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
	*/
	EditTextWidget.prototype.refresh = function(changedTiddlers) {
		var changedAttributes = this.computeAttributes();
		// Completely rerender if any of our attributes have changed
		if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes["default"] || changedAttributes["class"] || changedAttributes.placeholder || changedAttributes.size || changedAttributes.autoHeight || changedAttributes.minHeight || changedAttributes.focusPopup ||  changedAttributes.rows || changedAttributes.tabindex || changedTiddlers[HEIGHT_MODE_TITLE] || changedTiddlers[ENABLE_TOOLBAR_TITLE]) {
			this.refreshSelf();
			return true;
		} else if(changedTiddlers[this.editTitle]) {
			var editInfo = this.getEditInfo();
			this.updateEditor(editInfo.value,editInfo.type);
		}
		this.engine.fixHeight();
		if(this.editShowToolbar) {
			return this.refreshChildren(changedTiddlers);
		} else {
			return false;
		}
	};

	/*
	Update the editor with new text. This method is separate from updateEditorDomNode()
	so that subclasses can override updateEditor() and still use updateEditorDomNode()
	*/
	EditTextWidget.prototype.updateEditor = function(text,type) {
		this.updateEditorDomNode(text,type);
	};

	/*
	Update the editor dom node with new text
	*/
	EditTextWidget.prototype.updateEditorDomNode = function(text,type) {
		this.engine.setText(text,type);
	};

	/*
	Save changes back to the tiddler store
	*/
	EditTextWidget.prototype.saveChanges = function(text) {
		var editInfo = this.getEditInfo();
		if(text !== editInfo.value) {
			editInfo.update(text);
		}
	};

	/*
	Cancel Popups
	*/
	EditTextWidget.prototype.cancelPopups = function() {
		$tw.popup.cancel(0,this.engine.domNode);
	};

	/*
	Handle a dom "keydown" event, which we'll bubble up to our container for the keyboard widgets benefit
	*/
	EditTextWidget.prototype.handleKeydownEvent = function(event) {
		// Check for a keyboard shortcut
		if(this.toolbarNode) {
			var shortcutElements = this.toolbarNode.querySelectorAll("[data-tw-keyboard-shortcut]");
			for(var index=0; index<shortcutElements.length; index++) {
				var el = shortcutElements[index],
					shortcutData = el.getAttribute("data-tw-keyboard-shortcut"),
					keyInfoArray = $tw.keyboardManager.parseKeyDescriptors(shortcutData,{
						wiki: this.wiki
					});
				if($tw.keyboardManager.checkKeyDescriptors(event,keyInfoArray)) {
					var clickEvent = this.document.createEvent("Events");
				    clickEvent.initEvent("click",true,false);
				    el.dispatchEvent(clickEvent);
					event.preventDefault();
					event.stopPropagation();
					return true;
				}
			}
		}
		// Propogate the event to the container
		if(this.propogateKeydownEvent(event)) {
			// Ignore the keydown if it was already handled
			event.preventDefault();
			event.stopPropagation();
			return true;
		}
		// Otherwise, process the keydown normally
		return false;
	};

	/*
	Propogate keydown events to our container for the keyboard widgets benefit
	*/
	EditTextWidget.prototype.propogateKeydownEvent = function(event) {
		var newEvent = this.document.createEventObject ? this.document.createEventObject() : this.document.createEvent("Events");
		if(newEvent.initEvent) {
			newEvent.initEvent("keydown", true, true);
		}
		newEvent.keyCode = event.keyCode;
		newEvent.which = event.which;
		newEvent.metaKey = event.metaKey;
		newEvent.ctrlKey = event.ctrlKey;
		newEvent.altKey = event.altKey;
		newEvent.shiftKey = event.shiftKey;
		return !this.parentDomNode.dispatchEvent(newEvent);
	};

	return EditTextWidget;

}

exports.editTextWidgetFactory = editTextWidgetFactory;

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/bitmap/clear.js","bitmapeditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/bitmap/clear.js
type: application/javascript
module-type: bitmapeditoroperation

Bitmap editor operation to clear the image

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["clear"] = function(event) {
	var ctx = this.canvasDomNode.getContext("2d");
	ctx.globalAlpha = 1;
	ctx.fillStyle = event.paramObject.colour || "white";
	ctx.fillRect(0,0,this.canvasDomNode.width,this.canvasDomNode.height);
	// Save changes
	this.strokeEnd();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/bitmap/resize.js","bitmapeditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/bitmap/resize.js
type: application/javascript
module-type: bitmapeditoroperation

Bitmap editor operation to resize the image

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["resize"] = function(event) {
	// Get the new width
	var newWidth = parseInt(event.paramObject.width || this.canvasDomNode.width,10),
		newHeight = parseInt(event.paramObject.height || this.canvasDomNode.height,10);
	// Update if necessary
	if(newWidth > 0 && newHeight > 0 && !(newWidth === this.currCanvas.width && newHeight === this.currCanvas.height)) {
		this.changeCanvasSize(newWidth,newHeight);
	}
	// Update the input controls
	this.refreshToolbar();
	// Save the image into the tiddler
	this.saveChanges();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/bitmap/rotate-left.js","bitmapeditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/bitmap/rotate-left.js
type: application/javascript
module-type: bitmapeditoroperation

Bitmap editor operation to rotate the image left by 90 degrees

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["rotate-left"] = function(event) {
	// Rotate the canvas left by 90 degrees
	this.rotateCanvasLeft();
	// Update the input controls
	this.refreshToolbar();
	// Save the image into the tiddler
	this.saveChanges();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/excise.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/excise.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to excise the selection to a new tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["excise"] = function(event,operation) {
	var editTiddler = this.wiki.getTiddler(this.editTitle),
		editTiddlerTitle = this.editTitle;
	if(editTiddler && editTiddler.fields["draft.of"]) {
		editTiddlerTitle = editTiddler.fields["draft.of"];
	}
	var excisionTitle = event.paramObject.title || this.wiki.generateNewTitle("New Excision");
	this.wiki.addTiddler(new $tw.Tiddler(
		this.wiki.getCreationFields(),
		this.wiki.getModificationFields(),
		{
			title: excisionTitle,
			text: operation.selection,
			tags: event.paramObject.tagnew === "yes" ?  [editTiddlerTitle] : []
		}
	));
	operation.replacement = excisionTitle;
	switch(event.paramObject.type || "transclude") {
		case "transclude":
			operation.replacement = "{{" + operation.replacement+ "}}";
			break;
		case "link":
			operation.replacement = "[[" + operation.replacement+ "]]";
			break;
		case "macro":
			operation.replacement = "<<" + (event.paramObject.macro || "translink") + " \"\"\"" + operation.replacement + "\"\"\">>";
			break;
	}
	operation.cutStart = operation.selStart;
	operation.cutEnd = operation.selEnd;
	operation.newSelStart = operation.selStart;
	operation.newSelEnd = operation.selStart + operation.replacement.length;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/make-link.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/make-link.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to make a link

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["make-link"] = function(event,operation) {
	if(operation.selection) {
		operation.replacement = "[[" + operation.selection + "|" + event.paramObject.text + "]]";
		operation.cutStart = operation.selStart;
		operation.cutEnd = operation.selEnd;
	} else {
		operation.replacement = "[[" + event.paramObject.text + "]]";
		operation.cutStart = operation.selStart;
		operation.cutEnd = operation.selEnd;
	}
	operation.newSelStart = operation.selStart + operation.replacement.length;
	operation.newSelEnd = operation.newSelStart;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/prefix-lines.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/prefix-lines.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to add a prefix to the selected lines

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["prefix-lines"] = function(event,operation) {
	// Cut just past the preceding line break, or the start of the text
	operation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);
	// Cut to just past the following line break, or to the end of the text
	operation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);
	// Compose the required prefix
	var prefix = $tw.utils.repeat(event.paramObject.character,event.paramObject.count);
	// Process each line
	var lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\r?\n/mg);
	$tw.utils.each(lines,function(line,index) {
		// Remove and count any existing prefix characters
		var count = 0;
		while(line.charAt(0) === event.paramObject.character) {
			line = line.substring(1);
			count++;
		}
		// Remove any whitespace
		while(line.charAt(0) === " ") {
			line = line.substring(1);
		}
		// We're done if we removed the exact required prefix, otherwise add it
		if(count !== event.paramObject.count) {
			// Apply the prefix
			line =  prefix + " " + line;
		}
		// Save the modified line
		lines[index] = line;
	});
	// Stitch the replacement text together and set the selection
	operation.replacement = lines.join("\n");
	if(lines.length === 1) {
		operation.newSelStart = operation.cutStart + operation.replacement.length;
		operation.newSelEnd = operation.newSelStart;
	} else {
		operation.newSelStart = operation.cutStart;
		operation.newSelEnd = operation.newSelStart + operation.replacement.length;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/replace-all.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/replace-all.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to replace the entire text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["replace-all"] = function(event,operation) {
	operation.cutStart = 0;
	operation.cutEnd = operation.text.length;
	operation.replacement = event.paramObject.text;
	operation.newSelStart = 0;
	operation.newSelEnd = operation.replacement.length;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/replace-selection.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/replace-selection.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to replace the selection

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["replace-selection"] = function(event,operation) {
	operation.replacement = event.paramObject.text;
	operation.cutStart = operation.selStart;
	operation.cutEnd = operation.selEnd;
	operation.newSelStart = operation.selStart;
	operation.newSelEnd = operation.selStart + operation.replacement.length;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/save-selection.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/save-selection.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to save the current selection in a specified tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["save-selection"] = function(event,operation) {
	var tiddler = event.paramObject.tiddler,
		field = event.paramObject.field || "text";
	if(tiddler && field) {
		this.wiki.setText(tiddler,field,null,operation.text.substring(operation.selStart,operation.selEnd));
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/wrap-lines.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/wrap-lines.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to wrap the selected lines with a prefix and suffix

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["wrap-lines"] = function(event,operation) {
	// Cut just past the preceding line break, or the start of the text
	operation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);
	// Cut to just past the following line break, or to the end of the text
	operation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);
	// Add the prefix and suffix
	operation.replacement = event.paramObject.prefix + "\n" +
				operation.text.substring(operation.cutStart,operation.cutEnd) + "\n" +
				event.paramObject.suffix + "\n";
	operation.newSelStart = operation.cutStart + event.paramObject.prefix.length + 1;
	operation.newSelEnd = operation.newSelStart + (operation.cutEnd - operation.cutStart);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/editor/operations/text/wrap-selection.js","texteditoroperation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/editor/operations/text/wrap-selection.js
type: application/javascript
module-type: texteditoroperation

Text editor operation to wrap the selection with the specified prefix and suffix

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports["wrap-selection"] = function(event,operation) {
	if(operation.selStart === operation.selEnd) {
		// No selection; check if we're within the prefix/suffix
		if(operation.text.substring(operation.selStart - event.paramObject.prefix.length,operation.selStart + event.paramObject.suffix.length) === event.paramObject.prefix + event.paramObject.suffix) {
			// Remove the prefix and suffix
			operation.cutStart = operation.selStart - event.paramObject.prefix.length;
			operation.cutEnd = operation.selEnd + event.paramObject.suffix.length;
			operation.replacement = "";
			operation.newSelStart = operation.cutStart;
			operation.newSelEnd = operation.newSelStart;
		} else {
			// Wrap the cursor instead
			operation.cutStart = operation.selStart;
			operation.cutEnd = operation.selEnd;
			operation.replacement = event.paramObject.prefix + event.paramObject.suffix;
			operation.newSelStart = operation.selStart + event.paramObject.prefix.length;
			operation.newSelEnd = operation.newSelStart;
		}
	} else if(operation.text.substring(operation.selStart,operation.selStart + event.paramObject.prefix.length) === event.paramObject.prefix && operation.text.substring(operation.selEnd - event.paramObject.suffix.length,operation.selEnd) === event.paramObject.suffix) {
		// Prefix and suffix are already present, so remove them
		operation.cutStart = operation.selStart;
		operation.cutEnd = operation.selEnd;
		operation.replacement = operation.selection.substring(event.paramObject.prefix.length,operation.selection.length - event.paramObject.suffix.length);
		operation.newSelStart = operation.selStart;
		operation.newSelEnd = operation.selStart + operation.replacement.length;
	} else {
		// Add the prefix and suffix
		operation.cutStart = operation.selStart;
		operation.cutEnd = operation.selEnd;
		operation.replacement = event.paramObject.prefix + operation.selection + event.paramObject.suffix;
		operation.newSelStart = operation.selStart;
		operation.newSelEnd = operation.selStart + operation.replacement.length;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/addprefix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/addprefix.js
type: application/javascript
module-type: filteroperator

Filter operator for adding a prefix to each title in the list. This is
especially useful in contexts where only a filter expression is allowed
and macro substitution isn't available.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.addprefix = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(operator.operand + title);
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/addsuffix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/addsuffix.js
type: application/javascript
module-type: filteroperator

Filter operator for adding a suffix to each title in the list. This is
especially useful in contexts where only a filter expression is allowed
and macro substitution isn't available.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.addsuffix = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(title + operator.operand);
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/after.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/after.js
type: application/javascript
module-type: filteroperator

Filter operator returning the tiddler from the current list that is after the tiddler named in the operand.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.after = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	var index = results.indexOf(operator.operand);
	if(index === -1 || index > (results.length - 2)) {
		return [];
	} else {
		return [results[index + 1]];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/current.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/current.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[current]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.current = function(source,prefix,options) {
	var currTiddlerTitle = options.widget && options.widget.getVariable("currentTiddler");
	if(currTiddlerTitle) {
		return [currTiddlerTitle];
	} else {
		return [];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/missing.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/missing.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[missing]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.missing = function(source,prefix,options) {
	return options.wiki.getMissingTitles();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/orphans.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/orphans.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[orphans]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.orphans = function(source,prefix,options) {
	return options.wiki.getOrphanTitles();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/shadows.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/shadows.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[shadows]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.shadows = function(source,prefix,options) {
	return options.wiki.allShadowTitles();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/tags.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/tags.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[tags]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tags = function(source,prefix,options) {
	return Object.keys(options.wiki.getTagMap());
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all/tiddlers.js","allfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all/tiddlers.js
type: application/javascript
module-type: allfilteroperator

Filter function for [all[tiddlers]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tiddlers = function(source,prefix,options) {
	return options.wiki.allTitles();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/all.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/all.js
type: application/javascript
module-type: filteroperator

Filter operator for selecting tiddlers

[all[shadows+tiddlers]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var allFilterOperators;

function getAllFilterOperators() {
	if(!allFilterOperators) {
		allFilterOperators = {};
		$tw.modules.applyMethods("allfilteroperator",allFilterOperators);
	}
	return allFilterOperators;
}

/*
Export our filter function
*/
exports.all = function(source,operator,options) {
	// Get our suboperators
	var allFilterOperators = getAllFilterOperators();
	// Cycle through the suboperators accumulating their results
	var results = [],
		subops = operator.operand.split("+");
	// Check for common optimisations
	if(subops.length === 1 && subops[0] === "") {
		return source;
	} else if(subops.length === 1 && subops[0] === "tiddlers") {
		return options.wiki.each;
	} else if(subops.length === 1 && subops[0] === "shadows") {
		return options.wiki.eachShadow;
	} else if(subops.length === 2 && subops[0] === "tiddlers" && subops[1] === "shadows") {
		return options.wiki.eachTiddlerPlusShadows;
	} else if(subops.length === 2 && subops[0] === "shadows" && subops[1] === "tiddlers") {
		return options.wiki.eachShadowPlusTiddlers;
	}
	// Do it the hard way
	for(var t=0; t<subops.length; t++) {
		var subop = allFilterOperators[subops[t]];
		if(subop) {
			$tw.utils.pushTop(results,subop(source,operator.prefix,options));
		}
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/backlinks.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/backlinks.js
type: application/javascript
module-type: filteroperator

Filter operator for returning all the backlinks from a tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.backlinks = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		$tw.utils.pushTop(results,options.wiki.getTiddlerBacklinks(title));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/before.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/before.js
type: application/javascript
module-type: filteroperator

Filter operator returning the tiddler from the current list that is before the tiddler named in the operand.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.before = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	var index = results.indexOf(operator.operand);
	if(index <= 0) {
		return [];
	} else {
		return [results[index - 1]];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/commands.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/commands.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the commands available in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.commands = function(source,operator,options) {
	var results = [];
	$tw.utils.each($tw.commands,function(commandInfo,name) {
		results.push(name);
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/contains.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/contains.js
type: application/javascript
module-type: filteroperator

Filter operator for finding values in array fields

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.contains = function(source,operator,options) {
	var results = [],
		fieldname = (operator.suffix || "list").toLowerCase();
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(tiddler) {
				var list = tiddler.getFieldList(fieldname);
				if(list.indexOf(operator.operand) === -1) {
					results.push(title);
				}
			} else {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(tiddler) {
				var list = tiddler.getFieldList(fieldname);
				if(list.indexOf(operator.operand) !== -1) {
					results.push(title);
				}
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/count.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/count.js
type: application/javascript
module-type: filteroperator

Filter operator returning the number of entries in the current list.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.count = function(source,operator,options) {
	var count = 0;
	source(function(tiddler,title) {
		count++;
	});
	return [count + ""];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/days.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/days.js
type: application/javascript
module-type: filteroperator

Filter operator that selects tiddlers with a specified date field within a specified date interval.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.days = function(source,operator,options) {
	var results = [],
		fieldName = operator.suffix || "modified",
		dayInterval = (parseInt(operator.operand,10)||0),
		dayIntervalSign = $tw.utils.sign(dayInterval),
		targetTimeStamp = (new Date()).setHours(0,0,0,0) + 1000*60*60*24*dayInterval,
		isWithinDays = function(dateField) {
			var sign = $tw.utils.sign(targetTimeStamp - (new Date(dateField)).setHours(0,0,0,0));
			return sign === 0 || sign === dayIntervalSign;
		};

	if(operator.prefix === "!") {
		targetTimeStamp = targetTimeStamp - 1000*60*60*24*dayIntervalSign;
		source(function(tiddler,title) {
			if(tiddler && tiddler.fields[fieldName]) {
				if(!isWithinDays($tw.utils.parseDate(tiddler.fields[fieldName]))) {
					results.push(title);
				}
			}
		});
	} else {
		source(function(tiddler,title) {
			if(tiddler && tiddler.fields[fieldName]) {
				if(isWithinDays($tw.utils.parseDate(tiddler.fields[fieldName]))) {
					results.push(title);
				}
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/each.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/each.js
type: application/javascript
module-type: filteroperator

Filter operator that selects one tiddler for each unique value of the specified field.
With suffix "list", selects all tiddlers that are values in a specified list field.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.each = function(source,operator,options) {
	var results =[] ,
	value,values = {},
	field = operator.operand || "title";
	if(operator.suffix === "value" && field === "title") {
		source(function(tiddler,title) {
			if(!$tw.utils.hop(values,title)) {
				values[title] = true;
				results.push(title);
			}
		});
	} else if(operator.suffix !== "list-item") {
		if(field === "title") {
			source(function(tiddler,title) {
				if(tiddler && !$tw.utils.hop(values,title)) {
					values[title] = true;
					results.push(title);
				}
			});
		} else {
			source(function(tiddler,title) {
				if(tiddler) {
					value = tiddler.getFieldString(field);
					if(!$tw.utils.hop(values,value)) {
						values[value] = true;
						results.push(title);
					}
				}
			});
		}
	} else {
		source(function(tiddler,title) {
			if(tiddler) {
				$tw.utils.each(
					options.wiki.getTiddlerList(title,field),
					function(value) {
						if(!$tw.utils.hop(values,value)) {
							values[value] = true;
							results.push(value);
						}
					}
				);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/eachday.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/eachday.js
type: application/javascript
module-type: filteroperator

Filter operator that selects one tiddler for each unique day covered by the specified date field

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.eachday = function(source,operator,options) {
	var results = [],
		values = [],
		fieldName = operator.operand || "modified";
	// Function to convert a date/time to a date integer
	var toDate = function(value) {
		value = (new Date(value)).setHours(0,0,0,0);
		return value+0;
	};
	source(function(tiddler,title) {
		if(tiddler && tiddler.fields[fieldName]) {
			var value = toDate($tw.utils.parseDate(tiddler.fields[fieldName]));
			if(values.indexOf(value) === -1) {
				values.push(value);
				results.push(title);
			}
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/editiondescription.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/editiondescription.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the descriptions of the specified edition names

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.editiondescription = function(source,operator,options) {
	var results = [],
		editionInfo = $tw.utils.getEditionInfo();
	if(editionInfo) {
		source(function(tiddler,title) {
			if($tw.utils.hop(editionInfo,title)) {
				results.push(editionInfo[title].description || "");				
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/editions.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/editions.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the available editions in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.editions = function(source,operator,options) {
	var results = [],
		editionInfo = $tw.utils.getEditionInfo();
	if(editionInfo) {
		$tw.utils.each(editionInfo,function(info,name) {
			results.push(name);
		});
	}
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/decodeuricomponent.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/decodeuricomponent.js
type: application/javascript
module-type: filteroperator

Filter operator for applying decodeURIComponent() to each item.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter functions
*/

exports.decodeuricomponent = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var value = title;
		try {
			value = decodeURIComponent(title);
		} catch(e) {
		}
		results.push(value);
	});
	return results;
};

exports.encodeuricomponent = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(encodeURIComponent(title));
	});
	return results;
};

exports.decodeuri = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var value = title;
		try {
			value = decodeURI(title);
		} catch(e) {
		}
		results.push(value);
	});
	return results;
};

exports.encodeuri = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(encodeURI(title));
	});
	return results;
};

exports.decodehtml = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push($tw.utils.htmlDecode(title));
	});
	return results;
};

exports.encodehtml = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push($tw.utils.htmlEncode(title));
	});
	return results;
};

exports.stringify = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push($tw.utils.stringify(title));
	});
	return results;
};

exports.jsonstringify = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push($tw.utils.jsonStringify(title));
	});
	return results;
};

exports.escaperegexp = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push($tw.utils.escapeRegExp(title));
	});
	return results;
};

exports.escapecss = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		// escape any character with a special meaning in CSS using CSS.escape()
		results.push(CSS.escape(title));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/enlist.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/enlist.js
type: application/javascript
module-type: filteroperator

Filter operator returning its operand parsed as a list

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.enlist = function(source,operator,options) {
	var allowDuplicates = false;
	switch(operator.suffix) {
		case "raw":
			allowDuplicates = true;
			break;
		case "dedupe":
			allowDuplicates = false;
			break;
	}
	var list = $tw.utils.parseStringArray(operator.operand,allowDuplicates);
	if(operator.prefix === "!") {
		var results = [];
		source(function(tiddler,title) {
			if(list.indexOf(title) === -1) {
				results.push(title);
			}
		});
		return results;
	} else {
		return list;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/field.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/field.js
type: application/javascript
module-type: filteroperator

Filter operator for comparing fields for equality

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.field = function(source,operator,options) {
	var results = [],indexedResults,
		fieldname = (operator.suffix || operator.operator || "title").toLowerCase();
	if(operator.prefix === "!") {
		if(operator.regexp) {
			source(function(tiddler,title) {
				if(tiddler) {
					var text = tiddler.getFieldString(fieldname);
					if(text !== null && !operator.regexp.exec(text)) {
						results.push(title);
					}
				} else {
					results.push(title);
				}
			});
		} else {
			source(function(tiddler,title) {
				if(tiddler) {
					var text = tiddler.getFieldString(fieldname);
					if(text !== null && text !== operator.operand) {
						results.push(title);
					}
				} else {
					results.push(title);
				}
			});
		}
	} else {
		if(operator.regexp) {
			source(function(tiddler,title) {
				if(tiddler) {
					var text = tiddler.getFieldString(fieldname);
					if(text !== null && !!operator.regexp.exec(text)) {
						results.push(title);
					}
				}
			});
		} else {
			if(source.byField) {
				indexedResults = source.byField(fieldname,operator.operand);
				if(indexedResults) {
					return indexedResults
				}
			}
			source(function(tiddler,title) {
				if(tiddler) {
					var text = tiddler.getFieldString(fieldname);
					if(text !== null && text === operator.operand) {
						results.push(title);
					}
				}
			});
		}
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/fields.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/fields.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the fields on the selected tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.fields = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		if(tiddler) {
			for(var fieldName in tiddler.fields) {
				$tw.utils.pushTop(results,fieldName);
			}
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/get.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/get.js
type: application/javascript
module-type: filteroperator

Filter operator for replacing tiddler titles by the value of the field specified in the operand.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.get = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		if(tiddler) {
			var value = tiddler.getFieldString(operator.operand);
			if(value) {
				results.push(value);
			}
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/getindex.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/getindex.js
type: application/javascript
module-type: filteroperator

returns the value at a given index of datatiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.getindex = function(source,operator,options) {
	var data,title,results = [];
	if(operator.operand){
		source(function(tiddler,title) {
			title = tiddler ? tiddler.fields.title : title;
			data = options.wiki.extractTiddlerDataItem(tiddler,operator.operand);
			if(data) {
				results.push(data);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/getvariable.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/getvariable.js
type: application/javascript
module-type: filteroperator

Filter operator for replacing input values by the value of the variable with the same name, or blank if the variable is missing

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.getvariable = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(options.widget.getVariable(title) || "");
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/has.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/has.js
type: application/javascript
module-type: filteroperator

Filter operator for checking if a tiddler has the specified field

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.has = function(source,operator,options) {
	var results = [],
		invert = operator.prefix === "!";

	if(operator.suffix === "field") {
		if(invert) {
			source(function(tiddler,title) {
				if(!tiddler || (tiddler && (!$tw.utils.hop(tiddler.fields,operator.operand)))) {
					results.push(title);
				}
			});
		} else {
			source(function(tiddler,title) {
				if(tiddler && $tw.utils.hop(tiddler.fields,operator.operand)) {
					results.push(title);
				}
			});
		}
	} else {
		if(invert) {
			source(function(tiddler,title) {
				if(!tiddler || !$tw.utils.hop(tiddler.fields,operator.operand) || (tiddler.fields[operator.operand] === "")) {
					results.push(title);
				}
			});
		} else {
			source(function(tiddler,title) {
				if(tiddler && $tw.utils.hop(tiddler.fields,operator.operand) && !(tiddler.fields[operator.operand] === "" || tiddler.fields[operator.operand].length === 0)) {
					results.push(title);
				}
			});				
		}
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/haschanged.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/haschanged.js
type: application/javascript
module-type: filteroperator

Filter operator returns tiddlers from the list that have a non-zero changecount.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.haschanged = function(source,operator,options) {
	var results = [];
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(options.wiki.getChangeCount(title) === 0) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(options.wiki.getChangeCount(title) > 0) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/indexes.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/indexes.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the indexes of a data tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.indexes = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var data = options.wiki.getTiddlerDataCached(title);
		if(data) {
			$tw.utils.pushTop(results,Object.keys(data));
		}
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/insertbefore.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/insertbefore.js
type: application/javascript
module-type: filteroperator

Insert an item before another item in a list

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Order a list
*/
exports.insertbefore = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	var target = options.widget && options.widget.getVariable(operator.suffix || "currentTiddler");
	if(target !== operator.operand) {
		// Remove the entry from the list if it is present
		var pos = results.indexOf(operator.operand);
		if(pos !== -1) {
			results.splice(pos,1);
		}
		// Insert the entry before the target marker
		pos = results.indexOf(target);
		if(pos !== -1) {
			results.splice(pos,0,operator.operand);
		} else {
			results.push(operator.operand);
		}
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/blank.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/blank.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[blank]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.blank = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(title) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(!title) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/current.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/current.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[current]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.current = function(source,prefix,options) {
	var results = [],
		currTiddlerTitle = options.widget && options.widget.getVariable("currentTiddler");
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(title !== currTiddlerTitle) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(title === currTiddlerTitle) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/image.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/image.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[image]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.image = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!options.wiki.isImageTiddler(title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(options.wiki.isImageTiddler(title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/missing.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/missing.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[missing]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.missing = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(options.wiki.tiddlerExists(title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(!options.wiki.tiddlerExists(title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/orphan.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/orphan.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[orphan]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.orphan = function(source,prefix,options) {
	var results = [],
		orphanTitles = options.wiki.getOrphanTitles();
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(orphanTitles.indexOf(title) === -1) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(orphanTitles.indexOf(title) !== -1) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/shadow.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/shadow.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[shadow]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.shadow = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!options.wiki.isShadowTiddler(title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(options.wiki.isShadowTiddler(title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/system.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/system.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[system]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.system = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!options.wiki.isSystemTiddler(title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(options.wiki.isSystemTiddler(title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/tag.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/tag.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[tag]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tag = function(source,prefix,options) {
	var results = [],
		tagMap = options.wiki.getTagMap();
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!$tw.utils.hop(tagMap,title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if($tw.utils.hop(tagMap,title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/tiddler.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/tiddler.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[tiddler]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tiddler = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!options.wiki.tiddlerExists(title)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(options.wiki.tiddlerExists(title)) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is/variable.js","isfilteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is/variable.js
type: application/javascript
module-type: isfilteroperator

Filter function for [is[variable]]

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.variable = function(source,prefix,options) {
	var results = [];
	if(prefix === "!") {
		source(function(tiddler,title) {
			if(!(title in options.widget.variables)) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(title in options.widget.variables) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/is.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/is.js
type: application/javascript
module-type: filteroperator

Filter operator for checking tiddler properties

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var isFilterOperators;

function getIsFilterOperators() {
	if(!isFilterOperators) {
		isFilterOperators = {};
		$tw.modules.applyMethods("isfilteroperator",isFilterOperators);
	}
	return isFilterOperators;
}

/*
Export our filter function
*/
exports.is = function(source,operator,options) {
	// Dispatch to the correct isfilteroperator
	var isFilterOperators = getIsFilterOperators();
	if(operator.operand) {
		var isFilterOperator = isFilterOperators[operator.operand];
		if(isFilterOperator) {
			return isFilterOperator(source,operator.prefix,options);
		} else {
			return [$tw.language.getString("Error/IsFilterOperator")];
		}
	} else {
		// Return all tiddlers if the operand is missing
		var results = [];
		source(function(tiddler,title) {
			results.push(title);
		});
		return results;
	}
};

})();
;})();
return exports;
}));
_define("$:/core/modules/filters/limit.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/limit.js
type: application/javascript
module-type: filteroperator

Filter operator for chopping the results to a specified maximum number of entries

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.limit = function(source,operator,options) {
	var results = [];
	// Convert to an array
	source(function(tiddler,title) {
		results.push(title);
	});
	// Slice the array if necessary
	var limit = Math.min(results.length,parseInt(operator.operand,10));
	if(operator.prefix === "!") {
		results = results.slice(-limit);
	} else {
		results = results.slice(0,limit);
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/links.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/links.js
type: application/javascript
module-type: filteroperator

Filter operator for returning all the links from a tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.links = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		$tw.utils.pushTop(results,options.wiki.getTiddlerLinks(title));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/list.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/list.js
type: application/javascript
module-type: filteroperator

Filter operator returning the tiddlers whose title is listed in the operand tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.list = function(source,operator,options) {
	var results = [],
		tr = $tw.utils.parseTextReference(operator.operand),
		currTiddlerTitle = options.widget && options.widget.getVariable("currentTiddler"),
		list = options.wiki.getTiddlerList(tr.title || currTiddlerTitle,tr.field,tr.index);
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(list.indexOf(title) === -1) {
				results.push(title);
			}
		});
	} else {
		results = list;
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/listed.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/listed.js
type: application/javascript
module-type: filteroperator

Filter operator returning all tiddlers that have the selected tiddlers in a list

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.listed = function(source,operator,options) {
	var field = operator.operand || "list",
		results = [];
	source(function(tiddler,title) {
		$tw.utils.pushTop(results,options.wiki.findListingsOfTiddler(title,field));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/listops.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/listops.js
type: application/javascript
module-type: filteroperator

Filter operators for manipulating the current selection list

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Order a list
*/
exports.order = function(source,operator,options) {
	var results = [];
	if(operator.operand.toLowerCase() === "reverse") {
		source(function(tiddler,title) {
			results.unshift(title);
		});
	} else {
		source(function(tiddler,title) {
			results.push(title);
		});
	}
	return results;
};

/*
Reverse list
*/
exports.reverse = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.unshift(title);
	});
	return results;
};

/*
First entry/entries in list
*/
exports.first = function(source,operator,options) {
	var count = $tw.utils.getInt(operator.operand,1),
		results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results.slice(0,count);
};

/*
Last entry/entries in list
*/
exports.last = function(source,operator,options) {
	var count = $tw.utils.getInt(operator.operand,1),
		results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results.slice(-count);
};

/*
All but the first entry/entries of the list
*/
exports.rest = function(source,operator,options) {
	var count = $tw.utils.getInt(operator.operand,1),
		results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results.slice(count);
};
exports.butfirst = exports.rest;
exports.bf = exports.rest;

/*
All but the last entry/entries of the list
*/
exports.butlast = function(source,operator,options) {
	var count = $tw.utils.getInt(operator.operand,1),
		results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results.slice(0,-count);
};
exports.bl = exports.butlast;

/*
The nth member of the list
*/
exports.nth = function(source,operator,options) {
	var count = $tw.utils.getInt(operator.operand,1),
		results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results.slice(count - 1,count);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/lookup.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/lookup.js
type: application/javascript
module-type: filteroperator

Filter operator that looks up values via a title prefix

[lookup:<field>[<prefix>]]

Prepends the prefix to the selected items and returns the specified field value

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.lookup = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		results.push(options.wiki.getTiddlerText(operator.operand + title) || options.wiki.getTiddlerText(operator.operand + operator.suffix));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/math.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/math.js
type: application/javascript
module-type: filteroperator

Filter operators for math. Unary/binary operators work on each item in turn, and return a new item list.

Sum/product/maxall/minall operate on the entire list, returning a single item.

Note that strings are converted to numbers automatically. Trailing non-digits are ignored.

* "" converts to 0
* "12kk" converts to 12

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.negate = makeNumericBinaryOperator(
	function(a) {return -a}
);

exports.abs = makeNumericBinaryOperator(
	function(a) {return Math.abs(a)}
);

exports.ceil = makeNumericBinaryOperator(
	function(a) {return Math.ceil(a)}
);

exports.floor = makeNumericBinaryOperator(
	function(a) {return Math.floor(a)}
);

exports.round = makeNumericBinaryOperator(
	function(a) {return Math.round(a)}
);

exports.trunc = makeNumericBinaryOperator(
	function(a) {return Math.trunc(a)}
);

exports.untrunc = makeNumericBinaryOperator(
	function(a) {return Math.ceil(Math.abs(a)) * Math.sign(a)}
);

exports.sign = makeNumericBinaryOperator(
	function(a) {return Math.sign(a)}
);

exports.add = makeNumericBinaryOperator(
	function(a,b) {return a + b;}
);

exports.subtract = makeNumericBinaryOperator(
	function(a,b) {return a - b;}
);

exports.multiply = makeNumericBinaryOperator(
	function(a,b) {return a * b;}
);

exports.divide = makeNumericBinaryOperator(
	function(a,b) {return a / b;}
);

exports.remainder = makeNumericBinaryOperator(
	function(a,b) {return a % b;}
);

exports.max = makeNumericBinaryOperator(
	function(a,b) {return Math.max(a,b);}
);

exports.min = makeNumericBinaryOperator(
	function(a,b) {return Math.min(a,b);}
);

exports.fixed = makeNumericBinaryOperator(
	function(a,b) {return Number.prototype.toFixed.call(a,Math.min(Math.max(b,0),100));}
);

exports.precision = makeNumericBinaryOperator(
	function(a,b) {return Number.prototype.toPrecision.call(a,Math.min(Math.max(b,1),100));}
);

exports.exponential = makeNumericBinaryOperator(
	function(a,b) {return Number.prototype.toExponential.call(a,Math.min(Math.max(b,0),100));}
);

exports.sum = makeNumericReducingOperator(
	function(accumulator,value) {return accumulator + value},
	0 // Initial value
);

exports.product = makeNumericReducingOperator(
	function(accumulator,value) {return accumulator * value},
	1 // Initial value
);

exports.maxall = makeNumericReducingOperator(
	function(accumulator,value) {return Math.max(accumulator,value)},
	-Infinity // Initial value
);

exports.minall = makeNumericReducingOperator(
	function(accumulator,value) {return Math.min(accumulator,value)},
	Infinity // Initial value
);

function makeNumericBinaryOperator(fnCalc) {
	return function(source,operator,options) {
		var result = [],
			numOperand = parseNumber(operator.operand);
		source(function(tiddler,title) {
			result.push(stringifyNumber(fnCalc(parseNumber(title),numOperand)));
		});
		return result;
	};
}

function makeNumericReducingOperator(fnCalc,initialValue) {
	initialValue = initialValue || 0;
	return function(source,operator,options) {
		var result = [];
		source(function(tiddler,title) {
			result.push(title);
		});
		return [stringifyNumber(result.reduce(function(accumulator,currentValue) {
			return fnCalc(accumulator,parseNumber(currentValue));
		},initialValue))];
	};
}

function parseNumber(str) {
	return parseFloat(str) || 0;
}

function stringifyNumber(num) {
	return num + "";
}

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/minlength.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/minlength.js
type: application/javascript
module-type: filteroperator

Filter operator for filtering out titles that don't meet the minimum length in the operand

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.minlength = function(source,operator,options) {
	var results = [],
		minLength = parseInt(operator.operand || "",10) || 0;
	source(function(tiddler,title) {
		if(title.length >= minLength) {
			results.push(title);
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/modules.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/modules.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the titles of the modules of a given type in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.modules = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		$tw.utils.each($tw.modules.types[title],function(moduleInfo,moduleName) {
			results.push(moduleName);
		});
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/moduletypes.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/moduletypes.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the module types in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.moduletypes = function(source,operator,options) {
	var results = [];
	$tw.utils.each($tw.modules.types,function(moduleInfo,type) {
		results.push(type);
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/next.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/next.js
type: application/javascript
module-type: filteroperator

Filter operator returning the tiddler whose title occurs next in the list supplied in the operand tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.next = function(source,operator,options) {
	var results = [],
		list = options.wiki.getTiddlerList(operator.operand);
	source(function(tiddler,title) {
		var match = list.indexOf(title);
		// increment match and then test if result is in range
		match++;
		if(match > 0 && match < list.length) {
			results.push(list[match]);
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/plugintiddlers.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/plugintiddlers.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the titles of the shadow tiddlers within a plugin

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.plugintiddlers = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var pluginInfo = options.wiki.getPluginInfo(title) || options.wiki.getTiddlerDataCached(title,{tiddlers:[]});
		if(pluginInfo && pluginInfo.tiddlers) {
			$tw.utils.each(pluginInfo.tiddlers,function(fields,title) {
				results.push(title);
			});
		}
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/prefix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/prefix.js
type: application/javascript
module-type: filteroperator

Filter operator for checking if a title starts with a prefix

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.prefix = function(source,operator,options) {
	var results = [];
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(title.substr(0,operator.operand.length) !== operator.operand) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(title.substr(0,operator.operand.length) === operator.operand) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/previous.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/previous.js
type: application/javascript
module-type: filteroperator

Filter operator returning the tiddler whose title occurs immediately prior in the list supplied in the operand tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.previous = function(source,operator,options) {
	var results = [],
		list = options.wiki.getTiddlerList(operator.operand);
	source(function(tiddler,title) {
		var match = list.indexOf(title);
		// increment match and then test if result is in range
		match--;
		if(match >= 0) {
			results.push(list[match]);
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/range.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/range.js
type: application/javascript
module-type: filteroperator

Filter operator for generating a numeric range.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.range = function(source,operator,options) {
	var results = [];
	// Split the operand into numbers delimited by these symbols
	var parts = operator.operand.split(/[,:;]/g),
		beg, end, inc, i, fixed = 0;
	for (i=0; i<parts.length; i++) {
		// Validate real number
		if(!/^\s*[+-]?((\d+(\.\d*)?)|(\.\d+))\s*$/.test(parts[i])) {
			return ["range: bad number \"" + parts[i] + "\""];
		}
		// Count digits; the most precise number determines decimal places in output.
		var frac = /\.\d+/.exec(parts[i]);
		if(frac) {
			fixed = Math.max(fixed,frac[0].length-1);
		}
		parts[i] = parseFloat(parts[i]);
	}
	switch(parts.length) {
		case 1:
			end = parts[0];
			if (end >= 1) {
				beg = 1;
			}
			else if (end <= -1) {
				beg = -1;
			}
			else {
				return [];
			}
			inc = 1;
			break;
		case 2:
			beg = parts[0];
			end = parts[1];
			inc = 1;
			break;
		case 3:
			beg = parts[0];
			end = parts[1];
			inc = Math.abs(parts[2]);
			break;
	}
	if(inc === 0) {
		return ["range: increment 0 causes infinite loop"];
	}
	// May need to count backwards
	var direction = ((end < beg) ? -1 : 1);
	inc *= direction;
	// Estimate number of resulting elements
	if((end - beg) / inc > 10000) {
		return ["range: too many steps (over 10K)"];
	}
	// Avoid rounding error on last step
	end += direction * 0.5 * Math.pow(0.1,fixed);
	var safety = 10010;
	// Enumerate the range
	if (end<beg) {
		for(i=beg; i>end; i+=inc) {
			results.push(i.toFixed(fixed));
			if(--safety<0) {
				break;
			}
		}
	} else {
		for(i=beg; i<end; i+=inc) {
			results.push(i.toFixed(fixed));
			if(--safety<0) {
				break;
			}
		}
	}
	if(safety<0) {
		return ["range: unexpectedly large output"];
	}
	// Reverse?
	if(operator.prefix === "!") {
		results.reverse();
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/regexp.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/regexp.js
type: application/javascript
module-type: filteroperator

Filter operator for regexp matching

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.regexp = function(source,operator,options) {
	var results = [],
		fieldname = (operator.suffix || "title").toLowerCase(),
		regexpString, regexp, flags = "", match,
		getFieldString = function(tiddler,title) {
			if(tiddler) {
				return tiddler.getFieldString(fieldname);
			} else if(fieldname === "title") {
				return title;
			} else {
				return null;
			}
		};
	// Process flags and construct regexp
	regexpString = operator.operand;
	match = /^\(\?([gim]+)\)/.exec(regexpString);
	if(match) {
		flags = match[1];
		regexpString = regexpString.substr(match[0].length);
	} else {
		match = /\(\?([gim]+)\)$/.exec(regexpString);
		if(match) {
			flags = match[1];
			regexpString = regexpString.substr(0,regexpString.length - match[0].length);
		}
	}
	try {
		regexp = new RegExp(regexpString,flags);
	} catch(e) {
		return ["" + e];
	}
	// Process the incoming tiddlers
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			var text = getFieldString(tiddler,title);
			if(text !== null) {
				if(!regexp.exec(text)) {
					results.push(title);
				}
			}
		});
	} else {
		source(function(tiddler,title) {
			var text = getFieldString(tiddler,title);
			if(text !== null) {
				if(!!regexp.exec(text)) {
					results.push(title);
				}
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/removeprefix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/removeprefix.js
type: application/javascript
module-type: filteroperator

Filter operator for removing a prefix from each title in the list. Titles that do not start with the prefix are removed.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.removeprefix = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		if(title.substr(0,operator.operand.length) === operator.operand) {
			results.push(title.substr(operator.operand.length));
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/removesuffix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/removesuffix.js
type: application/javascript
module-type: filteroperator

Filter operator for removing a suffix from each title in the list. Titles that do not end with the suffix are removed.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.removesuffix = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		if(title && title.substr(-operator.operand.length) === operator.operand) {
			results.push(title.substr(0,title.length - operator.operand.length));
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/sameday.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/sameday.js
type: application/javascript
module-type: filteroperator

Filter operator that selects tiddlers with a modified date field on the same day as the provided value.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.sameday = function(source,operator,options) {
	var results = [],
		fieldName = operator.suffix || "modified",
		targetDate = (new Date($tw.utils.parseDate(operator.operand))).setHours(0,0,0,0);
	// Function to convert a date/time to a date integer
	source(function(tiddler,title) {
		if(tiddler) {
			if(tiddler.getFieldDay(fieldName) === targetDate) {
				results.push(title);
			}
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/search.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/search.js
type: application/javascript
module-type: filteroperator

Filter operator for searching for the text in the operand tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.search = function(source,operator,options) {
	var invert = operator.prefix === "!";
	if(operator.suffixes) {
		var hasFlag = function(flag) {
				return (operator.suffixes[1] || []).indexOf(flag) !== -1;
			},
			excludeFields = false,
			fieldList = operator.suffixes[0] || [],
			firstField = fieldList[0] || "", 
			firstChar = firstField.charAt(0),
			fields;
		if(firstChar === "-") {
			fields = [firstField.slice(1)].concat(fieldList.slice(1));
			excludeFields = true;
		} else if(fieldList[0] === "*"){
			fields = [];
			excludeFields = true;
		} else {
			fields = fieldList.slice(0);
		}
		return options.wiki.search(operator.operand,{
			source: source,
			invert: invert,
			field: fields,
			excludeField: excludeFields,
			caseSensitive: hasFlag("casesensitive"),
			literal: hasFlag("literal"),
			whitespace: hasFlag("whitespace"),
			regexp: hasFlag("regexp"),
			words: hasFlag("words")
		});
	} else {
		return options.wiki.search(operator.operand,{
			source: source,
			invert: invert
		});
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/shadowsource.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/shadowsource.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the source plugins for shadow tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.shadowsource = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var source = options.wiki.getShadowSource(title);
		if(source) {
			$tw.utils.pushTop(results,source);
		}
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/sort.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/sort.js
type: application/javascript
module-type: filteroperator

Filter operator for sorting

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.sort = function(source,operator,options) {
	var results = prepare_results(source);
	options.wiki.sortTiddlers(results,operator.operand || "title",operator.prefix === "!",false,false);
	return results;
};

exports.nsort = function(source,operator,options) {
	var results = prepare_results(source);
	options.wiki.sortTiddlers(results,operator.operand || "title",operator.prefix === "!",false,true);
	return results;
};

exports.sortan = function(source, operator, options) {
	var results = prepare_results(source);
	options.wiki.sortTiddlers(results, operator.operand || "title", operator.prefix === "!",false,false,true);
	return results;
};

exports.sortcs = function(source,operator,options) {
	var results = prepare_results(source);
	options.wiki.sortTiddlers(results,operator.operand || "title",operator.prefix === "!",true,false);
	return results;
};

exports.nsortcs = function(source,operator,options) {
	var results = prepare_results(source);
	options.wiki.sortTiddlers(results,operator.operand || "title",operator.prefix === "!",true,true);
	return results;
};

var prepare_results = function (source) {
	var results = [];
	source(function(tiddler,title) {
		results.push(title);
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/splitbefore.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/splitbefore.js
type: application/javascript
module-type: filteroperator

Filter operator that splits each result on the first occurance of the specified separator and returns the unique values.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.splitbefore = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var parts = title.split(operator.operand);
		if(parts.length === 1) {
			$tw.utils.pushTop(results,parts[0]);
		} else {
			$tw.utils.pushTop(results,parts[0] + operator.operand);
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/storyviews.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/storyviews.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the story views in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.storyviews = function(source,operator,options) {
	var results = [],
		storyviews = {};
	$tw.modules.applyMethods("storyview",storyviews);
	$tw.utils.each(storyviews,function(info,name) {
		results.push(name);
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/strings.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/strings.js
type: application/javascript
module-type: filteroperator

Filter operators for strings. Unary/binary operators work on each item in turn, and return a new item list.

Sum/product/maxall/minall operate on the entire list, returning a single item.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.length = makeStringBinaryOperator(
	function(a) {return ["" + ("" + a).length];}
);

exports.uppercase = makeStringBinaryOperator(
	function(a) {return [("" + a).toUpperCase()];}
);

exports.lowercase = makeStringBinaryOperator(
	function(a) {return [("" + a).toLowerCase()];}
);

exports.sentencecase = makeStringBinaryOperator(
	function(a) {return [$tw.utils.toSentenceCase(a)];}
);

exports.titlecase = makeStringBinaryOperator(
	function(a) {return [$tw.utils.toTitleCase(a)];}
);

exports.trim = makeStringBinaryOperator(
	function(a) {return [$tw.utils.trim(a)];}
);

exports.split = makeStringBinaryOperator(
	function(a,b) {return ("" + a).split(b);}
);

exports.join = makeStringReducingOperator(
	function(accumulator,value,operand) {
		if(accumulator === null) {
			return value;
		} else {
			return accumulator + operand + value;
		}
	},null
);

function makeStringBinaryOperator(fnCalc) {
	return function(source,operator,options) {
		var result = [];
		source(function(tiddler,title) {
			Array.prototype.push.apply(result,fnCalc(title,operator.operand || ""));
		});
		return result;
	};
}

function makeStringReducingOperator(fnCalc,initialValue) {
	return function(source,operator,options) {
		var result = [];
		source(function(tiddler,title) {
			result.push(title);
		});
		return [result.reduce(function(accumulator,currentValue) {
			return fnCalc(accumulator,currentValue,operator.operand || "");
		},initialValue)];
	};
}

exports.splitregexp = function(source,operator,options) {
	var result = [],
		suffix = operator.suffix || "",
		flags = (suffix.indexOf("m") !== -1 ? "m" : "") + (suffix.indexOf("i") !== -1 ? "i" : ""),
		regExp;
	try {
		regExp = new RegExp(operator.operand || "",flags);		
	} catch(ex) {
		return ["RegExp error: " + ex];
	}
	source(function(tiddler,title) {
		Array.prototype.push.apply(result,title.split(regExp));
	});		
	return result;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/subfilter.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/subfilter.js
type: application/javascript
module-type: filteroperator

Filter operator returning its operand evaluated as a filter

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.subfilter = function(source,operator,options) {
	var list = options.wiki.filterTiddlers(operator.operand,options.widget,source);
	if(operator.prefix === "!") {
		var results = [];
		source(function(tiddler,title) {
			if(list.indexOf(title) === -1) {
				results.push(title);
			}
		});
		return results;
	} else {
		return list;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/subtiddlerfields.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/subtiddlerfields.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the fields on the selected subtiddlers of the plugin named in the operand

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.subtiddlerfields = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		var subtiddler = options.wiki.getSubTiddler(operator.operand,title);
		if(subtiddler) {
			for(var fieldName in subtiddler.fields) {
				$tw.utils.pushTop(results,fieldName);
			}
		}
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/suffix.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/suffix.js
type: application/javascript
module-type: filteroperator

Filter operator for checking if a title ends with a suffix

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.suffix = function(source,operator,options) {
	var results = [];
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(title.substr(-operator.operand.length) !== operator.operand) {
				results.push(title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(title.substr(-operator.operand.length) === operator.operand) {
				results.push(title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/tag.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/tag.js
type: application/javascript
module-type: filteroperator

Filter operator for checking for the presence of a tag

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tag = function(source,operator,options) {
	var results = [],indexedResults;
	if((operator.suffix || "").toLowerCase() === "strict" && !operator.operand) {
		// New semantics:
		// Always return copy of input if operator.operand is missing
		source(function(tiddler,title) {
			results.push(title);
		});
	} else {
		// Old semantics:
		var tiddlers;
		if(operator.prefix === "!") {
			// Returns a copy of the input if operator.operand is missing
			tiddlers = options.wiki.getTiddlersWithTag(operator.operand);
			source(function(tiddler,title) {
				if(tiddlers.indexOf(title) === -1) {
					results.push(title);
				}
			});
		} else {
			// Returns empty results if operator.operand is missing
			if(source.byTag) {
				indexedResults = source.byTag(operator.operand);
				if(indexedResults) {
					return indexedResults;
				}
			} else {
				tiddlers = options.wiki.getTiddlersWithTag(operator.operand);
				source(function(tiddler,title) {
					if(tiddlers.indexOf(title) !== -1) {
						results.push(title);
					}
				});
				results = options.wiki.sortByList(results,operator.operand);
			}
		}		
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/tagging.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/tagging.js
type: application/javascript
module-type: filteroperator

Filter operator returning all tiddlers that are tagged with the selected tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tagging = function(source,operator,options) {
	var results = [];
	source(function(tiddler,title) {
		$tw.utils.pushTop(results,options.wiki.getTiddlersWithTag(title));
	});
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/tags.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/tags.js
type: application/javascript
module-type: filteroperator

Filter operator returning all the tags of the selected tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.tags = function(source,operator,options) {
	var tags = {};
	source(function(tiddler,title) {
		var t, length;
		if(tiddler && tiddler.fields.tags) {
			for(t=0, length=tiddler.fields.tags.length; t<length; t++) {
				tags[tiddler.fields.tags[t]] = true;
			}
		}
	});
	return Object.keys(tags);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/title.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/title.js
type: application/javascript
module-type: filteroperator

Filter operator for comparing title fields for equality

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.title = function(source,operator,options) {
	var results = [];
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(tiddler && tiddler.fields.title !== operator.operand) {
				results.push(title);
			}
		});
	} else {
		results.push(operator.operand);
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/untagged.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/untagged.js
type: application/javascript
module-type: filteroperator

Filter operator returning all the selected tiddlers that are untagged

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.untagged = function(source,operator,options) {
	var results = [];
	if(operator.prefix === "!") {
		source(function(tiddler,title) {
			if(tiddler && $tw.utils.isArray(tiddler.fields.tags) && tiddler.fields.tags.length > 0) {
				$tw.utils.pushTop(results,title);
			}
		});
	} else {
		source(function(tiddler,title) {
			if(!tiddler || !tiddler.hasField("tags") || ($tw.utils.isArray(tiddler.fields.tags) && tiddler.fields.tags.length === 0)) {
				$tw.utils.pushTop(results,title);
			}
		});
	}
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/variables.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/variables.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the active variables

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.variables = function(source,operator,options) {
	var names = [];
	for(var variable in options.widget.variables) {
		names.push(variable);
	}
	return names.sort();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/wikiparserrules.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/wikiparserrules.js
type: application/javascript
module-type: filteroperator

Filter operator for returning the names of the wiki parser rules in this wiki

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Export our filter function
*/
exports.wikiparserrules = function(source,operator,options) {
	var results = [],
		operand = operator.operand;
	$tw.utils.each($tw.modules.types.wikirule,function(mod) {
		var exp = mod.exports;
		if(!operand || exp.types[operand]) {
			results.push(exp.name);
		}
	});
	results.sort();
	return results;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/filters/x-listops.js","filteroperator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters/x-listops.js
type: application/javascript
module-type: filteroperator

Extended filter operators to manipulate the current list.

\*/
(function () {

    /*jslint node: true, browser: true */
    /*global $tw: false */
    "use strict";

    /*
    Fetch titles from the current list
    */
    var prepare_results = function (source) {
    var results = [];
        source(function (tiddler, title) {
            results.push(title);
        });
        return results;
    };

    /*
    Moves a number of items from the tail of the current list before the item named in the operand
    */
    exports.putbefore = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand),
            count = $tw.utils.getInt(operator.suffix,1);
        return (index === -1) ?
            results.slice(0, -1) :
            results.slice(0, index).concat(results.slice(-count)).concat(results.slice(index, -count));
    };

    /*
    Moves a number of items from the tail of the current list after the item named in the operand
    */
    exports.putafter = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand),
            count = $tw.utils.getInt(operator.suffix,1);
        return (index === -1) ?
            results.slice(0, -1) :
            results.slice(0, index + 1).concat(results.slice(-count)).concat(results.slice(index + 1, -count));
    };

    /*
    Replaces the item named in the operand with a number of items from the tail of the current list
    */
    exports.replace = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand),
            count = $tw.utils.getInt(operator.suffix,1);
        return (index === -1) ?
            results.slice(0, -count) :
            results.slice(0, index).concat(results.slice(-count)).concat(results.slice(index + 1, -count));
    };

    /*
    Moves a number of items from the tail of the current list to the head of the list
    */
    exports.putfirst = function (source, operator) {
        var results = prepare_results(source),
            count = $tw.utils.getInt(operator.suffix,1);
        return results.slice(-count).concat(results.slice(0, -count));
    };

    /*
    Moves a number of items from the head of the current list to the tail of the list
    */
    exports.putlast = function (source, operator) {
        var results = prepare_results(source),
            count = $tw.utils.getInt(operator.suffix,1);
        return results.slice(count).concat(results.slice(0, count));
    };

    /*
    Moves the item named in the operand a number of places forward or backward in the list
    */
    exports.move = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand),
            count = $tw.utils.getInt(operator.suffix,1),
            marker = results.splice(index, 1),
            offset =  (index + count) > 0 ? index + count : 0;
        return results.slice(0, offset).concat(marker).concat(results.slice(offset));
    };

    /*
    Returns the items from the current list that are after the item named in the operand
    */
    exports.allafter = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand);
        return (index === -1) ? [] :
            (operator.suffix) ? results.slice(index) :
            results.slice(index + 1);
    };

    /*
    Returns the items from the current list that are before the item named in the operand
    */
    exports.allbefore = function (source, operator) {
        var results = prepare_results(source),
            index = results.indexOf(operator.operand);
        return (index === -1) ? [] :
            (operator.suffix) ? results.slice(0, index + 1) :
            results.slice(0, index);
    };

    /*
    Appends the items listed in the operand array to the tail of the current list
    */
    exports.append = function (source, operator) {
        var append = $tw.utils.parseStringArray(operator.operand, "true"),
            results = prepare_results(source),
            count = parseInt(operator.suffix) || append.length;
        return (append.length === 0) ? results :
            (operator.prefix) ? results.concat(append.slice(-count)) :
            results.concat(append.slice(0, count));
    };

    /*
    Prepends the items listed in the operand array to the head of the current list
    */
    exports.prepend = function (source, operator) {
        var prepend = $tw.utils.parseStringArray(operator.operand, "true"),
            results = prepare_results(source),
            count = $tw.utils.getInt(operator.suffix,prepend.length);
        return (prepend.length === 0) ? results :
            (operator.prefix) ? prepend.slice(-count).concat(results) :
            prepend.slice(0, count).concat(results);
    };

    /*
    Returns all items from the current list except the items listed in the operand array
    */
    exports.remove = function (source, operator) {
        var array = $tw.utils.parseStringArray(operator.operand, "true"),
            results = prepare_results(source),
            count = parseInt(operator.suffix) || array.length,
            p,
            len,
            index;
        len = array.length - 1;
        for (p = 0; p < count; ++p) {
            if (operator.prefix) {
                index = results.indexOf(array[len - p]);
            } else {
                index = results.indexOf(array[p]);
            }
            if (index !== -1) {
                results.splice(index, 1);
            }
        }
        return results;
    };

    /*
    Returns all items from the current list sorted in the order of the items in the operand array
    */
    exports.sortby = function (source, operator) {
        var results = prepare_results(source);
        if (!results || results.length < 2) {
            return results;
        }
        var lookup = $tw.utils.parseStringArray(operator.operand, "true");
        results.sort(function (a, b) {
            return lookup.indexOf(a) - lookup.indexOf(b);
        });
        return results;
    };

    /*
    Removes all duplicate items from the current list
    */
    exports.unique = function (source, operator) {
        var results = prepare_results(source);
        var set = results.reduce(function (a, b) {
            if (a.indexOf(b) < 0) {
                a.push(b);
            }
            return a;
        }, []);
        return set;
    };
})();

;})();
return exports;
}));
_define("$:/core/modules/filters.js","wikimethod",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/filters.js
type: application/javascript
module-type: wikimethod

Adds tiddler filtering methods to the $tw.Wiki object.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Parses an operation (i.e. a run) within a filter string
	operators: Array of array of operator nodes into which results should be inserted
	filterString: filter string
	p: start position within the string
Returns the new start position, after the parsed operation
*/
function parseFilterOperation(operators,filterString,p) {
	var nextBracketPos, operator;
	// Skip the starting square bracket
	if(filterString.charAt(p++) !== "[") {
		throw "Missing [ in filter expression";
	}
	// Process each operator in turn
	do {
		operator = {};
		// Check for an operator prefix
		if(filterString.charAt(p) === "!") {
			operator.prefix = filterString.charAt(p++);
		}
		// Get the operator name
		nextBracketPos = filterString.substring(p).search(/[\[\{<\/]/);
		if(nextBracketPos === -1) {
			throw "Missing [ in filter expression";
		}
		nextBracketPos += p;
		var bracket = filterString.charAt(nextBracketPos);
		operator.operator = filterString.substring(p,nextBracketPos);
		// Any suffix?
		var colon = operator.operator.indexOf(':');
		if(colon > -1) {
			// The raw suffix for older filters
			operator.suffix = operator.operator.substring(colon + 1);
			operator.operator = operator.operator.substring(0,colon) || "field";
			// The processed suffix for newer filters
			operator.suffixes = [];
			$tw.utils.each(operator.suffix.split(":"),function(subsuffix) {
				operator.suffixes.push([]);
				$tw.utils.each(subsuffix.split(","),function(entry) {
					entry = $tw.utils.trim(entry);
					if(entry) {
						operator.suffixes[operator.suffixes.length - 1].push(entry); 
					}
				});
			});
		}
		// Empty operator means: title
		else if(operator.operator === "") {
			operator.operator = "title";
		}

		p = nextBracketPos + 1;
		switch (bracket) {
			case "{": // Curly brackets
				operator.indirect = true;
				nextBracketPos = filterString.indexOf("}",p);
				break;
			case "[": // Square brackets
				nextBracketPos = filterString.indexOf("]",p);
				break;
			case "<": // Angle brackets
				operator.variable = true;
				nextBracketPos = filterString.indexOf(">",p);
				break;
			case "/": // regexp brackets
				var rex = /^((?:[^\\\/]*|\\.)*)\/(?:\(([mygi]+)\))?/g,
					rexMatch = rex.exec(filterString.substring(p));
				if(rexMatch) {
					operator.regexp = new RegExp(rexMatch[1], rexMatch[2]);
// DEPRECATION WARNING
console.log("WARNING: Filter",operator.operator,"has a deprecated regexp operand",operator.regexp);
					nextBracketPos = p + rex.lastIndex - 1;
				}
				else {
					throw "Unterminated regular expression in filter expression";
				}
				break;
		}

		if(nextBracketPos === -1) {
			throw "Missing closing bracket in filter expression";
		}
		if(!operator.regexp) {
			operator.operand = filterString.substring(p,nextBracketPos);
		}
		p = nextBracketPos + 1;

		// Push this operator
		operators.push(operator);
	} while(filterString.charAt(p) !== "]");
	// Skip the ending square bracket
	if(filterString.charAt(p++) !== "]") {
		throw "Missing ] in filter expression";
	}
	// Return the parsing position
	return p;
}

/*
Parse a filter string
*/
exports.parseFilter = function(filterString) {
	filterString = filterString || "";
	var results = [], // Array of arrays of operator nodes {operator:,operand:}
		p = 0, // Current position in the filter string
		match;
	var whitespaceRegExp = /(\s+)/mg,
		operandRegExp = /((?:\+|\-|~|=)?)(?:(\[)|(?:"([^"]*)")|(?:'([^']*)')|([^\s\[\]]+))/mg;
	while(p < filterString.length) {
		// Skip any whitespace
		whitespaceRegExp.lastIndex = p;
		match = whitespaceRegExp.exec(filterString);
		if(match && match.index === p) {
			p = p + match[0].length;
		}
		// Match the start of the operation
		if(p < filterString.length) {
			operandRegExp.lastIndex = p;
			match = operandRegExp.exec(filterString);
			if(!match || match.index !== p) {
				throw $tw.language.getString("Error/FilterSyntax");
			}
			var operation = {
				prefix: "",
				operators: []
			};
			if(match[1]) {
				operation.prefix = match[1];
				p++;
			}
			if(match[2]) { // Opening square bracket
				p = parseFilterOperation(operation.operators,filterString,p);
			} else {
				p = match.index + match[0].length;
			}
			if(match[3] || match[4] || match[5]) { // Double quoted string, single quoted string or unquoted title
				operation.operators.push(
					{operator: "title", operand: match[3] || match[4] || match[5]}
				);
			}
			results.push(operation);
		}
	}
	return results;
};

exports.getFilterOperators = function() {
	if(!this.filterOperators) {
		$tw.Wiki.prototype.filterOperators = {};
		$tw.modules.applyMethods("filteroperator",this.filterOperators);
	}
	return this.filterOperators;
};

exports.filterTiddlers = function(filterString,widget,source) {
	var fn = this.compileFilter(filterString);
	return fn.call(this,source,widget);
};

/*
Compile a filter into a function with the signature fn(source,widget) where:
source: an iterator function for the source tiddlers, called source(iterator), where iterator is called as iterator(tiddler,title)
widget: an optional widget node for retrieving the current tiddler etc.
*/
exports.compileFilter = function(filterString) {
	var filterParseTree;
	try {
		filterParseTree = this.parseFilter(filterString);
	} catch(e) {
		return function(source,widget) {
			return [$tw.language.getString("Error/Filter") + ": " + e];
		};
	}
	// Get the hashmap of filter operator functions
	var filterOperators = this.getFilterOperators();
	// Assemble array of functions, one for each operation
	var operationFunctions = [];
	// Step through the operations
	var self = this;
	$tw.utils.each(filterParseTree,function(operation) {
		// Create a function for the chain of operators in the operation
		var operationSubFunction = function(source,widget) {
			var accumulator = source,
				results = [],
				currTiddlerTitle = widget && widget.getVariable("currentTiddler");
			$tw.utils.each(operation.operators,function(operator) {
				var operand = operator.operand,
					operatorFunction;
				if(!operator.operator) {
					operatorFunction = filterOperators.title;
				} else if(!filterOperators[operator.operator]) {
					operatorFunction = filterOperators.field;
				} else {
					operatorFunction = filterOperators[operator.operator];
				}
				if(operator.indirect) {
					operand = self.getTextReference(operator.operand,"",currTiddlerTitle);
				}
				if(operator.variable) {
					operand = widget.getVariable(operator.operand,{defaultValue: ""});
				}
				// Invoke the appropriate filteroperator module
				results = operatorFunction(accumulator,{
							operator: operator.operator,
							operand: operand,
							prefix: operator.prefix,
							suffix: operator.suffix,
							suffixes: operator.suffixes,
							regexp: operator.regexp
						},{
							wiki: self,
							widget: widget
						});
				if($tw.utils.isArray(results)) {
					accumulator = self.makeTiddlerIterator(results);
				} else {
					accumulator = results;
				}
			});
			if($tw.utils.isArray(results)) {
				return results;
			} else {
				var resultArray = [];
				results(function(tiddler,title) {
					resultArray.push(title);
				});
				return resultArray;
			}
		};
		// Wrap the operator functions in a wrapper function that depends on the prefix
		operationFunctions.push((function() {
			switch(operation.prefix || "") {
				case "": // No prefix means that the operation is unioned into the result
					return function(results,source,widget) {
						$tw.utils.pushTop(results,operationSubFunction(source,widget));
					};
				case "=": // The results of the operation are pushed into the result without deduplication
					return function(results,source,widget) {
						Array.prototype.push.apply(results,operationSubFunction(source,widget));
					};
				case "-": // The results of this operation are removed from the main result
					return function(results,source,widget) {
						$tw.utils.removeArrayEntries(results,operationSubFunction(source,widget));
					};
				case "+": // This operation is applied to the main results so far
					return function(results,source,widget) {
						// This replaces all the elements of the array, but keeps the actual array so that references to it are preserved
						source = self.makeTiddlerIterator(results);
						results.splice(0,results.length);
						$tw.utils.pushTop(results,operationSubFunction(source,widget));
					};
				case "~": // This operation is unioned into the result only if the main result so far is empty
					return function(results,source,widget) {
						if(results.length === 0) {
							// Main result so far is empty
							$tw.utils.pushTop(results,operationSubFunction(source,widget));
						}
					};
			}
		})());
	});
	// Return a function that applies the operations to a source iterator of tiddler titles
	return $tw.perf.measure("filter: " + filterString,function filterFunction(source,widget) {
		if(!source) {
			source = self.each;
		} else if(typeof source === "object") { // Array or hashmap
			source = self.makeTiddlerIterator(source);
		}
		var results = [];
		$tw.utils.each(operationFunctions,function(operationFunction) {
			operationFunction(results,source,widget);
		});
		return results;
	});
};

})();

;})();
return exports;
}));
_define("$:/core/modules/indexers/field-indexer.js","indexer",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/indexers/field-indexer.js
type: application/javascript
module-type: indexer

Indexes the tiddlers with each field value

\*/
(function(){

/*jslint node: true, browser: true */
/*global modules: false */
"use strict";

var DEFAULT_MAXIMUM_INDEXED_VALUE_LENGTH = 128;

function FieldIndexer(wiki) {
	this.wiki = wiki;
}

FieldIndexer.prototype.init = function() {
	this.index = null;
	this.maxIndexedValueLength = DEFAULT_MAXIMUM_INDEXED_VALUE_LENGTH;
	this.addIndexMethods();
}

// Provided for testing
FieldIndexer.prototype.setMaxIndexedValueLength = function(length) {
	this.index = null;
	this.maxIndexedValueLength = length;
};

FieldIndexer.prototype.addIndexMethods = function() {
	var self = this;
	this.wiki.each.byField = function(name,value) {
		var titles = self.wiki.allTitles(),
			lookup = self.lookup(name,value);
		return lookup && lookup.filter(function(title) {
			return titles.indexOf(title) !== -1;
		});
	};
	this.wiki.eachShadow.byField = function(name,value) {
		var titles = self.wiki.allShadowTitles(),
			lookup = self.lookup(name,value);
		return lookup && lookup.filter(function(title) {
			return titles.indexOf(title) !== -1;
		});
	};
	this.wiki.eachTiddlerPlusShadows.byField = function(name,value) {
		var lookup = self.lookup(name,value);
		return lookup ? lookup.slice(0) : null;
	};
	this.wiki.eachShadowPlusTiddlers.byField = function(name,value) {
		var lookup = self.lookup(name,value);
		return lookup ? lookup.slice(0) : null;
	};
};

/*
Tear down and then rebuild the index as if all tiddlers have changed
*/
FieldIndexer.prototype.rebuild = function() {
	// Invalidate the index so that it will be rebuilt when it is next used
	this.index = null;
};

/*
Build the index for a particular field
*/
FieldIndexer.prototype.buildIndexForField = function(name) {
	var self = this;
	// Hashmap by field name of hashmap by field value of array of tiddler titles
	this.index = this.index || Object.create(null);
	this.index[name] = Object.create(null);
	var baseIndex = this.index[name];
	// Update the index for each tiddler
	this.wiki.eachTiddlerPlusShadows(function(tiddler,title) {
		if(name in tiddler.fields) {
			var value = tiddler.getFieldString(name);
			// Skip any values above the maximum length
			if(value.length < self.maxIndexedValueLength) {
				baseIndex[value] = baseIndex[value] || [];
				baseIndex[value].push(title);
			}
		}
	});
};

/*
Update the index in the light of a tiddler value changing; note that the title must be identical. (Renames are handled as a separate delete and create)
oldTiddler: old tiddler value, or null for creation
newTiddler: new tiddler value, or null for deletion
*/
FieldIndexer.prototype.update = function(oldTiddler,newTiddler) {
	var self = this;
	// Don't do anything if the index hasn't been built yet
	if(this.index === null) {
		return;
	}
	// Remove the old tiddler from the index
	if(oldTiddler) {
		$tw.utils.each(this.index,function(indexEntry,name) {
			if(name in oldTiddler.fields) {
				var value = oldTiddler.getFieldString(name),
					tiddlerList = indexEntry[value];
				if(tiddlerList) {
					var index = tiddlerList.indexOf(oldTiddler.fields.title);
					if(index !== -1) {
						tiddlerList.splice(index,1);
					}
				}
			}
		});
	}
	// Add the new tiddler to the index
	if(newTiddler) {
		$tw.utils.each(this.index,function(indexEntry,name) {
			if(name in newTiddler.fields) {
				var value = newTiddler.getFieldString(name);
				if(value.length < self.maxIndexedValueLength) {
					indexEntry[value] = indexEntry[value] || [];
					indexEntry[value].push(newTiddler.fields.title);
				}
			}
		});		
	}
};

// Lookup the given field returning a list of tiddler titles
FieldIndexer.prototype.lookup = function(name,value) {
	// Fail the lookup if the value is too long
	if(value.length >= this.maxIndexedValueLength) {
		return null;
	}
	// Update the index if it has yet to be built
	if(this.index === null || !this.index[name]) {
		this.buildIndexForField(name);
	}
	return this.index[name][value] || [];
};

exports.FieldIndexer = FieldIndexer;

})();

;})();
return exports;
}));
_define("$:/core/modules/indexers/tag-indexer.js","indexer",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/indexers/tag-indexer.js
type: application/javascript
module-type: indexer

Indexes the tiddlers with each tag

\*/
(function(){

/*jslint node: true, browser: true */
/*global modules: false */
"use strict";

function TagIndexer(wiki) {
	this.wiki = wiki;
}

TagIndexer.prototype.init = function() {
	this.index = null; // Hashmap of tag title to {isSorted: bool, titles: [array]}
	this.addIndexMethods();
}

TagIndexer.prototype.addIndexMethods = function() {
	var self = this;
	this.wiki.each.byTag = function(tag) {
		var titles = self.wiki.allTitles();
		return self.lookup(tag).filter(function(title) {
			return titles.indexOf(title) !== -1;
		});
	};
	this.wiki.eachShadow.byTag = function(tag) {
		var titles = self.wiki.allShadowTitles();
		return self.lookup(tag).filter(function(title) {
			return titles.indexOf(title) !== -1;
		});
	};
	this.wiki.eachTiddlerPlusShadows.byTag = function(tag) {
		return self.lookup(tag).slice(0);
	};
	this.wiki.eachShadowPlusTiddlers.byTag = function(tag) {
		return self.lookup(tag).slice(0);
	};
};

/*
Tear down and then rebuild the index as if all tiddlers have changed
*/
TagIndexer.prototype.rebuild = function() {
	var self = this;
	// Hashmap by tag of array of {isSorted:, titles:[]}
	this.index = Object.create(null);
	// Add all the tags
	this.wiki.eachTiddlerPlusShadows(function(tiddler,title) {
		$tw.utils.each(tiddler.fields.tags,function(tag) {
			if(!self.index[tag]) {
				self.index[tag] = {isSorted: false, titles: [title]};
			} else {
				self.index[tag].titles.push(title);
			}
		});		
	});
};

/*
Update the index in the light of a tiddler value changing; note that the title must be identical. (Renames are handled as a separate delete and create)
oldTiddler: old tiddler value, or null for creation
newTiddler: new tiddler value, or null for deletion
*/
TagIndexer.prototype.update = function(oldTiddler,newTiddler) {
	// Don't update the index if it has yet to be built
	if(this.index === null) {
		return;
	}
	var self = this,
		title = oldTiddler ? oldTiddler.fields.title : newTiddler.fields.title;
	// Handle changes to the tags
	var oldTiddlerTags = (oldTiddler ? (oldTiddler.fields.tags || []) : []),
		newTiddlerTags = (newTiddler ? (newTiddler.fields.tags || []) : []);
	$tw.utils.each(oldTiddlerTags,function(oldTag) {
		if(newTiddlerTags.indexOf(oldTag) === -1) {
			// Deleted tag
			var indexRecord = self.index[oldTag],
				pos = indexRecord.titles.indexOf(title);
			if(pos !== -1) {
				indexRecord.titles.splice(pos,1);
			}
		}
	});
	$tw.utils.each(newTiddlerTags,function(newTag) {
		if(oldTiddlerTags.indexOf(newTag) === -1) {
			// New tag
			var indexRecord = self.index[newTag];
			if(!indexRecord) {
				self.index[newTag] = {isSorted: false, titles: [title]};
			} else {
				indexRecord.titles.push(title);
				indexRecord.isSorted = false;
			}
		}
	});
	// Handle changes to the list field of tags
	var oldTiddlerList = (oldTiddler ? (oldTiddler.fields.list || []) : []),
		newTiddlerList = (newTiddler ? (newTiddler.fields.list || []) : []);
	if(!$tw.utils.isArrayEqual(oldTiddlerList,newTiddlerList)) {
		if(self.index[title]) {
			self.index[title].isSorted = false;			
		}
	}
};

// Lookup the given tag returning an ordered list of tiddler titles
TagIndexer.prototype.lookup = function(tag) {
	// Update the index if it has yet to be built
	if(this.index === null) {
		this.rebuild();
	}
	var indexRecord = this.index[tag];
	if(indexRecord) {
		if(!indexRecord.isSorted) {
			if(this.wiki.sortByList) {
				indexRecord.titles = this.wiki.sortByList(indexRecord.titles,tag);
			}			
			indexRecord.isSorted = true;
		}
		return indexRecord.titles;
	} else {
		return [];
	}
};

exports.TagIndexer = TagIndexer;

})();

;})();
return exports;
}));
_define("$:/core/modules/info/platform.js","info",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/info/platform.js
type: application/javascript
module-type: info

Initialise basic platform $:/info/ tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.getInfoTiddlerFields = function() {
	var mapBoolean = function(value) {return value ? "yes" : "no";},
		infoTiddlerFields = [];
	// Basics
	infoTiddlerFields.push({title: "$:/info/browser", text: mapBoolean(!!$tw.browser)});
	infoTiddlerFields.push({title: "$:/info/node", text: mapBoolean(!!$tw.node)});
	if($tw.browser) {
		// Document location
		var setLocationProperty = function(name,value) {
				infoTiddlerFields.push({title: "$:/info/url/" + name, text: value});			
			},
			location = document.location;
		setLocationProperty("full", (location.toString()).split("#")[0]);
		setLocationProperty("host", location.host);
		setLocationProperty("hostname", location.hostname);
		setLocationProperty("protocol", location.protocol);
		setLocationProperty("port", location.port);
		setLocationProperty("pathname", location.pathname);
		setLocationProperty("search", location.search);
		setLocationProperty("origin", location.origin);
		// Screen size
		infoTiddlerFields.push({title: "$:/info/browser/screen/width", text: window.screen.width.toString()});
		infoTiddlerFields.push({title: "$:/info/browser/screen/height", text: window.screen.height.toString()});
		// Language
		infoTiddlerFields.push({title: "$:/info/browser/language", text: navigator.language || ""});
	}
	return infoTiddlerFields;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/keyboard.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/keyboard.js
type: application/javascript
module-type: global

Keyboard handling utilities

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var namedKeys = {
	"cancel": 3,
	"help": 6,
	"backspace": 8,
	"tab": 9,
	"clear": 12,
	"return": 13,
	"enter": 13,
	"pause": 19,
	"escape": 27,
	"space": 32,
	"page_up": 33,
	"page_down": 34,
	"end": 35,
	"home": 36,
	"left": 37,
	"up": 38,
	"right": 39,
	"down": 40,
	"printscreen": 44,
	"insert": 45,
	"delete": 46,
	"0": 48,
	"1": 49,
	"2": 50,
	"3": 51,
	"4": 52,
	"5": 53,
	"6": 54,
	"7": 55,
	"8": 56,
	"9": 57,
	"firefoxsemicolon": 59,
	"firefoxequals": 61,
	"a": 65,
	"b": 66,
	"c": 67,
	"d": 68,
	"e": 69,
	"f": 70,
	"g": 71,
	"h": 72,
	"i": 73,
	"j": 74,
	"k": 75,
	"l": 76,
	"m": 77,
	"n": 78,
	"o": 79,
	"p": 80,
	"q": 81,
	"r": 82,
	"s": 83,
	"t": 84,
	"u": 85,
	"v": 86,
	"w": 87,
	"x": 88,
	"y": 89,
	"z": 90,
	"numpad0": 96,
	"numpad1": 97,
	"numpad2": 98,
	"numpad3": 99,
	"numpad4": 100,
	"numpad5": 101,
	"numpad6": 102,
	"numpad7": 103,
	"numpad8": 104,
	"numpad9": 105,
	"multiply": 106,
	"add": 107,
	"separator": 108,
	"subtract": 109,
	"decimal": 110,
	"divide": 111,
	"f1": 112,
	"f2": 113,
	"f3": 114,
	"f4": 115,
	"f5": 116,
	"f6": 117,
	"f7": 118,
	"f8": 119,
	"f9": 120,
	"f10": 121,
	"f11": 122,
	"f12": 123,
	"f13": 124,
	"f14": 125,
	"f15": 126,
	"f16": 127,
	"f17": 128,
	"f18": 129,
	"f19": 130,
	"f20": 131,
	"f21": 132,
	"f22": 133,
	"f23": 134,
	"f24": 135,
	"firefoxminus": 173,
	"semicolon": 186,
	"equals": 187,
	"comma": 188,
	"dash": 189,
	"period": 190,
	"slash": 191,
	"backquote": 192,
	"openbracket": 219,
	"backslash": 220,
	"closebracket": 221,
	"quote": 222
};

function KeyboardManager(options) {
	var self = this;
	options = options || "";
	// Save the named key hashmap
	this.namedKeys = namedKeys;
	// Create a reverse mapping of code to keyname
	this.keyNames = [];
	$tw.utils.each(namedKeys,function(keyCode,name) {
		self.keyNames[keyCode] = name.substr(0,1).toUpperCase() + name.substr(1);
	});
	// Save the platform-specific name of the "meta" key
	this.metaKeyName = $tw.platform.isMac ? "cmd-" : "win-";
	this.shortcutKeysList = [], // Stores the shortcut-key descriptors
	this.shortcutActionList = [], // Stores the corresponding action strings
	this.shortcutParsedList = []; // Stores the parsed key descriptors
	this.lookupNames = ["shortcuts"];
	this.lookupNames.push($tw.platform.isMac ? "shortcuts-mac" : "shortcuts-not-mac")
	this.lookupNames.push($tw.platform.isWindows ? "shortcuts-windows" : "shortcuts-not-windows");
	this.lookupNames.push($tw.platform.isLinux ? "shortcuts-linux" : "shortcuts-not-linux");
	this.updateShortcutLists(this.getShortcutTiddlerList());
	$tw.wiki.addEventListener("change",function(changes) {
		self.handleShortcutChanges(changes);
	});
}

/*
Return an array of keycodes for the modifier keys ctrl, shift, alt, meta
*/
KeyboardManager.prototype.getModifierKeys = function() {
	return [
		16, // Shift
		17, // Ctrl
		18, // Alt
		20, // CAPS LOCK
		91, // Meta (left)
		93, // Meta (right)
		224 // Meta (Firefox)
	]
};

/*
Parses a key descriptor into the structure:
{
	keyCode: numeric keycode
	shiftKey: boolean
	altKey: boolean
	ctrlKey: boolean
	metaKey: boolean
}
Key descriptors have the following format:
	ctrl+enter
	ctrl+shift+alt+A
*/
KeyboardManager.prototype.parseKeyDescriptor = function(keyDescriptor) {
	var components = keyDescriptor.split(/\+|\-/),
		info = {
			keyCode: 0,
			shiftKey: false,
			altKey: false,
			ctrlKey: false,
			metaKey: false
		};
	for(var t=0; t<components.length; t++) {
		var s = components[t].toLowerCase(),
			c = s.charCodeAt(0);
		// Look for modifier keys
		if(s === "ctrl") {
			info.ctrlKey = true;
		} else if(s === "shift") {
			info.shiftKey = true;
		} else if(s === "alt") {
			info.altKey = true;
		} else if(s === "meta" || s === "cmd" || s === "win") {
			info.metaKey = true;
		}
		// Replace named keys with their code
		if(this.namedKeys[s]) {
			info.keyCode = this.namedKeys[s];
		}
	}
	if(info.keyCode) {
		return info;
	} else {
		return null;
	}
};

/*
Parse a list of key descriptors into an array of keyInfo objects. The key descriptors can be passed as an array of strings or a space separated string
*/
KeyboardManager.prototype.parseKeyDescriptors = function(keyDescriptors,options) {
	var self = this;
	options = options || {};
	options.stack = options.stack || [];
	var wiki = options.wiki || $tw.wiki;
	if(typeof keyDescriptors === "string" && keyDescriptors === "") {
		return [];
	}
	if(!$tw.utils.isArray(keyDescriptors)) {
		keyDescriptors = keyDescriptors.split(" ");
	}
	var result = [];
	$tw.utils.each(keyDescriptors,function(keyDescriptor) {
		// Look for a named shortcut
		if(keyDescriptor.substr(0,2) === "((" && keyDescriptor.substr(-2,2) === "))") {
			if(options.stack.indexOf(keyDescriptor) === -1) {
				options.stack.push(keyDescriptor);
				var name = keyDescriptor.substring(2,keyDescriptor.length - 2),
					lookupName = function(configName) {
						var keyDescriptors = wiki.getTiddlerText("$:/config/" + configName + "/" + name);
						if(keyDescriptors) {
							result.push.apply(result,self.parseKeyDescriptors(keyDescriptors,options));
						}
					};
				$tw.utils.each(self.lookupNames,function(platformDescriptor) {
					lookupName(platformDescriptor);
				});
			}
		} else {
			result.push(self.parseKeyDescriptor(keyDescriptor));
		}
	});
	return result;
};

KeyboardManager.prototype.getPrintableShortcuts = function(keyInfoArray) {
	var self = this,
		result = [];
	$tw.utils.each(keyInfoArray,function(keyInfo) {
		if(keyInfo) {
			result.push((keyInfo.ctrlKey ? "ctrl-" : "") + 
				   (keyInfo.shiftKey ? "shift-" : "") + 
				   (keyInfo.altKey ? "alt-" : "") + 
				   (keyInfo.metaKey ? self.metaKeyName : "") + 
				   (self.keyNames[keyInfo.keyCode]));
		}
	});
	return result;
}

KeyboardManager.prototype.checkKeyDescriptor = function(event,keyInfo) {
	return keyInfo &&
			event.keyCode === keyInfo.keyCode && 
			event.shiftKey === keyInfo.shiftKey && 
			event.altKey === keyInfo.altKey && 
			event.ctrlKey === keyInfo.ctrlKey && 
			event.metaKey === keyInfo.metaKey;
};

KeyboardManager.prototype.checkKeyDescriptors = function(event,keyInfoArray) {
	for(var t=0; t<keyInfoArray.length; t++) {
		if(this.checkKeyDescriptor(event,keyInfoArray[t])) {
			return true;
		}
	}
	return false;
};

KeyboardManager.prototype.getShortcutTiddlerList = function() {
	return $tw.wiki.getTiddlersWithTag("$:/tags/KeyboardShortcut");
};

KeyboardManager.prototype.updateShortcutLists = function(tiddlerList) {
	this.shortcutTiddlers = tiddlerList;
	for(var i=0; i<tiddlerList.length; i++) {
		var title = tiddlerList[i],
			tiddlerFields = $tw.wiki.getTiddler(title).fields;
		this.shortcutKeysList[i] = tiddlerFields.key !== undefined ? tiddlerFields.key : undefined;
		this.shortcutActionList[i] = tiddlerFields.text;
		this.shortcutParsedList[i] = this.shortcutKeysList[i] !== undefined ? this.parseKeyDescriptors(this.shortcutKeysList[i]) : undefined;
	}
};

KeyboardManager.prototype.handleKeydownEvent = function(event) {
	var key, action;
	for(var i=0; i<this.shortcutTiddlers.length; i++) {
		if(this.shortcutParsedList[i] !== undefined && this.checkKeyDescriptors(event,this.shortcutParsedList[i])) {
			key = this.shortcutParsedList[i];
			action = this.shortcutActionList[i];
		}
	}
	if(key !== undefined) {
		event.preventDefault();
		event.stopPropagation();
		$tw.rootWidget.invokeActionString(action,$tw.rootWidget);
		return true;
	}
	return false;
};

KeyboardManager.prototype.detectNewShortcuts = function(changedTiddlers) {
	var shortcutConfigTiddlers = [],
		handled = false;
	$tw.utils.each(this.lookupNames,function(platformDescriptor) {
		var descriptorString = "$:/config/" + platformDescriptor + "/";
		Object.keys(changedTiddlers).forEach(function(configTiddler) {
			var configString = configTiddler.substr(0, configTiddler.lastIndexOf("/") + 1);
			if(configString === descriptorString) {
				shortcutConfigTiddlers.push(configTiddler);
				handled = true;
			}
		});
	});
	if(handled) {
		return $tw.utils.hopArray(changedTiddlers,shortcutConfigTiddlers);
	} else {
		return false;
	}
};

KeyboardManager.prototype.handleShortcutChanges = function(changedTiddlers) {
	var newList = this.getShortcutTiddlerList();
	var hasChanged = $tw.utils.hopArray(changedTiddlers,this.shortcutTiddlers) ? true :
		($tw.utils.hopArray(changedTiddlers,newList) ? true :
		(this.detectNewShortcuts(changedTiddlers))
	);
	// Re-cache shortcuts if something changed
	if(hasChanged) {
		this.updateShortcutLists(newList);
	}
};

exports.KeyboardManager = KeyboardManager;

})();

;})();
return exports;
}));
_define("$:/core/modules/language.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/language.js
type: application/javascript
module-type: global

The $tw.Language() manages translateable strings

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Create an instance of the language manager. Options include:
wiki: wiki from which to retrieve translation tiddlers
*/
function Language(options) {
	options = options || "";
	this.wiki = options.wiki || $tw.wiki;
}

/*
Return a wikified translateable string. The title is automatically prefixed with "$:/language/"
Options include:
variables: optional hashmap of variables to supply to the language wikification
*/
Language.prototype.getString = function(title,options) {
	options = options || {};
	title = "$:/language/" + title;
	return this.wiki.renderTiddler("text/plain",title,{variables: options.variables});
};

/*
Return a raw, unwikified translateable string. The title is automatically prefixed with "$:/language/"
*/
Language.prototype.getRawString = function(title) {
	title = "$:/language/" + title;
	return this.wiki.getTiddlerText(title);
};

exports.Language = Language;

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/changecount.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/changecount.js
type: application/javascript
module-type: macro

Macro to return the changecount for the current tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "changecount";

exports.params = [];

/*
Run the macro
*/
exports.run = function() {
	return this.wiki.getChangeCount(this.getVariable("currentTiddler")) + "";
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/contrastcolour.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/contrastcolour.js
type: application/javascript
module-type: macro

Macro to choose which of two colours has the highest contrast with a base colour

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "contrastcolour";

exports.params = [
	{name: "target"},
	{name: "fallbackTarget"},
	{name: "colourA"},
	{name: "colourB"}
];

/*
Run the macro
*/
exports.run = function(target,fallbackTarget,colourA,colourB) {
	var rgbTarget = $tw.utils.parseCSSColor(target) || $tw.utils.parseCSSColor(fallbackTarget);
	if(!rgbTarget) {
		return colourA;
	}
	var rgbColourA = $tw.utils.parseCSSColor(colourA),
		rgbColourB = $tw.utils.parseCSSColor(colourB);
	if(rgbColourA && !rgbColourB) {
		return rgbColourA;
	}
	if(rgbColourB && !rgbColourA) {
		return rgbColourB;
	}
	if(!rgbColourA && !rgbColourB) {
		// If neither colour is readable, return a crude inverse of the target
		return [255 - rgbTarget[0],255 - rgbTarget[1],255 - rgbTarget[2],rgbTarget[3]];
	}
	// Colour brightness formula derived from http://www.w3.org/WAI/ER/WD-AERT/#color-contrast
	var brightnessTarget = rgbTarget[0] * 0.299 + rgbTarget[1] * 0.587 + rgbTarget[2] * 0.114,
		brightnessA = rgbColourA[0] * 0.299 + rgbColourA[1] * 0.587 + rgbColourA[2] * 0.114,
		brightnessB = rgbColourB[0] * 0.299 + rgbColourB[1] * 0.587 + rgbColourB[2] * 0.114;
	return Math.abs(brightnessTarget - brightnessA) > Math.abs(brightnessTarget - brightnessB) ? colourA : colourB;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/csvtiddlers.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/csvtiddlers.js
type: application/javascript
module-type: macro

Macro to output tiddlers matching a filter to CSV

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "csvtiddlers";

exports.params = [
	{name: "filter"},
	{name: "format"},
];

/*
Run the macro
*/
exports.run = function(filter,format) {
	var self = this,
		tiddlers = this.wiki.filterTiddlers(filter),
		tiddler,
		fields = [],
		t,f;
	// Collect all the fields
	for(t=0;t<tiddlers.length; t++) {
		tiddler = this.wiki.getTiddler(tiddlers[t]);
		for(f in tiddler.fields) {
			if(fields.indexOf(f) === -1) {
				fields.push(f);
			}
		}
	}
	// Sort the fields and bring the standard ones to the front
	fields.sort();
	"title text modified modifier created creator".split(" ").reverse().forEach(function(value,index) {
		var p = fields.indexOf(value);
		if(p !== -1) {
			fields.splice(p,1);
			fields.unshift(value)
		}
	});
	// Output the column headings
	var output = [], row = [];
	fields.forEach(function(value) {
		row.push(quoteAndEscape(value))
	});
	output.push(row.join(","));
	// Output each tiddler
	for(var t=0;t<tiddlers.length; t++) {
		row = [];
		tiddler = this.wiki.getTiddler(tiddlers[t]);
			for(f=0; f<fields.length; f++) {
				row.push(quoteAndEscape(tiddler ? tiddler.getFieldString(fields[f]) || "" : ""));
			}
		output.push(row.join(","));
	}
	return output.join("\n");
};

function quoteAndEscape(value) {
	return "\"" + value.replace(/"/mg,"\"\"") + "\"";
}

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/displayshortcuts.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/displayshortcuts.js
type: application/javascript
module-type: macro

Macro to display a list of keyboard shortcuts in human readable form. Notably, it resolves named shortcuts like `((bold))` to the underlying keystrokes.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "displayshortcuts";

exports.params = [
	{name: "shortcuts"},
	{name: "prefix"},
	{name: "separator"},
	{name: "suffix"}
];

/*
Run the macro
*/
exports.run = function(shortcuts,prefix,separator,suffix) {
	var shortcutArray = $tw.keyboardManager.getPrintableShortcuts($tw.keyboardManager.parseKeyDescriptors(shortcuts,{
		wiki: this.wiki
	}));
	if(shortcutArray.length > 0) {
		shortcutArray.sort(function(a,b) {
		    return a.toLowerCase().localeCompare(b.toLowerCase());
		})
		return prefix + shortcutArray.join(separator) + suffix;
	} else {
		return "";
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/jsontiddler.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/jsontiddler.js
type: application/javascript
module-type: macro

Macro to output a single tiddler to JSON

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "jsontiddler";

exports.params = [
	{name: "title"}
];

/*
Run the macro
*/
exports.run = function(title) {
	title = title || this.getVariable("currentTiddler");
	var tiddler = !!title && this.wiki.getTiddler(title),
		fields = new Object();
	if(tiddler) {
		for(var field in tiddler.fields) {
			fields[field] = tiddler.getFieldString(field);
		}
	}
	return JSON.stringify(fields,null,$tw.config.preferences.jsonSpaces);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/jsontiddlers.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/jsontiddlers.js
type: application/javascript
module-type: macro

Macro to output tiddlers matching a filter to JSON

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "jsontiddlers";

exports.params = [
	{name: "filter"}
];

/*
Run the macro
*/
exports.run = function(filter) {
	return this.wiki.getTiddlersAsJson(filter);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/makedatauri.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/makedatauri.js
type: application/javascript
module-type: macro

Macro to convert a string of text to a data URI

<<makedatauri text:"Text to be converted" type:"text/vnd.tiddlywiki">>

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "makedatauri";

exports.params = [
	{name: "text"},
	{name: "type"}
];

/*
Run the macro
*/
exports.run = function(text,type) {
	return $tw.utils.makeDataUri(text,type);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/now.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/now.js
type: application/javascript
module-type: macro

Macro to return a formatted version of the current time

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "now";

exports.params = [
	{name: "format"}
];

/*
Run the macro
*/
exports.run = function(format) {
	return $tw.utils.formatDateString(new Date(),format || "0hh:0mm, DDth MMM YYYY");
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/qualify.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/qualify.js
type: application/javascript
module-type: macro

Macro to qualify a state tiddler title according

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "qualify";

exports.params = [
	{name: "title"}
];

/*
Run the macro
*/
exports.run = function(title) {
	return title + "-" + this.getStateQualifier();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/resolvepath.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/resolvepath.js
type: application/javascript
module-type: macro

Resolves a relative path for an absolute rootpath.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "resolvepath";

exports.params = [
	{name: "source"},
	{name: "root"}
];

/*
Run the macro
*/
exports.run = function(source, root) {
	return $tw.utils.resolvePath(source, root);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/unusedtitle.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/unusedtitle.js
type: application/javascript
module-type: macro
Macro to return a new title that is unused in the wiki. It can be given a name as a base.
\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "unusedtitle";

exports.params = [
	{name: "baseName"},
	{name: "options"}
];

/*
Run the macro
*/
exports.run = function(baseName, options) {
	if(!baseName) {
		baseName = $tw.language.getString("DefaultNewTiddlerTitle");
	}
	return this.wiki.generateNewTitle(baseName, options);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/macros/version.js","macro",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/macros/version.js
type: application/javascript
module-type: macro

Macro to return the TiddlyWiki core version number

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Information about this macro
*/

exports.name = "version";

exports.params = [];

/*
Run the macro
*/
exports.run = function() {
	return $tw.version;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/audioparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/audioparser.js
type: application/javascript
module-type: parser

The audio parser parses an audio tiddler into an embeddable HTML element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var AudioParser = function(type,text,options) {
	var element = {
			type: "element",
			tag: "audio",
			attributes: {
				controls: {type: "string", value: "controls"}
			}
		},
		src;
	if(options._canonical_uri) {
		element.attributes.src = {type: "string", value: options._canonical_uri};
	} else if(text) {
		element.attributes.src = {type: "string", value: "data:" + type + ";base64," + text};
	}
	this.tree = [element];
};

exports["audio/ogg"] = AudioParser;
exports["audio/mpeg"] = AudioParser;
exports["audio/mp3"] = AudioParser;
exports["audio/mp4"] = AudioParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/binaryparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/binaryparser.js
type: application/javascript
module-type: parser

The video parser parses a video tiddler into an embeddable HTML element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var BINARY_WARNING_MESSAGE = "$:/core/ui/BinaryWarning";

var BinaryParser = function(type,text,options) {
	this.tree = [{
		type: "transclude",
		attributes: {
			tiddler: {type: "string", value: BINARY_WARNING_MESSAGE}
		}
	}];
};

exports["application/octet-stream"] = BinaryParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/csvparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/csvparser.js
type: application/javascript
module-type: parser

The CSV text parser processes CSV files into a table wrapped in a scrollable widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var CsvParser = function(type,text,options) {
	// Table framework
	this.tree = [{
		"type": "scrollable", "children": [{
			"type": "element", "tag": "table", "children": [{
				"type": "element", "tag": "tbody", "children": []
			}], "attributes": {
				"class": {"type": "string", "value": "tc-csv-table"}
			}
		}]
	}];
	// Split the text into lines
	var lines = text.split(/\r?\n/mg),
		tag = "th";
	for(var line=0; line<lines.length; line++) {
		var lineText = lines[line];
		if(lineText) {
			var row = {
					"type": "element", "tag": "tr", "children": []
				};
			var columns = lineText.split(",");
			for(var column=0; column<columns.length; column++) {
				row.children.push({
						"type": "element", "tag": tag, "children": [{
							"type": "text",
							"text": columns[column]
						}]
					});
			}
			tag = "td";
			this.tree[0].children[0].children[0].children.push(row);
		}
	}
};

exports["text/csv"] = CsvParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/htmlparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/htmlparser.js
type: application/javascript
module-type: parser

The HTML parser displays text as raw HTML

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var HtmlParser = function(type,text,options) {
	var src;
	if(options._canonical_uri) {
		src = options._canonical_uri;
	} else if(text) {
		src = "data:text/html;charset=utf-8," + encodeURIComponent(text);
	}
	this.tree = [{
		type: "element",
		tag: "iframe",
		attributes: {
			src: {type: "string", value: src},
			sandbox: {type: "string", value: ""}
		}
	}];
};

exports["text/html"] = HtmlParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/imageparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/imageparser.js
type: application/javascript
module-type: parser

The image parser parses an image into an embeddable HTML element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ImageParser = function(type,text,options) {
	var element = {
			type: "element",
			tag: "img",
			attributes: {}
		};
	if(options._canonical_uri) {
		element.attributes.src = {type: "string", value: options._canonical_uri};
	} else if(text) {
		if(type === "image/svg+xml" || type === ".svg") {
			element.attributes.src = {type: "string", value: "data:image/svg+xml," + encodeURIComponent(text)};
		} else {
			element.attributes.src = {type: "string", value: "data:" + type + ";base64," + text};
		}
	}
	this.tree = [element];
};

exports["image/svg+xml"] = ImageParser;
exports["image/jpg"] = ImageParser;
exports["image/jpeg"] = ImageParser;
exports["image/png"] = ImageParser;
exports["image/gif"] = ImageParser;
exports["image/webp"] = ImageParser;
exports["image/heic"] = ImageParser;
exports["image/heif"] = ImageParser;
exports["image/x-icon"] = ImageParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/utils/parseutils.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/parseutils.js
type: application/javascript
module-type: utils

Utility functions concerned with parsing text into tokens.

Most functions have the following pattern:

* The parameters are:
** `source`: the source string being parsed
** `pos`: the current parse position within the string
** Any further parameters are used to identify the token that is being parsed
* The return value is:
** null if the token was not found at the specified position
** an object representing the token with the following standard fields:
*** `type`: string indicating the type of the token
*** `start`: start position of the token in the source string
*** `end`: end position of the token in the source string
*** Any further fields required to describe the token

The exception is `skipWhiteSpace`, which just returns the position after the whitespace.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Look for a whitespace token. Returns null if not found, otherwise returns {type: "whitespace", start:, end:,}
*/
exports.parseWhiteSpace = function(source,pos) {
	var p = pos,c;
	while(true) {
		c = source.charAt(p);
		if((c === " ") || (c === "\f") || (c === "\n") || (c === "\r") || (c === "\t") || (c === "\v") || (c === "\u00a0")) { // Ignores some obscure unicode spaces
			p++;
		} else {
			break;
		}
	}
	if(p === pos) {
		return null;
	} else {
		return {
			type: "whitespace",
			start: pos,
			end: p
		}
	}
};

/*
Convenience wrapper for parseWhiteSpace. Returns the position after the whitespace
*/
exports.skipWhiteSpace = function(source,pos) {
	var c;
	while(true) {
		c = source.charAt(pos);
		if((c === " ") || (c === "\f") || (c === "\n") || (c === "\r") || (c === "\t") || (c === "\v") || (c === "\u00a0")) { // Ignores some obscure unicode spaces
			pos++;
		} else {
			return pos;
		}
	}
};

/*
Look for a given string token. Returns null if not found, otherwise returns {type: "token", value:, start:, end:,}
*/
exports.parseTokenString = function(source,pos,token) {
	var match = source.indexOf(token,pos) === pos;
	if(match) {
		return {
			type: "token",
			value: token,
			start: pos,
			end: pos + token.length
		};
	}
	return null;
};

/*
Look for a token matching a regex. Returns null if not found, otherwise returns {type: "regexp", match:, start:, end:,}
*/
exports.parseTokenRegExp = function(source,pos,reToken) {
	var node = {
		type: "regexp",
		start: pos
	};
	reToken.lastIndex = pos;
	node.match = reToken.exec(source);
	if(node.match && node.match.index === pos) {
		node.end = pos + node.match[0].length;
		return node;
	} else {
		return null;
	}
};

/*
Look for a string literal. Returns null if not found, otherwise returns {type: "string", value:, start:, end:,}
*/
exports.parseStringLiteral = function(source,pos) {
	var node = {
		type: "string",
		start: pos
	};
	var reString = /(?:"""([\s\S]*?)"""|"([^"]*)")|(?:'([^']*)')/g;
	reString.lastIndex = pos;
	var match = reString.exec(source);
	if(match && match.index === pos) {
		node.value = match[1] !== undefined ? match[1] :(
			match[2] !== undefined ? match[2] : match[3] 
					);
		node.end = pos + match[0].length;
		return node;
	} else {
		return null;
	}
};

/*
Look for a macro invocation parameter. Returns null if not found, or {type: "macro-parameter", name:, value:, start:, end:}
*/
exports.parseMacroParameter = function(source,pos) {
	var node = {
		type: "macro-parameter",
		start: pos
	};
	// Define our regexp
	var reMacroParameter = /(?:([A-Za-z0-9\-_]+)\s*:)?(?:\s*(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^\s>"'=]+)))/g;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for the parameter
	var token = $tw.utils.parseTokenRegExp(source,pos,reMacroParameter);
	if(!token) {
		return null;
	}
	pos = token.end;
	// Get the parameter details
	node.value = token.match[2] !== undefined ? token.match[2] : (
					token.match[3] !== undefined ? token.match[3] : (
						token.match[4] !== undefined ? token.match[4] : (
							token.match[5] !== undefined ? token.match[5] : (
								token.match[6] !== undefined ? token.match[6] : (
									""
								)
							)
						)
					)
				);
	if(token.match[1]) {
		node.name = token.match[1];
	}
	// Update the end position
	node.end = pos;
	return node;
};

/*
Look for a macro invocation. Returns null if not found, or {type: "macrocall", name:, parameters:, start:, end:}
*/
exports.parseMacroInvocation = function(source,pos) {
	var node = {
		type: "macrocall",
		start: pos,
		params: []
	};
	// Define our regexps
	var reMacroName = /([^\s>"'=]+)/g;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for a double less than sign
	var token = $tw.utils.parseTokenString(source,pos,"<<");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Get the macro name
	var name = $tw.utils.parseTokenRegExp(source,pos,reMacroName);
	if(!name) {
		return null;
	}
	node.name = name.match[1];
	pos = name.end;
	// Process parameters
	var parameter = $tw.utils.parseMacroParameter(source,pos);
	while(parameter) {
		node.params.push(parameter);
		pos = parameter.end;
		// Get the next parameter
		parameter = $tw.utils.parseMacroParameter(source,pos);
	}
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for a double greater than sign
	token = $tw.utils.parseTokenString(source,pos,">>");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Update the end position
	node.end = pos;
	return node;
};

/*
Look for an HTML attribute definition. Returns null if not found, otherwise returns {type: "attribute", name:, valueType: "string|indirect|macro", value:, start:, end:,}
*/
exports.parseAttribute = function(source,pos) {
	var node = {
		start: pos
	};
	// Define our regexps
	var reAttributeName = /([^\/\s>"'=]+)/g,
		reUnquotedAttribute = /([^\/\s<>"'=]+)/g,
		reFilteredValue = /\{\{\{(.+?)\}\}\}/g,
		reIndirectValue = /\{\{([^\}]+)\}\}/g;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Get the attribute name
	var name = $tw.utils.parseTokenRegExp(source,pos,reAttributeName);
	if(!name) {
		return null;
	}
	node.name = name.match[1];
	pos = name.end;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for an equals sign
	var token = $tw.utils.parseTokenString(source,pos,"=");
	if(token) {
		pos = token.end;
		// Skip whitespace
		pos = $tw.utils.skipWhiteSpace(source,pos);
		// Look for a string literal
		var stringLiteral = $tw.utils.parseStringLiteral(source,pos);
		if(stringLiteral) {
			pos = stringLiteral.end;
			node.type = "string";
			node.value = stringLiteral.value;
		} else {
			// Look for a filtered value
			var filteredValue = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);
			if(filteredValue) {
				pos = filteredValue.end;
				node.type = "filtered";
				node.filter = filteredValue.match[1];
			} else {
				// Look for an indirect value
				var indirectValue = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);
				if(indirectValue) {
					pos = indirectValue.end;
					node.type = "indirect";
					node.textReference = indirectValue.match[1];
				} else {
					// Look for a unquoted value
					var unquotedValue = $tw.utils.parseTokenRegExp(source,pos,reUnquotedAttribute);
					if(unquotedValue) {
						pos = unquotedValue.end;
						node.type = "string";
						node.value = unquotedValue.match[1];
					} else {
						// Look for a macro invocation value
						var macroInvocation = $tw.utils.parseMacroInvocation(source,pos);
						if(macroInvocation) {
							pos = macroInvocation.end;
							node.type = "macro";
							node.value = macroInvocation;
						} else {
							node.type = "string";
							node.value = "true";
						}
					}
				}
			}
		}
	} else {
		node.type = "string";
		node.value = "true";
	}
	// Update the end position
	node.end = pos;
	return node;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/pdfparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/pdfparser.js
type: application/javascript
module-type: parser

The PDF parser embeds a PDF viewer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ImageParser = function(type,text,options) {
	var element = {
			type: "element",
			tag: "embed",
			attributes: {}
		},
		src;
	if(options._canonical_uri) {
		element.attributes.src = {type: "string", value: options._canonical_uri};
	} else if(text) {
		element.attributes.src = {type: "string", value: "data:application/pdf;base64," + text};
	}
	this.tree = [element];
};

exports["application/pdf"] = ImageParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/textparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/textparser.js
type: application/javascript
module-type: parser

The plain text parser processes blocks of source text into a degenerate parse tree consisting of a single text node

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var TextParser = function(type,text,options) {
	this.tree = [{
		type: "codeblock",
		attributes: {
			code: {type: "string", value: text},
			language: {type: "string", value: type}
		}
	}];
};

exports["text/plain"] = TextParser;
exports["text/x-tiddlywiki"] = TextParser;
exports["application/javascript"] = TextParser;
exports["application/json"] = TextParser;
exports["text/css"] = TextParser;
exports["application/x-tiddler-dictionary"] = TextParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/videoparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/videoparser.js
type: application/javascript
module-type: parser

The video parser parses a video tiddler into an embeddable HTML element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var VideoParser = function(type,text,options) {
	var element = {
			type: "element",
			tag: "video",
			attributes: {
				controls: {type: "string", value: "controls"}
			}
		},
		src;
	if(options._canonical_uri) {
		element.attributes.src = {type: "string", value: options._canonical_uri};
	} else if(text) {
		element.attributes.src = {type: "string", value: "data:" + type + ";base64," + text};
	}
	this.tree = [element];
};

exports["video/mp4"] = VideoParser;
exports["video/quicktime"] = VideoParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/codeblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/codeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for code blocks. For example:

```
	```
	This text will not be //wikified//
	```
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "codeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match and get language if defined
	this.matchRegExp = /```([\w-]*)\r?\n/mg;
};

exports.parse = function() {
	var reEnd = /(\r?\n```$)/mg;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Look for the end of the block
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the block
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	// Return the $codeblock widget
	return [{
			type: "codeblock",
			attributes: {
					code: {type: "string", value: text},
					language: {type: "string", value: this.match[1]}
			}
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/codeinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/codeinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for code runs. For example:

```
	This is a `code run`.
	This is another ``code run``
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "codeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(``?)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	var reEnd = new RegExp(this.match[1], "mg");
	// Look for the end marker
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the text
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	return [{
		type: "element",
		tag: "code",
		children: [{
			type: "text",
			text: text
		}]
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/commentblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/commentblock.js
type: application/javascript
module-type: wikirule

Wiki text block rule for HTML comments. For example:

```
<!-- This is a comment -->
```

Note that the syntax for comments is simplified to an opening "<!--" sequence and a closing "-->" sequence -- HTML itself implements a more complex format (see http://ostermiller.org/findhtmlcomment.html)

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "commentblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	this.matchRegExp = /<!--/mg;
	this.endMatchRegExp = /-->/mg;
};

exports.findNextMatch = function(startPos) {
	this.matchRegExp.lastIndex = startPos;
	this.match = this.matchRegExp.exec(this.parser.source);
	if(this.match) {
		this.endMatchRegExp.lastIndex = startPos + this.match[0].length;
		this.endMatch = this.endMatchRegExp.exec(this.parser.source);
		if(this.endMatch) {
			return this.match.index;
		}
	}
	return undefined;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.endMatchRegExp.lastIndex;
	// Don't return any elements
	return [];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/commentinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/commentinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for HTML comments. For example:

```
<!-- This is a comment -->
```

Note that the syntax for comments is simplified to an opening "<!--" sequence and a closing "-->" sequence -- HTML itself implements a more complex format (see http://ostermiller.org/findhtmlcomment.html)

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "commentinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	this.matchRegExp = /<!--/mg;
	this.endMatchRegExp = /-->/mg;
};

exports.findNextMatch = function(startPos) {
	this.matchRegExp.lastIndex = startPos;
	this.match = this.matchRegExp.exec(this.parser.source);
	if(this.match) {
		this.endMatchRegExp.lastIndex = startPos + this.match[0].length;
		this.endMatch = this.endMatchRegExp.exec(this.parser.source);
		if(this.endMatch) {
			return this.match.index;
		}
	}
	return undefined;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.endMatchRegExp.lastIndex;
	// Don't return any elements
	return [];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/dash.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/dash.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for dashes. For example:

```
This is an en-dash: --

This is an em-dash: ---
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "dash";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /-{2,3}(?!-)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	var dash = this.match[0].length === 2 ? "&ndash;" : "&mdash;";
	return [{
		type: "entity",
		entity: dash
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/bold.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/bold.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - bold. For example:

```
	This is ''bold'' text
```

This wikiparser can be modified using the rules eg:

```
\rules except bold 
\rules only bold 
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "bold";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /''/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/''/mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "strong",
		children: tree
	}];
};

})();
;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/italic.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/italic.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - italic. For example:

```
	This is //italic// text
```

This wikiparser can be modified using the rules eg:

```
\rules except italic
\rules only italic
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "italic";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\/\//mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/\/\//mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "em",
		children: tree
	}];
};

})();
;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/strikethrough.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/strikethrough.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - strikethrough. For example:

```
	This is ~~strikethrough~~ text
```

This wikiparser can be modified using the rules eg:

```
\rules except strikethrough 
\rules only strikethrough 
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "strikethrough";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /~~/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/~~/mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "strike",
		children: tree
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/subscript.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/subscript.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - subscript. For example:

```
	This is ,,subscript,, text
```

This wikiparser can be modified using the rules eg:

```
\rules except subscript 
\rules only subscript 
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "subscript";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /,,/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/,,/mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "sub",
		children: tree
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/superscript.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/superscript.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - superscript. For example:

```
	This is ^^superscript^^ text
```

This wikiparser can be modified using the rules eg:

```
\rules except superscript 
\rules only superscript 
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "superscript";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\^\^/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/\^\^/mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "sup",
		children: tree
	}];
};

})();
;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/emphasis/underscore.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis/underscore.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis - underscore. For example:

```
	This is __underscore__ text
```

This wikiparser can be modified using the rules eg:

```
\rules except underscore 
\rules only underscore
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "underscore";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /__/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;

	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(/__/mg,{eatTerminator: true});

	// Return the classed span
	return [{
		type: "element",
		tag: "u",
		children: tree
	}];
};

})();
;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/entity.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/entity.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for HTML entities. For example:

```
	This is a copyright symbol: &copy;
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "entity";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(&#?[a-zA-Z0-9]{2,8};)/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var entityString = this.match[1];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	// Return the entity
	return [{type: "entity", entity: this.match[0]}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/extlink.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/extlink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for external links. For example:

```
An external link: https://www.tiddlywiki.com/

A suppressed external link: ~http://www.tiddlyspace.com/
```

External links can be suppressed by preceding them with `~`.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "extlink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /~?(?:file|http|https|mailto|ftp|irc|news|data|skype):[^\s<>{}\[\]`|"\\^]+(?:\/|\b)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Create the link unless it is suppressed
	if(this.match[0].substr(0,1) === "~") {
		return [{type: "text", text: this.match[0].substr(1)}];
	} else {
		return [{
			type: "element",
			tag: "a",
			attributes: {
				href: {type: "string", value: this.match[0]},
				"class": {type: "string", value: "tc-tiddlylink-external"},
				target: {type: "string", value: "_blank"},
				rel: {type: "string", value: "noopener noreferrer"}
			},
			children: [{
				type: "text", text: this.match[0]
			}]
		}];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/filteredtranscludeblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/filteredtranscludeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for block-level filtered transclusion. For example:

```
{{{ [tag[docs]] }}}
{{{ [tag[docs]] |tooltip}}}
{{{ [tag[docs]] ||TemplateTitle}}}
{{{ [tag[docs]] |tooltip||TemplateTitle}}}
{{{ [tag[docs]] }}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "filteredtranscludeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{\{([^\|]+?)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}\}([^\}]*)\}(?:\.(\S+))?(?:\r?\n|$)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var filter = this.match[1],
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the list widget
	var node = {
		type: "list",
		attributes: {
			filter: {type: "string", value: filter}
		},
		isBlock: true
	};
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes.itemClass = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/filteredtranscludeinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/filteredtranscludeinline.js
type: application/javascript
module-type: wikirule

Wiki text rule for inline filtered transclusion. For example:

```
{{{ [tag[docs]] }}}
{{{ [tag[docs]] |tooltip}}}
{{{ [tag[docs]] ||TemplateTitle}}}
{{{ [tag[docs]] |tooltip||TemplateTitle}}}
{{{ [tag[docs]] }}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "filteredtranscludeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{\{([^\|]+?)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}\}([^\}]*)\}(?:\.(\S+))?/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var filter = this.match[1],
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the list widget
	var node = {
		type: "list",
		attributes: {
			filter: {type: "string", value: filter}
		}
	};
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes.itemClass = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/hardlinebreaks.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/hardlinebreaks.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for marking areas with hard line breaks. For example:

```
"""
This is some text
That is set like
It is a Poem
When it is
Clearly
Not
"""
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "hardlinebreaks";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /"""(?:\r?\n)?/mg;
};

exports.parse = function() {
	var reEnd = /(""")|(\r?\n)/mg,
		tree = [],
		match;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	do {
		// Parse the run up to the terminator
		tree.push.apply(tree,this.parser.parseInlineRun(reEnd,{eatTerminator: false}));
		// Redo the terminator match
		reEnd.lastIndex = this.parser.pos;
		match = reEnd.exec(this.parser.source);
		if(match) {
			this.parser.pos = reEnd.lastIndex;
			// Add a line break if the terminator was a line break
			if(match[2]) {
				tree.push({type: "element", tag: "br"});
			}
		}
	} while(match && !match[1]);
	// Return the nodes
	return tree;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/heading.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/heading.js
type: application/javascript
module-type: wikirule

Wiki text block rule for headings

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "heading";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(!{1,6})/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var headingLevel = this.match[1].length;
	// Move past the !s
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse any classes, whitespace and then the heading itself
	var classes = this.parser.parseClasses();
	this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
	var tree = this.parser.parseInlineRun(/(\r?\n)/mg);
	// Return the heading
	return [{
		type: "element",
		tag: "h" + headingLevel, 
		attributes: {
			"class": {type: "string", value: classes.join(" ")}
		},
		children: tree
	}];
};
})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/horizrule.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/horizrule.js
type: application/javascript
module-type: wikirule

Wiki text block rule for rules. For example:

```
---
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "horizrule";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /-{3,}\r?(?:\n|$)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	return [{type: "element", tag: "hr"}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/html.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/html.js
type: application/javascript
module-type: wikirule

Wiki rule for HTML elements and widgets. For example:

{{{
<aside>
This is an HTML5 aside element
</aside>

<$slider target="MyTiddler">
This is a widget invocation
</$slider>

}}}

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "html";
exports.types = {inline: true, block: true};

exports.init = function(parser) {
	this.parser = parser;
};

exports.findNextMatch = function(startPos) {
	// Find the next tag
	this.nextTag = this.findNextTag(this.parser.source,startPos,{
		requireLineBreak: this.is.block
	});
	return this.nextTag ? this.nextTag.start : undefined;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Retrieve the most recent match so that recursive calls don't overwrite it
	var tag = this.nextTag;
	this.nextTag = null;
	// Advance the parser position to past the tag
	this.parser.pos = tag.end;
	// Check for an immediately following double linebreak
	var hasLineBreak = !tag.isSelfClosing && !!$tw.utils.parseTokenRegExp(this.parser.source,this.parser.pos,/([^\S\n\r]*\r?\n(?:[^\S\n\r]*\r?\n|$))/g);
	// Set whether we're in block mode
	tag.isBlock = this.is.block || hasLineBreak;
	// Parse the body if we need to
	if(!tag.isSelfClosing && $tw.config.htmlVoidElements.indexOf(tag.tag) === -1) {
			var reEndString = "</" + $tw.utils.escapeRegExp(tag.tag) + ">",
				reEnd = new RegExp("(" + reEndString + ")","mg");
		if(hasLineBreak) {
			tag.children = this.parser.parseBlocks(reEndString);
		} else {
			tag.children = this.parser.parseInlineRun(reEnd);
		}
		reEnd.lastIndex = this.parser.pos;
		var endMatch = reEnd.exec(this.parser.source);
		if(endMatch && endMatch.index === this.parser.pos) {
			this.parser.pos = endMatch.index + endMatch[0].length;
		}
	}
	// Return the tag
	return [tag];
};

/*
Look for an HTML tag. Returns null if not found, otherwise returns {type: "element", name:, attributes: [], isSelfClosing:, start:, end:,}
*/
exports.parseTag = function(source,pos,options) {
	options = options || {};
	var token,
		node = {
			type: "element",
			start: pos,
			attributes: {}
		};
	// Define our regexps
	var reTagName = /([a-zA-Z0-9\-\$]+)/g;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for a less than sign
	token = $tw.utils.parseTokenString(source,pos,"<");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Get the tag name
	token = $tw.utils.parseTokenRegExp(source,pos,reTagName);
	if(!token) {
		return null;
	}
	node.tag = token.match[1];
	if(node.tag.slice(1).indexOf("$") !== -1) {
		return null;
	}
	if(node.tag.charAt(0) === "$") {
		node.type = node.tag.substr(1);
	}
	pos = token.end;
	// Check that the tag is terminated by a space, / or >
	if(!$tw.utils.parseWhiteSpace(source,pos) && !(source.charAt(pos) === "/") && !(source.charAt(pos) === ">") ) {
		return null;
	}
	// Process attributes
	var attribute = $tw.utils.parseAttribute(source,pos);
	while(attribute) {
		node.attributes[attribute.name] = attribute;
		pos = attribute.end;
		// Get the next attribute
		attribute = $tw.utils.parseAttribute(source,pos);
	}
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for a closing slash
	token = $tw.utils.parseTokenString(source,pos,"/");
	if(token) {
		pos = token.end;
		node.isSelfClosing = true;
	}
	// Look for a greater than sign
	token = $tw.utils.parseTokenString(source,pos,">");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Check for a required line break
	if(options.requireLineBreak) {
		token = $tw.utils.parseTokenRegExp(source,pos,/([^\S\n\r]*\r?\n(?:[^\S\n\r]*\r?\n|$))/g);
		if(!token) {
			return null;
		}
	}
	// Update the end position
	node.end = pos;
	return node;
};

exports.findNextTag = function(source,pos,options) {
	// A regexp for finding candidate HTML tags
	var reLookahead = /<([a-zA-Z\-\$]+)/g;
	// Find the next candidate
	reLookahead.lastIndex = pos;
	var match = reLookahead.exec(source);
	while(match) {
		// Try to parse the candidate as a tag
		var tag = this.parseTag(source,match.index,options);
		// Return success
		if(tag && this.isLegalTag(tag)) {
			return tag;
		}
		// Look for the next match
		reLookahead.lastIndex = match.index + 1;
		match = reLookahead.exec(source);
	}
	// Failed
	return null;
};

exports.isLegalTag = function(tag) {
	// Widgets are always OK
	if(tag.type !== "element") {
		return true;
	// If it's an HTML tag that starts with a dash then it's not legal
	} else if(tag.tag.charAt(0) === "-") {
		return false;
	} else {
		// Otherwise it's OK
		return true;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/image.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/image.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for embedding images. For example:

```
[img[https://tiddlywiki.com/fractalveg.jpg]]
[img width=23 height=24 [https://tiddlywiki.com/fractalveg.jpg]]
[img width={{!!width}} height={{!!height}} [https://tiddlywiki.com/fractalveg.jpg]]
[img[Description of image|https://tiddlywiki.com/fractalveg.jpg]]
[img[TiddlerTitle]]
[img[Description of image|TiddlerTitle]]
```

Generates the `<$image>` widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "image";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
};

exports.findNextMatch = function(startPos) {
	// Find the next tag
	this.nextImage = this.findNextImage(this.parser.source,startPos);
	return this.nextImage ? this.nextImage.start : undefined;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.nextImage.end;
	var node = {
		type: "image",
		attributes: this.nextImage.attributes
	};
	return [node];
};

/*
Find the next image from the current position
*/
exports.findNextImage = function(source,pos) {
	// A regexp for finding candidate HTML tags
	var reLookahead = /(\[img)/g;
	// Find the next candidate
	reLookahead.lastIndex = pos;
	var match = reLookahead.exec(source);
	while(match) {
		// Try to parse the candidate as a tag
		var tag = this.parseImage(source,match.index);
		// Return success
		if(tag) {
			return tag;
		}
		// Look for the next match
		reLookahead.lastIndex = match.index + 1;
		match = reLookahead.exec(source);
	}
	// Failed
	return null;
};

/*
Look for an image at the specified position. Returns null if not found, otherwise returns {type: "image", attributes: [], isSelfClosing:, start:, end:,}
*/
exports.parseImage = function(source,pos) {
	var token,
		node = {
			type: "image",
			start: pos,
			attributes: {}
		};
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for the `[img`
	token = $tw.utils.parseTokenString(source,pos,"[img");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Process attributes
	if(source.charAt(pos) !== "[") {
		var attribute = $tw.utils.parseAttribute(source,pos);
		while(attribute) {
			node.attributes[attribute.name] = attribute;
			pos = attribute.end;
			pos = $tw.utils.skipWhiteSpace(source,pos);
			if(source.charAt(pos) !== "[") {
				// Get the next attribute
				attribute = $tw.utils.parseAttribute(source,pos);
			} else {
				attribute = null;
			}
		}
	}
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for the `[` after the attributes
	token = $tw.utils.parseTokenString(source,pos,"[");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Get the source up to the terminating `]]`
	token = $tw.utils.parseTokenRegExp(source,pos,/(?:([^|\]]*?)\|)?([^\]]+?)\]\]/g);
	if(!token) {
		return null;
	}
	pos = token.end;
	if(token.match[1]) {
		node.attributes.tooltip = {type: "string", value: token.match[1].trim()};
	}
	node.attributes.source = {type: "string", value: (token.match[2] || "").trim()};
	// Update the end position
	node.end = pos;
	return node;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/import.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/import.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for importing variable definitions

```
\import [[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "import";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\import[^\S\n]/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	var self = this;
	// Move past the pragma invocation
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse the filter terminated by a line break
	var reMatch = /(.*)(\r?\n)|$/mg;
	reMatch.lastIndex = this.parser.pos;
	var match = reMatch.exec(this.parser.source);
	this.parser.pos = reMatch.lastIndex;
	// Parse tree nodes to return
	return [{
		type: "importvariables",
		attributes: {
			filter: {type: "string", value: match[1]}
		},
		children: []
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/list.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/list.js
type: application/javascript
module-type: wikirule

Wiki text block rule for lists. For example:

```
* This is an unordered list
* It has two items

# This is a numbered list
## With a subitem
# And a third item

; This is a term that is being defined
: This is the definition of that term
```

Note that lists can be nested arbitrarily:

```
#** One
#* Two
#** Three
#**** Four
#**# Five
#**## Six
## Seven
### Eight
## Nine
```

A CSS class can be applied to a list item as follows:

```
* List item one
*.active List item two has the class `active`
* List item three
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "list";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /([\*#;:>]+)/mg;
};

var listTypes = {
	"*": {listTag: "ul", itemTag: "li"},
	"#": {listTag: "ol", itemTag: "li"},
	";": {listTag: "dl", itemTag: "dt"},
	":": {listTag: "dl", itemTag: "dd"},
	">": {listTag: "blockquote", itemTag: "p"}
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Array of parse tree nodes for the previous row of the list
	var listStack = [];
	// Cycle through the items in the list
	while(true) {
		// Match the list marker
		var reMatch = /([\*#;:>]+)/mg;
		reMatch.lastIndex = this.parser.pos;
		var match = reMatch.exec(this.parser.source);
		if(!match || match.index !== this.parser.pos) {
			break;
		}
		// Check whether the list type of the top level matches
		var listInfo = listTypes[match[0].charAt(0)];
		if(listStack.length > 0 && listStack[0].tag !== listInfo.listTag) {
			break;
		}
		// Move past the list marker
		this.parser.pos = match.index + match[0].length;
		// Walk through the list markers for the current row
		for(var t=0; t<match[0].length; t++) {
			listInfo = listTypes[match[0].charAt(t)];
			// Remove any stacked up element if we can't re-use it because the list type doesn't match
			if(listStack.length > t && listStack[t].tag !== listInfo.listTag) {
				listStack.splice(t,listStack.length - t);
			}
			// Construct the list element or reuse the previous one at this level
			if(listStack.length <= t) {
				var listElement = {type: "element", tag: listInfo.listTag, children: [
					{type: "element", tag: listInfo.itemTag, children: []}
				]};
				// Link this list element into the last child item of the parent list item
				if(t) {
					var prevListItem = listStack[t-1].children[listStack[t-1].children.length-1];
					prevListItem.children.push(listElement);
				}
				// Save this element in the stack
				listStack[t] = listElement;
			} else if(t === (match[0].length - 1)) {
				listStack[t].children.push({type: "element", tag: listInfo.itemTag, children: []});
			}
		}
		if(listStack.length > match[0].length) {
			listStack.splice(match[0].length,listStack.length - match[0].length);
		}
		// Process the body of the list item into the last list item
		var lastListChildren = listStack[listStack.length-1].children,
			lastListItem = lastListChildren[lastListChildren.length-1],
			classes = this.parser.parseClasses();
		this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
		var tree = this.parser.parseInlineRun(/(\r?\n)/mg);
		lastListItem.children.push.apply(lastListItem.children,tree);
		if(classes.length > 0) {
			$tw.utils.addClassToParseTreeNode(lastListItem,classes.join(" "));
		}
		// Consume any whitespace following the list item
		this.parser.skipWhitespace();
	}
	// Return the root element of the list
	return [listStack[0]];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/macrocallblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/macrocallblock.js
type: application/javascript
module-type: wikirule

Wiki rule for block macro calls

```
<<name value value2>>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrocallblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /<<([^>\s]+)(?:\s*)((?:[^>]|(?:>(?!>)))*?)>>(?:\r?\n|$)/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var macroName = this.match[1],
		paramString = this.match[2];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	var params = [],
		reParam = /\s*(?:([A-Za-z0-9\-_]+)\s*:)?(?:\s*(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))/mg,
		paramMatch = reParam.exec(paramString);
	while(paramMatch) {
		// Process this parameter
		var paramInfo = {
			value: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]
		};
		if(paramMatch[1]) {
			paramInfo.name = paramMatch[1];
		}
		params.push(paramInfo);
		// Find the next match
		paramMatch = reParam.exec(paramString);
	}
	return [{
		type: "macrocall",
		name: macroName,
		params: params,
		isBlock: true
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/macrocallinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/macrocallinline.js
type: application/javascript
module-type: wikirule

Wiki rule for macro calls

```
<<name value value2>>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrocallinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /<<([^\s>]+)\s*([\s\S]*?)>>/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var macroName = this.match[1],
		paramString = this.match[2];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	var params = [],
		reParam = /\s*(?:([A-Za-z0-9\-_]+)\s*:)?(?:\s*(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))/mg,
		paramMatch = reParam.exec(paramString);
	while(paramMatch) {
		// Process this parameter
		var paramInfo = {
			value: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5]|| paramMatch[6]
		};
		if(paramMatch[1]) {
			paramInfo.name = paramMatch[1];
		}
		params.push(paramInfo);
		// Find the next match
		paramMatch = reParam.exec(paramString);
	}
	return [{
		type: "macrocall",
		name: macroName,
		params: params
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/macrodef.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/macrodef.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for macro definitions

```
\define name(param:defaultvalue,param2:defaultvalue)
definition text, including $param$ markers
\end
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrodef";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\define\s+([^(\s]+)\(\s*([^)]*)\)(\s*\r?\n)?/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Move past the macro name and parameters
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse the parameters
	var paramString = this.match[2],
		params = [];
	if(paramString !== "") {
		var reParam = /\s*([A-Za-z0-9\-_]+)(?:\s*:\s*(?:"""([\s\S]*?)"""|"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))?/mg,
			paramMatch = reParam.exec(paramString);
		while(paramMatch) {
			// Save the parameter details
			var paramInfo = {name: paramMatch[1]},
				defaultValue = paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6];
			if(defaultValue) {
				paramInfo["default"] = defaultValue;
			}
			params.push(paramInfo);
			// Look for the next parameter
			paramMatch = reParam.exec(paramString);
		}
	}
	// Is this a multiline definition?
	var reEnd;
	if(this.match[3]) {
		// If so, the end of the body is marked with \end
		reEnd = /(\r?\n\\end[^\S\n\r]*(?:$|\r?\n))/mg;
	} else {
		// Otherwise, the end of the definition is marked by the end of the line
		reEnd = /($|\r?\n)/mg;
		// Move past any whitespace
		this.parser.pos = $tw.utils.skipWhiteSpace(this.parser.source,this.parser.pos);
	}
	// Find the end of the definition
	reEnd.lastIndex = this.parser.pos;
	var text,
		endMatch = reEnd.exec(this.parser.source);
	if(endMatch) {
		text = this.parser.source.substring(this.parser.pos,endMatch.index);
		this.parser.pos = endMatch.index + endMatch[0].length;
	} else {
		// We didn't find the end of the definition, so we'll make it blank
		text = "";
	}
	// Save the macro definition
	return [{
		type: "set",
		attributes: {
			name: {type: "string", value: this.match[1]},
			value: {type: "string", value: text}
		},
		children: [],
		params: params,
		isMacroDefinition: true
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/prettyextlink.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/prettyextlink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for external links. For example:

```
[ext[https://tiddlywiki.com/fractalveg.jpg]]
[ext[Tooltip|https://tiddlywiki.com/fractalveg.jpg]]
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "prettyextlink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
};

exports.findNextMatch = function(startPos) {
	// Find the next tag
	this.nextLink = this.findNextLink(this.parser.source,startPos);
	return this.nextLink ? this.nextLink.start : undefined;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.nextLink.end;
	return [this.nextLink];
};

/*
Find the next link from the current position
*/
exports.findNextLink = function(source,pos) {
	// A regexp for finding candidate links
	var reLookahead = /(\[ext\[)/g;
	// Find the next candidate
	reLookahead.lastIndex = pos;
	var match = reLookahead.exec(source);
	while(match) {
		// Try to parse the candidate as a link
		var link = this.parseLink(source,match.index);
		// Return success
		if(link) {
			return link;
		}
		// Look for the next match
		reLookahead.lastIndex = match.index + 1;
		match = reLookahead.exec(source);
	}
	// Failed
	return null;
};

/*
Look for an link at the specified position. Returns null if not found, otherwise returns {type: "element", tag: "a", attributes: [], isSelfClosing:, start:, end:,}
*/
exports.parseLink = function(source,pos) {
	var token,
		textNode = {
			type: "text"
		},
		node = {
			type: "element",
			tag: "a",
			start: pos,
			attributes: {
				"class": {type: "string", value: "tc-tiddlylink-external"},
			},
			children: [textNode]
		};
	// Skip whitespace
	pos = $tw.utils.skipWhiteSpace(source,pos);
	// Look for the `[ext[`
	token = $tw.utils.parseTokenString(source,pos,"[ext[");
	if(!token) {
		return null;
	}
	pos = token.end;
	// Look ahead for the terminating `]]`
	var closePos = source.indexOf("]]",pos);
	if(closePos === -1) {
		return null;
	}
	// Look for a `|` separating the tooltip
	var splitPos = source.indexOf("|",pos);
	if(splitPos === -1 || splitPos > closePos) {
		splitPos = null;
	}
	// Pull out the tooltip and URL
	var tooltip, URL;
	if(splitPos) {
		URL = source.substring(splitPos + 1,closePos).trim();
		textNode.text = source.substring(pos,splitPos).trim();
	} else {
		URL = source.substring(pos,closePos).trim();
		textNode.text = URL;
	}
	node.attributes.href = {type: "string", value: URL};
	node.attributes.target = {type: "string", value: "_blank"};
	node.attributes.rel = {type: "string", value: "noopener noreferrer"};
	// Update the end position
	node.end = closePos + 2;
	return node;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/prettylink.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/prettylink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for pretty links. For example:

```
[[Introduction]]

[[Link description|TiddlerTitle]]
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "prettylink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\[\[(.*?)(?:\|(.*?))?\]\]/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Process the link
	var text = this.match[1],
		link = this.match[2] || text;
	if($tw.utils.isLinkExternal(link)) {
		return [{
			type: "element",
			tag: "a",
			attributes: {
				href: {type: "string", value: link},
				"class": {type: "string", value: "tc-tiddlylink-external"},
				target: {type: "string", value: "_blank"},
				rel: {type: "string", value: "noopener noreferrer"}
			},
			children: [{
				type: "text", text: text
			}]
		}];
	} else {
		return [{
			type: "link",
			attributes: {
				to: {type: "string", value: link}
			},
			children: [{
				type: "text", text: text
			}]
		}];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/quoteblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/quoteblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for quote blocks. For example:

```
	<<<.optionalClass(es) optional cited from
	a quote
	<<<
	
	<<<.optionalClass(es)
	a quote
	<<< optional cited from
```

Quotes can be quoted by putting more <s

```
	<<<
	Quote Level 1
	
	<<<<
	QuoteLevel 2
	<<<<
	
	<<<
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "quoteblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(<<<+)/mg;
};

exports.parse = function() {
	var classes = ["tc-quote"];
	// Get all the details of the match
	var reEndString = "^" + this.match[1] + "(?!<)";
	// Move past the <s
	this.parser.pos = this.matchRegExp.lastIndex;
	
	// Parse any classes, whitespace and then the optional cite itself
	classes.push.apply(classes, this.parser.parseClasses());
	this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
	var cite = this.parser.parseInlineRun(/(\r?\n)/mg);
	// before handling the cite, parse the body of the quote
	var tree= this.parser.parseBlocks(reEndString);
	// If we got a cite, put it before the text
	if(cite.length > 0) {
		tree.unshift({
			type: "element",
			tag: "cite",
			children: cite
		});
	}
	// Parse any optional cite
	this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
	cite = this.parser.parseInlineRun(/(\r?\n)/mg);
	// If we got a cite, push it
	if(cite.length > 0) {
		tree.push({
			type: "element",
			tag: "cite",
			children: cite
		});
	}
	// Return the blockquote element
	return [{
		type: "element",
		tag: "blockquote",
		attributes: {
			class: { type: "string", value: classes.join(" ") },
		},
		children: tree
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/rules.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/rules.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for rules specifications

```
\rules except ruleone ruletwo rulethree
\rules only ruleone ruletwo rulethree
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "rules";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\rules[^\S\n]/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Move past the pragma invocation
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse whitespace delimited tokens terminated by a line break
	var reMatch = /[^\S\n]*(\S+)|(\r?\n)/mg,
		tokens = [];
	reMatch.lastIndex = this.parser.pos;
	var match = reMatch.exec(this.parser.source);
	while(match && match.index === this.parser.pos) {
		this.parser.pos = reMatch.lastIndex;
		// Exit if we've got the line break
		if(match[2]) {
			break;
		}
		// Process the token
		if(match[1]) {
			tokens.push(match[1]);
		}
		// Match the next token
		match = reMatch.exec(this.parser.source);
	}
	// Process the tokens
	if(tokens.length > 0) {
		this.parser.amendRules(tokens[0],tokens.slice(1));
	}
	// No parse tree nodes to return
	return [];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/styleblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/styleblock.js
type: application/javascript
module-type: wikirule

Wiki text block rule for assigning styles and classes to paragraphs and other blocks. For example:

```
@@.myClass
@@background-color:red;
This paragraph will have the CSS class `myClass`.

* The `<ul>` around this list will also have the class `myClass`
* List item 2

@@
```

Note that classes and styles can be mixed subject to the rule that styles must precede classes. For example

```
@@.myFirstClass.mySecondClass
@@width:100px;.myThirdClass
This is a paragraph
@@
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "styleblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /@@((?:[^\.\r\n\s:]+:[^\r\n;]+;)+)?(?:\.([^\r\n\s]+))?\r?\n/mg;
};

exports.parse = function() {
	var reEndString = "^@@(?:\\r?\\n)?";
	var classes = [], styles = [];
	do {
		// Get the class and style
		if(this.match[1]) {
			styles.push(this.match[1]);
		}
		if(this.match[2]) {
			classes.push(this.match[2].split(".").join(" "));
		}
		// Move past the match
		this.parser.pos = this.matchRegExp.lastIndex;
		// Look for another line of classes and styles
		this.match = this.matchRegExp.exec(this.parser.source);
	} while(this.match && this.match.index === this.parser.pos);
	// Parse the body
	var tree = this.parser.parseBlocks(reEndString);
	for(var t=0; t<tree.length; t++) {
		if(classes.length > 0) {
			$tw.utils.addClassToParseTreeNode(tree[t],classes.join(" "));
		}
		if(styles.length > 0) {
			$tw.utils.addAttributeToParseTreeNode(tree[t],"style",styles.join(""));
		}
	}
	return tree;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/styleinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/styleinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for assigning styles and classes to inline runs. For example:

```
@@.myClass This is some text with a class@@
@@background-color:red;This is some text with a background colour@@
@@width:100px;.myClass This is some text with a class and a width@@
```


\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "styleinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /@@((?:[^\.\r\n\s:]+:[^\r\n;]+;)+)?(\.(?:[^\r\n\s]+)\s+)?/mg;
};

exports.parse = function() {
	var reEnd = /@@/g;
	// Get the styles and class
	var stylesString = this.match[1],
		classString = this.match[2] ? this.match[2].split(".").join(" ") : undefined;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse the run up to the terminator
	var tree = this.parser.parseInlineRun(reEnd,{eatTerminator: true});
	// Return the classed span
	var node = {
		type: "element",
		tag: "span",
		attributes: {
			"class": {type: "string", value: "tc-inline-style"}
		},
		children: tree
	};
	if(classString) {
		$tw.utils.addClassToParseTreeNode(node,classString);
	}
	if(stylesString) {
		$tw.utils.addAttributeToParseTreeNode(node,"style",stylesString);
	}
	return [node];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/syslink.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/syslink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for system tiddler links.
Can be suppressed preceding them with `~`.
\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "syslink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = new RegExp(
		"~?\\$:\\/[" +
		$tw.config.textPrimitives.anyLetter.substr(1,$tw.config.textPrimitives.anyLetter.length - 2) +
		"\/._-]+",
		"mg"
	);
};

exports.parse = function() {
	var match = this.match[0];
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Create the link unless it is suppressed
	if(match.substr(0,1) === "~") {
		return [{type: "text", text: match.substr(1)}];
	} else {
		return [{
			type: "link",
			attributes: {
				to: {type: "string", value: match}
			},
			children: [{
				type: "text",
				text: match
			}]
		}];
	}
};

})();
;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/table.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/table.js
type: application/javascript
module-type: wikirule

Wiki text block rule for tables.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "table";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\|(?:[^\n]*)\|(?:[fhck]?)\r?(?:\n|$)/mg;
};

var processRow = function(prevColumns) {
	var cellRegExp = /(?:\|([^\n\|]*)\|)|(\|[fhck]?\r?(?:\n|$))/mg,
		cellTermRegExp = /((?:\x20*)\|)/mg,
		tree = [],
		col = 0,
		colSpanCount = 1,
		prevCell,
		vAlign;
	// Match a single cell
	cellRegExp.lastIndex = this.parser.pos;
	var cellMatch = cellRegExp.exec(this.parser.source);
	while(cellMatch && cellMatch.index === this.parser.pos) {
		if(cellMatch[1] === "~") {
			// Rowspan
			var last = prevColumns[col];
			if(last) {
				last.rowSpanCount++;
				$tw.utils.addAttributeToParseTreeNode(last.element,"rowspan",last.rowSpanCount);
				vAlign = $tw.utils.getAttributeValueFromParseTreeNode(last.element,"valign","center");
				$tw.utils.addAttributeToParseTreeNode(last.element,"valign",vAlign);
				if(colSpanCount > 1) {
					$tw.utils.addAttributeToParseTreeNode(last.element,"colspan",colSpanCount);
					colSpanCount = 1;
				}
			}
			// Move to just before the `|` terminating the cell
			this.parser.pos = cellRegExp.lastIndex - 1;
		} else if(cellMatch[1] === ">") {
			// Colspan
			colSpanCount++;
			// Move to just before the `|` terminating the cell
			this.parser.pos = cellRegExp.lastIndex - 1;
		} else if(cellMatch[1] === "<" && prevCell) {
			colSpanCount = 1 + $tw.utils.getAttributeValueFromParseTreeNode(prevCell,"colspan",1);
			$tw.utils.addAttributeToParseTreeNode(prevCell,"colspan",colSpanCount);
			colSpanCount = 1;
			// Move to just before the `|` terminating the cell
			this.parser.pos = cellRegExp.lastIndex - 1;
		} else if(cellMatch[2]) {
			// End of row
			if(prevCell && colSpanCount > 1) {
				if(prevCell.attributes && prevCell.attributes && prevCell.attributes.colspan) {
						colSpanCount += prevCell.attributes.colspan.value;
				} else {
					colSpanCount -= 1;
				}
				$tw.utils.addAttributeToParseTreeNode(prevCell,"colspan",colSpanCount);
			}
			this.parser.pos = cellRegExp.lastIndex - 1;
			break;
		} else {
			// For ordinary cells, step beyond the opening `|`
			this.parser.pos++;
			// Look for a space at the start of the cell
			var spaceLeft = false;
			vAlign = null;
			if(this.parser.source.substr(this.parser.pos).search(/^\^([^\^]|\^\^)/) === 0) {
				vAlign = "top";
			} else if(this.parser.source.substr(this.parser.pos).search(/^,([^,]|,,)/) === 0) {
				vAlign = "bottom";
			}
			if(vAlign) {
				this.parser.pos++;
			}
			var chr = this.parser.source.substr(this.parser.pos,1);
			while(chr === " ") {
				spaceLeft = true;
				this.parser.pos++;
				chr = this.parser.source.substr(this.parser.pos,1);
			}
			// Check whether this is a heading cell
			var cell;
			if(chr === "!") {
				this.parser.pos++;
				cell = {type: "element", tag: "th", children: []};
			} else {
				cell = {type: "element", tag: "td", children: []};
			}
			tree.push(cell);
			// Record information about this cell
			prevCell = cell;
			prevColumns[col] = {rowSpanCount:1,element:cell};
			// Check for a colspan
			if(colSpanCount > 1) {
				$tw.utils.addAttributeToParseTreeNode(cell,"colspan",colSpanCount);
				colSpanCount = 1;
			}
			// Parse the cell
			cell.children = this.parser.parseInlineRun(cellTermRegExp,{eatTerminator: true});
			// Set the alignment for the cell
			if(vAlign) {
				$tw.utils.addAttributeToParseTreeNode(cell,"valign",vAlign);
			}
			if(this.parser.source.substr(this.parser.pos - 2,1) === " ") { // spaceRight
				$tw.utils.addAttributeToParseTreeNode(cell,"align",spaceLeft ? "center" : "left");
			} else if(spaceLeft) {
				$tw.utils.addAttributeToParseTreeNode(cell,"align","right");
			}
			// Move back to the closing `|`
			this.parser.pos--;
		}
		col++;
		cellRegExp.lastIndex = this.parser.pos;
		cellMatch = cellRegExp.exec(this.parser.source);
	}
	return tree;
};

exports.parse = function() {
	var rowContainerTypes = {"c":"caption", "h":"thead", "":"tbody", "f":"tfoot"},
		table = {type: "element", tag: "table", children: []},
		rowRegExp = /^\|([^\n]*)\|([fhck]?)\r?(?:\n|$)/mg,
		rowTermRegExp = /(\|(?:[fhck]?)\r?(?:\n|$))/mg,
		prevColumns = [],
		currRowType,
		rowContainer,
		rowCount = 0;
	// Match the row
	rowRegExp.lastIndex = this.parser.pos;
	var rowMatch = rowRegExp.exec(this.parser.source);
	while(rowMatch && rowMatch.index === this.parser.pos) {
		var rowType = rowMatch[2];
		// Check if it is a class assignment
		if(rowType === "k") {
			$tw.utils.addClassToParseTreeNode(table,rowMatch[1]);
			this.parser.pos = rowMatch.index + rowMatch[0].length;
		} else {
			// Otherwise, create a new row if this one is of a different type
			if(rowType !== currRowType) {
				rowContainer = {type: "element", tag: rowContainerTypes[rowType], children: []};
				table.children.push(rowContainer);
				currRowType = rowType;
			}
			// Is this a caption row?
			if(currRowType === "c") {
				// If so, move past the opening `|` of the row
				this.parser.pos++;
				// Move the caption to the first row if it isn't already
				if(table.children.length !== 1) {
					table.children.pop(); // Take rowContainer out of the children array
					table.children.splice(0,0,rowContainer); // Insert it at the bottom						
				}
				// Set the alignment - TODO: figure out why TW did this
//				rowContainer.attributes.align = rowCount === 0 ? "top" : "bottom";
				// Parse the caption
				rowContainer.children = this.parser.parseInlineRun(rowTermRegExp,{eatTerminator: true});
			} else {
				// Create the row
				var theRow = {type: "element", tag: "tr", children: []};
				$tw.utils.addClassToParseTreeNode(theRow,rowCount%2 ? "oddRow" : "evenRow");
				rowContainer.children.push(theRow);
				// Process the row
				theRow.children = processRow.call(this,prevColumns);
				this.parser.pos = rowMatch.index + rowMatch[0].length;
				// Increment the row count
				rowCount++;
			}
		}
		rowMatch = rowRegExp.exec(this.parser.source);
	}
	return [table];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/transcludeblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/transcludeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for block-level transclusion. For example:

```
{{MyTiddler}}
{{MyTiddler||TemplateTitle}}
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "transcludeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{([^\{\}\|]*)(?:\|\|([^\|\{\}]+))?\}\}(?:\r?\n|$)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var template = $tw.utils.trim(this.match[2]),
		textRef = $tw.utils.trim(this.match[1]);
	// Prepare the transclude widget
	var transcludeNode = {
			type: "transclude",
			attributes: {},
			isBlock: true
		};
	// Prepare the tiddler widget
	var tr, targetTitle, targetField, targetIndex, tiddlerNode;
	if(textRef) {
		tr = $tw.utils.parseTextReference(textRef);
		targetTitle = tr.title;
		targetField = tr.field;
		targetIndex = tr.index;
		tiddlerNode = {
			type: "tiddler",
			attributes: {
				tiddler: {type: "string", value: targetTitle}
			},
			isBlock: true,
			children: [transcludeNode]
		};
	}
	if(template) {
		transcludeNode.attributes.tiddler = {type: "string", value: template};
		if(textRef) {
			return [tiddlerNode];
		} else {
			return [transcludeNode];
		}
	} else {
		if(textRef) {
			transcludeNode.attributes.tiddler = {type: "string", value: targetTitle};
			if(targetField) {
				transcludeNode.attributes.field = {type: "string", value: targetField};
			}
			if(targetIndex) {
				transcludeNode.attributes.index = {type: "string", value: targetIndex};
			}
			return [tiddlerNode];
		} else {
			return [transcludeNode];
		}
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/transcludeinline.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/transcludeinline.js
type: application/javascript
module-type: wikirule

Wiki text rule for inline-level transclusion. For example:

```
{{MyTiddler}}
{{MyTiddler||TemplateTitle}}
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "transcludeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{([^\{\}\|]*)(?:\|\|([^\|\{\}]+))?\}\}/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var template = $tw.utils.trim(this.match[2]),
		textRef = $tw.utils.trim(this.match[1]);
	// Prepare the transclude widget
	var transcludeNode = {
			type: "transclude",
			attributes: {}
		};
	// Prepare the tiddler widget
	var tr, targetTitle, targetField, targetIndex, tiddlerNode;
	if(textRef) {
		tr = $tw.utils.parseTextReference(textRef);
		targetTitle = tr.title;
		targetField = tr.field;
		targetIndex = tr.index;
		tiddlerNode = {
			type: "tiddler",
			attributes: {
				tiddler: {type: "string", value: targetTitle}
			},
			children: [transcludeNode]
		};
	}
	if(template) {
		transcludeNode.attributes.tiddler = {type: "string", value: template};
		if(textRef) {
			return [tiddlerNode];
		} else {
			return [transcludeNode];
		}
	} else {
		if(textRef) {
			transcludeNode.attributes.tiddler = {type: "string", value: targetTitle};
			if(targetField) {
				transcludeNode.attributes.field = {type: "string", value: targetField};
			}
			if(targetIndex) {
				transcludeNode.attributes.index = {type: "string", value: targetIndex};
			}
			return [tiddlerNode];
		} else {
			return [transcludeNode];
		}
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/typedblock.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/typedblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for typed blocks. For example:

```
$$$.js
This will be rendered as JavaScript
$$$

$$$.svg
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="100">
  <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red" />
</svg>
$$$

$$$text/vnd.tiddlywiki>text/html
This will be rendered as an //HTML representation// of WikiText
$$$
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

exports.name = "typedblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\$\$\$([^ >\r\n]*)(?: *> *([^ \r\n]+))?\r?\n/mg;
};

exports.parse = function() {
	var reEnd = /\r?\n\$\$\$\r?(?:\n|$)/mg;
	// Save the type
	var parseType = this.match[1],
		renderType = this.match[2];
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Look for the end of the block
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the block
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	// Parse the block according to the specified type
	var parser = this.parser.wiki.parseText(parseType,text,{defaultType: "text/plain"});
	// If there's no render type, just return the parse tree
	if(!renderType) {
		return parser.tree;
	} else {
		// Otherwise, render to the rendertype and return in a <PRE> tag
		var widgetNode = this.parser.wiki.makeWidget(parser),
			container = $tw.fakeDocument.createElement("div");
		widgetNode.render(container,null);
		text = renderType === "text/html" ? container.innerHTML : container.textContent;
		return [{
			type: "element",
			tag: "pre",
			children: [{
				type: "text",
				text: text
			}]
		}];
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/whitespace.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/whitespace.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for whitespace specifications

```
\whitespace trim
\whitespace notrim
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "whitespace";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\whitespace[^\S\n]/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	var self = this;
	// Move past the pragma invocation
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse whitespace delimited tokens terminated by a line break
	var reMatch = /[^\S\n]*(\S+)|(\r?\n)/mg,
		tokens = [];
	reMatch.lastIndex = this.parser.pos;
	var match = reMatch.exec(this.parser.source);
	while(match && match.index === this.parser.pos) {
		this.parser.pos = reMatch.lastIndex;
		// Exit if we've got the line break
		if(match[2]) {
			break;
		}
		// Process the token
		if(match[1]) {
			tokens.push(match[1]);
		}
		// Match the next token
		match = reMatch.exec(this.parser.source);
	}
	// Process the tokens
	$tw.utils.each(tokens,function(token) {
		switch(token) {
			case "trim":
				self.parser.configTrimWhiteSpace = true;
				break;
			case "notrim":
				self.parser.configTrimWhiteSpace = false;
				break;
		}
	});
	// No parse tree nodes to return
	return [];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/wikilink.js","wikirule",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/wikilink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for wiki links. For example:

```
AWikiLink
AnotherLink
~SuppressedLink
```

Precede a camel case word with `~` to prevent it from being recognised as a link.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "wikilink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = new RegExp($tw.config.textPrimitives.unWikiLink + "?" + $tw.config.textPrimitives.wikiLink,"mg");
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get the details of the match
	var linkText = this.match[0];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	// If the link starts with the unwikilink character then just output it as plain text
	if(linkText.substr(0,1) === $tw.config.textPrimitives.unWikiLink) {
		return [{type: "text", text: linkText.substr(1)}];
	}
	// If the link has been preceded with a blocked letter then don't treat it as a link
	if(this.match.index > 0) {
		var preRegExp = new RegExp($tw.config.textPrimitives.blockPrefixLetters,"mg");
		preRegExp.lastIndex = this.match.index-1;
		var preMatch = preRegExp.exec(this.parser.source);
		if(preMatch && preMatch.index === this.match.index-1) {
			return [{type: "text", text: linkText}];
		}
	}
	return [{
		type: "link",
		attributes: {
			to: {type: "string", value: linkText}
		},
		children: [{
			type: "text",
			text: linkText
		}]
	}];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/wikiparser.js","parser",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/wikiparser.js
type: application/javascript
module-type: parser

The wiki text parser processes blocks of source text into a parse tree.

The parse tree is made up of nested arrays of these JavaScript objects:

	{type: "element", tag: <string>, attributes: {}, children: []} - an HTML element
	{type: "text", text: <string>} - a text node
	{type: "entity", value: <string>} - an entity
	{type: "raw", html: <string>} - raw HTML

Attributes are stored as hashmaps of the following objects:

	{type: "string", value: <string>} - literal string
	{type: "indirect", textReference: <textReference>} - indirect through a text reference
	{type: "macro", macro: <TBD>} - indirect through a macro invocation

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var WikiParser = function(type,text,options) {
	this.wiki = options.wiki;
	var self = this;
	// Check for an externally linked tiddler
	if($tw.browser && (text || "") === "" && options._canonical_uri) {
		this.loadRemoteTiddler(options._canonical_uri);
		text = $tw.language.getRawString("LazyLoadingWarning");
	}
	// Initialise the classes if we don't have them already
	if(!this.pragmaRuleClasses) {
		WikiParser.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules("wikirule","pragma",$tw.WikiRuleBase);
		this.setupRules(WikiParser.prototype.pragmaRuleClasses,"$:/config/WikiParserRules/Pragmas/");
	}
	if(!this.blockRuleClasses) {
		WikiParser.prototype.blockRuleClasses = $tw.modules.createClassesFromModules("wikirule","block",$tw.WikiRuleBase);
		this.setupRules(WikiParser.prototype.blockRuleClasses,"$:/config/WikiParserRules/Block/");
	}
	if(!this.inlineRuleClasses) {
		WikiParser.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules("wikirule","inline",$tw.WikiRuleBase);
		this.setupRules(WikiParser.prototype.inlineRuleClasses,"$:/config/WikiParserRules/Inline/");
	}
	// Save the parse text
	this.type = type || "text/vnd.tiddlywiki";
	this.source = text || "";
	this.sourceLength = this.source.length;
	// Flag for ignoring whitespace
	this.configTrimWhiteSpace = false;
	// Set current parse position
	this.pos = 0;
	// Instantiate the pragma parse rules
	this.pragmaRules = this.instantiateRules(this.pragmaRuleClasses,"pragma",0);
	// Instantiate the parser block and inline rules
	this.blockRules = this.instantiateRules(this.blockRuleClasses,"block",0);
	this.inlineRules = this.instantiateRules(this.inlineRuleClasses,"inline",0);
	// Parse any pragmas
	this.tree = [];
	var topBranch = this.parsePragmas();
	// Parse the text into inline runs or blocks
	if(options.parseAsInline) {
		topBranch.push.apply(topBranch,this.parseInlineRun());
	} else {
		topBranch.push.apply(topBranch,this.parseBlocks());
	}
	// Return the parse tree
};

/*
*/
WikiParser.prototype.loadRemoteTiddler = function(url) {
	var self = this;
	$tw.utils.httpRequest({
		url: url,
		type: "GET",
		callback: function(err,data) {
			if(!err) {
				var tiddlers = self.wiki.deserializeTiddlers(".tid",data,self.wiki.getCreationFields());
				$tw.utils.each(tiddlers,function(tiddler) {
					tiddler["_canonical_uri"] = url;
				});
				if(tiddlers) {
					self.wiki.addTiddlers(tiddlers);
				}
			}
		}
	});
};

/*
*/
WikiParser.prototype.setupRules = function(proto,configPrefix) {
	var self = this;
	if(!$tw.safemode) {
		$tw.utils.each(proto,function(object,name) {
			if(self.wiki.getTiddlerText(configPrefix + name,"enable") !== "enable") {
				delete proto[name];
			}
		});
	}
};

/*
Instantiate an array of parse rules
*/
WikiParser.prototype.instantiateRules = function(classes,type,startPos) {
	var rulesInfo = [],
		self = this;
	$tw.utils.each(classes,function(RuleClass) {
		// Instantiate the rule
		var rule = new RuleClass(self);
		rule.is = {};
		rule.is[type] = true;
		rule.init(self);
		var matchIndex = rule.findNextMatch(startPos);
		if(matchIndex !== undefined) {
			rulesInfo.push({
				rule: rule,
				matchIndex: matchIndex
			});
		}
	});
	return rulesInfo;
};

/*
Skip any whitespace at the current position. Options are:
	treatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace
*/
WikiParser.prototype.skipWhitespace = function(options) {
	options = options || {};
	var whitespaceRegExp = options.treatNewlinesAsNonWhitespace ? /([^\S\n]+)/mg : /(\s+)/mg;
	whitespaceRegExp.lastIndex = this.pos;
	var whitespaceMatch = whitespaceRegExp.exec(this.source);
	if(whitespaceMatch && whitespaceMatch.index === this.pos) {
		this.pos = whitespaceRegExp.lastIndex;
	}
};

/*
Get the next match out of an array of parse rule instances
*/
WikiParser.prototype.findNextMatch = function(rules,startPos) {
	// Find the best matching rule by finding the closest match position
	var matchingRule,
		matchingRulePos = this.sourceLength;
	// Step through each rule
	for(var t=0; t<rules.length; t++) {
		var ruleInfo = rules[t];
		// Ask the rule to get the next match if we've moved past the current one
		if(ruleInfo.matchIndex !== undefined  && ruleInfo.matchIndex < startPos) {
			ruleInfo.matchIndex = ruleInfo.rule.findNextMatch(startPos);
		}
		// Adopt this match if it's closer than the current best match
		if(ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex <= matchingRulePos) {
			matchingRule = ruleInfo;
			matchingRulePos = ruleInfo.matchIndex;
		}
	}
	return matchingRule;
};

/*
Parse any pragmas at the beginning of a block of parse text
*/
WikiParser.prototype.parsePragmas = function() {
	var currentTreeBranch = this.tree;
	while(true) {
		// Skip whitespace
		this.skipWhitespace();
		// Check for the end of the text
		if(this.pos >= this.sourceLength) {
			break;
		}
		// Check if we've arrived at a pragma rule match
		var nextMatch = this.findNextMatch(this.pragmaRules,this.pos);
		// If not, just exit
		if(!nextMatch || nextMatch.matchIndex !== this.pos) {
			break;
		}
		// Process the pragma rule
		var subTree = nextMatch.rule.parse();
		if(subTree.length > 0) {
			// Quick hack; we only cope with a single parse tree node being returned, which is true at the moment
			currentTreeBranch.push.apply(currentTreeBranch,subTree);
			subTree[0].children = [];
			currentTreeBranch = subTree[0].children;
		}
	}
	return currentTreeBranch;
};

/*
Parse a block from the current position
	terminatorRegExpString: optional regular expression string that identifies the end of plain paragraphs. Must not include capturing parenthesis
*/
WikiParser.prototype.parseBlock = function(terminatorRegExpString) {
	var terminatorRegExp = terminatorRegExpString ? new RegExp("(" + terminatorRegExpString + "|\\r?\\n\\r?\\n)","mg") : /(\r?\n\r?\n)/mg;
	this.skipWhitespace();
	if(this.pos >= this.sourceLength) {
		return [];
	}
	// Look for a block rule that applies at the current position
	var nextMatch = this.findNextMatch(this.blockRules,this.pos);
	if(nextMatch && nextMatch.matchIndex === this.pos) {
		return nextMatch.rule.parse();
	}
	// Treat it as a paragraph if we didn't find a block rule
	return [{type: "element", tag: "p", children: this.parseInlineRun(terminatorRegExp)}];
};

/*
Parse a series of blocks of text until a terminating regexp is encountered or the end of the text
	terminatorRegExpString: terminating regular expression
*/
WikiParser.prototype.parseBlocks = function(terminatorRegExpString) {
	if(terminatorRegExpString) {
		return this.parseBlocksTerminated(terminatorRegExpString);
	} else {
		return this.parseBlocksUnterminated();
	}
};

/*
Parse a block from the current position to the end of the text
*/
WikiParser.prototype.parseBlocksUnterminated = function() {
	var tree = [];
	while(this.pos < this.sourceLength) {
		tree.push.apply(tree,this.parseBlock());
	}
	return tree;
};

/*
Parse blocks of text until a terminating regexp is encountered
*/
WikiParser.prototype.parseBlocksTerminated = function(terminatorRegExpString) {
	var terminatorRegExp = new RegExp("(" + terminatorRegExpString + ")","mg"),
		tree = [];
	// Skip any whitespace
	this.skipWhitespace();
	//  Check if we've got the end marker
	terminatorRegExp.lastIndex = this.pos;
	var match = terminatorRegExp.exec(this.source);
	// Parse the text into blocks
	while(this.pos < this.sourceLength && !(match && match.index === this.pos)) {
		var blocks = this.parseBlock(terminatorRegExpString);
		tree.push.apply(tree,blocks);
		// Skip any whitespace
		this.skipWhitespace();
		//  Check if we've got the end marker
		terminatorRegExp.lastIndex = this.pos;
		match = terminatorRegExp.exec(this.source);
	}
	if(match && match.index === this.pos) {
		this.pos = match.index + match[0].length;
	}
	return tree;
};

/*
Parse a run of text at the current position
	terminatorRegExp: a regexp at which to stop the run
	options: see below
Options available:
	eatTerminator: move the parse position past any encountered terminator (default false)
*/
WikiParser.prototype.parseInlineRun = function(terminatorRegExp,options) {
	if(terminatorRegExp) {
		return this.parseInlineRunTerminated(terminatorRegExp,options);
	} else {
		return this.parseInlineRunUnterminated(options);
	}
};

WikiParser.prototype.parseInlineRunUnterminated = function(options) {
	var tree = [];
	// Find the next occurrence of an inline rule
	var nextMatch = this.findNextMatch(this.inlineRules,this.pos);
	// Loop around the matches until we've reached the end of the text
	while(this.pos < this.sourceLength && nextMatch) {
		// Process the text preceding the run rule
		if(nextMatch.matchIndex > this.pos) {
			this.pushTextWidget(tree,this.source.substring(this.pos,nextMatch.matchIndex));
			this.pos = nextMatch.matchIndex;
		}
		// Process the run rule
		tree.push.apply(tree,nextMatch.rule.parse());
		// Look for the next run rule
		nextMatch = this.findNextMatch(this.inlineRules,this.pos);
	}
	// Process the remaining text
	if(this.pos < this.sourceLength) {
		this.pushTextWidget(tree,this.source.substr(this.pos));
	}
	this.pos = this.sourceLength;
	return tree;
};

WikiParser.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {
	options = options || {};
	var tree = [];
	// Find the next occurrence of the terminator
	terminatorRegExp.lastIndex = this.pos;
	var terminatorMatch = terminatorRegExp.exec(this.source);
	// Find the next occurrence of a inlinerule
	var inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);
	// Loop around until we've reached the end of the text
	while(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {
		// Return if we've found the terminator, and it precedes any inline rule match
		if(terminatorMatch) {
			if(!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {
				if(terminatorMatch.index > this.pos) {
					this.pushTextWidget(tree,this.source.substring(this.pos,terminatorMatch.index));
				}
				this.pos = terminatorMatch.index;
				if(options.eatTerminator) {
					this.pos += terminatorMatch[0].length;
				}
				return tree;
			}
		}
		// Process any inline rule, along with the text preceding it
		if(inlineRuleMatch) {
			// Preceding text
			if(inlineRuleMatch.matchIndex > this.pos) {
				this.pushTextWidget(tree,this.source.substring(this.pos,inlineRuleMatch.matchIndex));
				this.pos = inlineRuleMatch.matchIndex;
			}
			// Process the inline rule
			tree.push.apply(tree,inlineRuleMatch.rule.parse());
			// Look for the next inline rule
			inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);
			// Look for the next terminator match
			terminatorRegExp.lastIndex = this.pos;
			terminatorMatch = terminatorRegExp.exec(this.source);
		}
	}
	// Process the remaining text
	if(this.pos < this.sourceLength) {
		this.pushTextWidget(tree,this.source.substr(this.pos));
	}
	this.pos = this.sourceLength;
	return tree;
};

/*
Push a text widget onto an array, respecting the configTrimWhiteSpace setting
*/
WikiParser.prototype.pushTextWidget = function(array,text) {
	if(this.configTrimWhiteSpace) {
		text = $tw.utils.trim(text);
	}
	if(text) {
		array.push({type: "text", text: text});		
	}
};

/*
Parse zero or more class specifiers `.classname`
*/
WikiParser.prototype.parseClasses = function() {
	var classRegExp = /\.([^\s\.]+)/mg,
		classNames = [];
	classRegExp.lastIndex = this.pos;
	var match = classRegExp.exec(this.source);
	while(match && match.index === this.pos) {
		this.pos = match.index + match[0].length;
		classNames.push(match[1]);
		match = classRegExp.exec(this.source);
	}
	return classNames;
};

/*
Amend the rules used by this instance of the parser
	type: `only` keeps just the named rules, `except` keeps all but the named rules
	names: array of rule names
*/
WikiParser.prototype.amendRules = function(type,names) {
	names = names || [];
	// Define the filter function
	var keepFilter;
	if(type === "only") {
		keepFilter = function(name) {
			return names.indexOf(name) !== -1;
		};
	} else if(type === "except") {
		keepFilter = function(name) {
			return names.indexOf(name) === -1;
		};
	} else {
		return;
	}
	// Define a function to process each of our rule arrays
	var processRuleArray = function(ruleArray) {
		for(var t=ruleArray.length-1; t>=0; t--) {
			if(!keepFilter(ruleArray[t].rule.name)) {
				ruleArray.splice(t,1);
			}
		}
	};
	// Process each rule array
	processRuleArray(this.pragmaRules);
	processRuleArray(this.blockRules);
	processRuleArray(this.inlineRules);
};

exports["text/vnd.tiddlywiki"] = WikiParser;

})();


;})();
return exports;
}));
_define("$:/core/modules/parsers/wikiparser/rules/wikirulebase.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/parsers/wikiparser/rules/wikirulebase.js
type: application/javascript
module-type: global

Base class for wiki parser rules

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
This constructor is always overridden with a blank constructor, and so shouldn't be used
*/
var WikiRuleBase = function() {
};

/*
To be overridden by individual rules
*/
WikiRuleBase.prototype.init = function(parser) {
	this.parser = parser;
};

/*
Default implementation of findNextMatch uses RegExp matching
*/
WikiRuleBase.prototype.findNextMatch = function(startPos) {
	this.matchRegExp.lastIndex = startPos;
	this.match = this.matchRegExp.exec(this.parser.source);
	return this.match ? this.match.index : undefined;
};

exports.WikiRuleBase = WikiRuleBase;

})();

;})();
return exports;
}));
_define("$:/core/modules/pluginswitcher.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/pluginswitcher.js
type: application/javascript
module-type: global

Manages switching plugins for themes and languages.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
options:
wiki: wiki store to be used
pluginType: type of plugin to be switched
controllerTitle: title of tiddler used to control switching of this resource
defaultPlugins: array of default plugins to be used if nominated plugin isn't found
onSwitch: callback when plugin is switched (single parameter is array of plugin titles)
*/
function PluginSwitcher(options) {
	this.wiki = options.wiki;
	this.pluginType = options.pluginType;
	this.controllerTitle = options.controllerTitle;
	this.defaultPlugins = options.defaultPlugins || [];
	this.onSwitch = options.onSwitch;
	// Switch to the current plugin
	this.switchPlugins();
	// Listen for changes to the selected plugin
	var self = this;
	this.wiki.addEventListener("change",function(changes) {
		if($tw.utils.hop(changes,self.controllerTitle)) {
			self.switchPlugins();
		}
	});
}

PluginSwitcher.prototype.switchPlugins = function() {
	// Get the name of the current theme
	var selectedPluginTitle = this.wiki.getTiddlerText(this.controllerTitle);
	// If it doesn't exist, then fallback to one of the default themes
	var index = 0;
	while(!this.wiki.getTiddler(selectedPluginTitle) && index < this.defaultPlugins.length) {
		selectedPluginTitle = this.defaultPlugins[index++];
	}
	// Accumulate the titles of the plugins that we need to load
	var plugins = [],
		self = this,
		accumulatePlugin = function(title) {
			var tiddler = self.wiki.getTiddler(title);
			if(tiddler && tiddler.isPlugin() && plugins.indexOf(title) === -1) {
				plugins.push(title);
				var pluginInfo = JSON.parse(self.wiki.getTiddlerText(title)),
					dependents = $tw.utils.parseStringArray(tiddler.fields.dependents || "");
				$tw.utils.each(dependents,function(title) {
					accumulatePlugin(title);
				});
			}
		};
	accumulatePlugin(selectedPluginTitle);
	// Unregister any existing theme tiddlers
	var unregisteredTiddlers = $tw.wiki.unregisterPluginTiddlers(this.pluginType);
	// Register any new theme tiddlers
	var registeredTiddlers = $tw.wiki.registerPluginTiddlers(this.pluginType,plugins);
	// Unpack the current theme tiddlers
	$tw.wiki.unpackPluginTiddlers();
	// Call the switch handler
	if(this.onSwitch) {
		this.onSwitch(plugins);
	}
};

exports.PluginSwitcher = PluginSwitcher;

})();

;})();
return exports;
}));
_define("$:/core/modules/saver-handler.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/saver-handler.js
type: application/javascript
module-type: global

The saver handler tracks changes to the store and handles saving the entire wiki via saver modules.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Instantiate the saver handler with the following options:
wiki: wiki to be synced
dirtyTracking: true if dirty tracking should be performed
*/
function SaverHandler(options) {
	var self = this;
	this.wiki = options.wiki;
	this.dirtyTracking = options.dirtyTracking;
	this.preloadDirty = options.preloadDirty || [];
	this.pendingAutoSave = false;
	// Make a logger
	this.logger = new $tw.utils.Logger("saver-handler");
	// Initialise our savers
	if($tw.browser) {
		this.initSavers();
	}
	// Only do dirty tracking if required
	if($tw.browser && this.dirtyTracking) {
		// Compile the dirty tiddler filter
		this.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter));
		// Count of changes that have not yet been saved
		var filteredChanges = self.filterFn.call(self.wiki,function(iterator) {
				$tw.utils.each(self.preloadDirty,function(title) {
					var tiddler = self.wiki.getTiddler(title);
					iterator(tiddler,title);
				});
		});
		this.numChanges = filteredChanges.length;
		// Listen out for changes to tiddlers
		this.wiki.addEventListener("change",function(changes) {
			// Filter the changes so that we only count changes to tiddlers that we care about
			var filteredChanges = self.filterFn.call(self.wiki,function(iterator) {
				$tw.utils.each(changes,function(change,title) {
					var tiddler = self.wiki.getTiddler(title);
					iterator(tiddler,title);
				});
			});
			// Adjust the number of changes
			self.numChanges += filteredChanges.length;
			self.updateDirtyStatus();
			// Do any autosave if one is pending and there's no more change events
			if(self.pendingAutoSave && self.wiki.getSizeOfTiddlerEventQueue() === 0) {
				// Check if we're dirty
				if(self.numChanges > 0) {
					self.saveWiki({
						method: "autosave",
						downloadType: "text/plain"
					});
				}
				self.pendingAutoSave = false;
			}
		});
		// Listen for the autosave event
		$tw.rootWidget.addEventListener("tm-auto-save-wiki",function(event) {
			// Do the autosave unless there are outstanding tiddler change events
			if(self.wiki.getSizeOfTiddlerEventQueue() === 0) {
				// Check if we're dirty
				if(self.numChanges > 0) {
					self.saveWiki({
						method: "autosave",
						downloadType: "text/plain"
					});
				}
			} else {
				// Otherwise put ourselves in the "pending autosave" state and wait for the change event before we do the autosave
				self.pendingAutoSave = true;
			}
		});
		// Set up our beforeunload handler
		$tw.addUnloadTask(function(event) {
			var confirmationMessage;
			if(self.isDirty()) {
				confirmationMessage = $tw.language.getString("UnsavedChangesWarning");
				event.returnValue = confirmationMessage; // Gecko
			}
			return confirmationMessage;
		});
	}
	// Install the save action handlers
	if($tw.browser) {
		$tw.rootWidget.addEventListener("tm-save-wiki",function(event) {
			self.saveWiki({
				template: event.param,
				downloadType: "text/plain",
				variables: event.paramObject
			});
		});
		$tw.rootWidget.addEventListener("tm-download-file",function(event) {
			self.saveWiki({
				method: "download",
				template: event.param,
				downloadType: "text/plain",
				variables: event.paramObject
			});
		});
	}
}

SaverHandler.prototype.titleSyncFilter = "$:/config/SaverFilter";
SaverHandler.prototype.titleAutoSave = "$:/config/AutoSave";
SaverHandler.prototype.titleSavedNotification = "$:/language/Notifications/Save/Done";

/*
Select the appropriate saver modules and set them up
*/
SaverHandler.prototype.initSavers = function(moduleType) {
	moduleType = moduleType || "saver";
	// Instantiate the available savers
	this.savers = [];
	var self = this;
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		if(module.canSave(self)) {
			self.savers.push(module.create(self.wiki));
		}
	});
	// Sort the savers into priority order
	this.savers.sort(function(a,b) {
		if(a.info.priority < b.info.priority) {
			return -1;
		} else {
			if(a.info.priority > b.info.priority) {
				return +1;
			} else {
				return 0;
			}
		}
	});
};

/*
Save the wiki contents. Options are:
	method: "save", "autosave" or "download"
	template: the tiddler containing the template to save
	downloadType: the content type for the saved file
*/
SaverHandler.prototype.saveWiki = function(options) {
	options = options || {};
	var self = this,
		method = options.method || "save";
	// Ignore autosave if disabled
	if(method === "autosave" && this.wiki.getTiddlerText(this.titleAutoSave,"yes") !== "yes") {
		return false;
	}
	var	variables = options.variables || {},
		template = options.template || "$:/core/save/all",
		downloadType = options.downloadType || "text/plain",
		text = this.wiki.renderTiddler(downloadType,template,options),
		callback = function(err) {
			if(err) {
				alert($tw.language.getString("Error/WhileSaving") + ":\n\n" + err);
			} else {
				// Clear the task queue if we're saving (rather than downloading)
				if(method !== "download") {
					self.numChanges = 0;
					self.updateDirtyStatus();
				}
				$tw.notifier.display(self.titleSavedNotification);
				if(options.callback) {
					options.callback();
				}
			}
		};
	// Call the highest priority saver that supports this method
	for(var t=this.savers.length-1; t>=0; t--) {
		var saver = this.savers[t];
		if(saver.info.capabilities.indexOf(method) !== -1 && saver.save(text,method,callback,{variables: {filename: variables.filename}})) {
			this.logger.log("Saving wiki with method",method,"through saver",saver.info.name);
			return true;
		}
	}
	return false;
};

/*
Checks whether the wiki is dirty (ie the window shouldn't be closed)
*/
SaverHandler.prototype.isDirty = function() {
	return this.numChanges > 0;
};

/*
Update the document body with the class "tc-dirty" if the wiki has unsaved/unsynced changes
*/
SaverHandler.prototype.updateDirtyStatus = function() {
	if($tw.browser) {
		$tw.utils.toggleClass(document.body,"tc-dirty",this.isDirty());
	}
};

exports.SaverHandler = SaverHandler;

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/andtidwiki.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/andtidwiki.js
type: application/javascript
module-type: saver

Handles saving changes via the AndTidWiki Android app

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false, netscape: false, Components: false */
"use strict";

var AndTidWiki = function(wiki) {
};

AndTidWiki.prototype.save = function(text,method,callback) {
	// Get the pathname of this document
	var pathname = decodeURIComponent(document.location.toString().split("#")[0]);
	// Strip the file://
	if(pathname.indexOf("file://") === 0) {
		pathname = pathname.substr(7);
	}
	// Strip any query or location part
	var p = pathname.indexOf("?");
	if(p !== -1) {
		pathname = pathname.substr(0,p);
	}
	p = pathname.indexOf("#");
	if(p !== -1) {
		pathname = pathname.substr(0,p);
	}
	// Save the file
	window.twi.saveFile(pathname,text);
	// Call the callback
	callback(null);
	return true;
};

/*
Information about this saver
*/
AndTidWiki.prototype.info = {
	name: "andtidwiki",
	priority: 1600,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return !!window.twi && !!window.twi.saveFile;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new AndTidWiki(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/beaker.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/beaker.js
type: application/javascript
module-type: saver

Saves files using the Beaker browser's (https://beakerbrowser.com) Dat protocol (https://datproject.org/)
Compatible with beaker >= V0.7.2

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Set up the saver
*/
var BeakerSaver = function(wiki) {
	this.wiki = wiki;
};

BeakerSaver.prototype.save = function(text,method,callback) {
	var dat = new DatArchive("" + window.location),
		pathname = ("" + window.location.pathname).split("#")[0];
	dat.stat(pathname).then(function(value) {
		if(value.isDirectory()) {
			pathname = pathname + "/index.html";
		}
		dat.writeFile(pathname,text,"utf8").then(function(value) {
			callback(null);
		},function(reason) {
			callback("Beaker Saver Write Error: " + reason);
		});
	},function(reason) {
		callback("Beaker Saver Stat Error: " + reason);
	});
	return true;
};

/*
Information about this saver
*/
BeakerSaver.prototype.info = {
	name: "beaker",
	priority: 3000,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return !!window.DatArchive && location.protocol==="dat:";
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new BeakerSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/download.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/download.js
type: application/javascript
module-type: saver

Handles saving changes via HTML5's download APIs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var DownloadSaver = function(wiki) {
};

DownloadSaver.prototype.save = function(text,method,callback,options) {
	options = options || {};
	// Get the current filename
	var filename = options.variables.filename;
	if(!filename) {
		var p = document.location.pathname.lastIndexOf("/");
		if(p !== -1) {
			// We decode the pathname because document.location is URL encoded by the browser
			filename = decodeURIComponent(document.location.pathname.substr(p+1));
		}
	}
	if(!filename) {
		filename = "tiddlywiki.html";
	}
	// Set up the link
	var link = document.createElement("a");
	if(Blob !== undefined) {
		var blob = new Blob([text], {type: "text/html"});
		link.setAttribute("href", URL.createObjectURL(blob));
	} else {
		link.setAttribute("href","data:text/html," + encodeURIComponent(text));
	}
	link.setAttribute("download",filename);
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
	// Callback that we succeeded
	callback(null);
	return true;
};

/*
Information about this saver
*/
DownloadSaver.prototype.info = {
	name: "download",
	priority: 100
};

Object.defineProperty(DownloadSaver.prototype.info, "capabilities", {
	get: function() {
		var capabilities = ["save", "download"];
		if(($tw.wiki.getTextReference("$:/config/DownloadSaver/AutoSave") || "").toLowerCase() === "yes") {
			capabilities.push("autosave");
		}
		return capabilities;
	}
});

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return document.createElement("a").download !== undefined;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new DownloadSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/fsosaver.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/fsosaver.js
type: application/javascript
module-type: saver

Handles saving changes via MS FileSystemObject ActiveXObject

Note: Since TiddlyWiki's markup contains the MOTW, the FileSystemObject normally won't be available. 
However, if the wiki is loaded as an .HTA file (Windows HTML Applications) then the FSO can be used.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var FSOSaver = function(wiki) {
};

FSOSaver.prototype.save = function(text,method,callback) {
	// Get the pathname of this document
	var pathname = unescape(document.location.pathname);
	// Test for a Windows path of the form /x:\blah...
	if(/^\/[A-Z]\:\\[^\\]+/i.test(pathname)) {	// ie: ^/[a-z]:/[^/]+
		// Remove the leading slash
		pathname = pathname.substr(1);
	} else if(document.location.hostname !== "" && /^\/\\[^\\]+\\[^\\]+/i.test(pathname)) {	// test for \\server\share\blah... - ^/[^/]+/[^/]+
		// Remove the leading slash
		pathname = pathname.substr(1);
		// reconstruct UNC path
		pathname = "\\\\" + document.location.hostname + pathname;
	} else {
		return false;
	}
	// Save the file (as UTF-16)
	var fso = new ActiveXObject("Scripting.FileSystemObject");
	var file = fso.OpenTextFile(pathname,2,-1,-1);
	file.Write(text);
	file.Close();
	// Callback that we succeeded
	callback(null);
	return true;
};

/*
Information about this saver
*/
FSOSaver.prototype.info = {
	name: "FSOSaver",
	priority: 120,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	try {
		return (window.location.protocol === "file:") && !!(new ActiveXObject("Scripting.FileSystemObject"));
	} catch(e) { return false; }
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new FSOSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/github.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/github.js
type: application/javascript
module-type: saver

Saves wiki by pushing a commit to the GitHub v3 REST API

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var GitHubSaver = function(wiki) {
	this.wiki = wiki;
};

GitHubSaver.prototype.save = function(text,method,callback) {
	var self = this,
		username = this.wiki.getTiddlerText("$:/GitHub/Username"),
		password = $tw.utils.getPassword("github"),
		repo = this.wiki.getTiddlerText("$:/GitHub/Repo"),
		path = this.wiki.getTiddlerText("$:/GitHub/Path"),
		filename = this.wiki.getTiddlerText("$:/GitHub/Filename"),
		branch = this.wiki.getTiddlerText("$:/GitHub/Branch") || "master",
		endpoint = this.wiki.getTiddlerText("$:/GitHub/ServerURL") || "https://api.github.com",
		headers = {
			"Accept": "application/vnd.github.v3+json",
			"Content-Type": "application/json;charset=UTF-8",
			"Authorization": "Basic " + window.btoa(username + ":" + password)
		};
	// Bail if we don't have everything we need
	if(!username || !password || !repo || !path || !filename) {
		return false;
	}
	// Make sure the path start and ends with a slash
	if(path.substring(0,1) !== "/") {
		path = "/" + path;
	}
	if(path.substring(path.length - 1) !== "/") {
		path = path + "/";
	}
	// Compose the base URI
	var uri = endpoint + "/repos/" + repo + "/contents" + path;
	// Perform a get request to get the details (inc shas) of files in the same path as our file
	$tw.utils.httpRequest({
		url: uri,
		type: "GET",
		headers: headers,
		data: {
			ref: branch
		},
		callback: function(err,getResponseDataJson,xhr) {
			var getResponseData,sha = "";
			if(err && xhr.status !== 404) {
				return callback(err);					
			}
			if(xhr.status !== 404) {
				getResponseData = JSON.parse(getResponseDataJson);
				$tw.utils.each(getResponseData,function(details) {
					if(details.name === filename) {
						sha = details.sha;
					}
				});				
			}
			var data = {
					message: "Saved by TiddlyWiki",
					content: $tw.utils.base64Encode(text),
					branch: branch,
					sha: sha
				};
			// Perform a PUT request to save the file
			$tw.utils.httpRequest({
				url: uri + filename,
				type: "PUT",
				headers: headers,
				data: JSON.stringify(data),
				callback: function(err,putResponseDataJson,xhr) {
					if(err) {
						return callback(err);
					}
					var putResponseData = JSON.parse(putResponseDataJson);
					callback(null);
				}
			});
		}
	});
	return true;
};

/*
Information about this saver
*/
GitHubSaver.prototype.info = {
	name: "github",
	priority: 2000,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new GitHubSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/manualdownload.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/manualdownload.js
type: application/javascript
module-type: saver

Handles saving changes via HTML5's download APIs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Title of the tiddler containing the download message
var downloadInstructionsTitle = "$:/language/Modals/Download";

/*
Select the appropriate saver module and set it up
*/
var ManualDownloadSaver = function(wiki) {
};

ManualDownloadSaver.prototype.save = function(text,method,callback) {
	$tw.modal.display(downloadInstructionsTitle,{
		downloadLink: "data:text/html," + encodeURIComponent(text)
	});
	// Callback that we succeeded
	callback(null);
	return true;
};

/*
Information about this saver
*/
ManualDownloadSaver.prototype.info = {
	name: "manualdownload",
	priority: 0,
	capabilities: ["save", "download"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new ManualDownloadSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/msdownload.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/msdownload.js
type: application/javascript
module-type: saver

Handles saving changes via window.navigator.msSaveBlob()

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var MsDownloadSaver = function(wiki) {
};

MsDownloadSaver.prototype.save = function(text,method,callback) {
	// Get the current filename
	var filename = "tiddlywiki.html",
		p = document.location.pathname.lastIndexOf("/");
	if(p !== -1) {
		filename = document.location.pathname.substr(p+1);
	}
	// Set up the link
	var blob = new Blob([text], {type: "text/html"});
	window.navigator.msSaveBlob(blob,filename);
	// Callback that we succeeded
	callback(null);
	return true;
};

/*
Information about this saver
*/
MsDownloadSaver.prototype.info = {
	name: "msdownload",
	priority: 110,
	capabilities: ["save", "download"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return !!window.navigator.msSaveBlob;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new MsDownloadSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/put.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/put.js
type: application/javascript
module-type: saver

Saves wiki by performing a PUT request to the server

Works with any server which accepts a PUT request
to the current URL, such as a WebDAV server.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Retrieve ETag if available
*/
var retrieveETag = function(self) {
	var headers = {
		Accept: "*/*;charset=UTF-8"
	};
	$tw.utils.httpRequest({
		url: self.uri(),
		type: "HEAD",
		headers: headers,
		callback: function(err,data,xhr) {
			if(err) {
				return;
			}
			var etag = xhr.getResponseHeader("ETag");
			if(!etag) {
				return;
			}
			self.etag = etag.replace(/^W\//,"");
		}
	});
};


/*
Select the appropriate saver module and set it up
*/
var PutSaver = function(wiki) {
	this.wiki = wiki;
	var self = this;
	var uri = this.uri();
	// Async server probe. Until probe finishes, save will fail fast
	// See also https://github.com/Jermolene/TiddlyWiki5/issues/2276
	$tw.utils.httpRequest({
		url: uri,
		type: "OPTIONS",
		callback: function(err,data,xhr) {
			// Check DAV header http://www.webdav.org/specs/rfc2518.html#rfc.section.9.1
			if(!err) {
				self.serverAcceptsPuts = xhr.status === 200 && !!xhr.getResponseHeader("dav");
			}
		}
	});
	retrieveETag(this);
};

PutSaver.prototype.uri = function() {
	return document.location.toString().split("#")[0];
};

// TODO: in case of edit conflict
// Prompt: Do you want to save over this? Y/N
// Merging would be ideal, and may be possible using future generic merge flow
PutSaver.prototype.save = function(text,method,callback) {
	if(!this.serverAcceptsPuts) {
		return false;
	}
	var self = this;
	var headers = {
		"Content-Type": "text/html;charset=UTF-8"
	};
	if(this.etag) {
		headers["If-Match"] = this.etag;
	}
	$tw.utils.httpRequest({
		url: this.uri(),
		type: "PUT",
		headers: headers,
		data: text,
		callback: function(err,data,xhr) {
			if(err) {
				// response is textual: "XMLHttpRequest error code: 412"
				var status = Number(err.substring(err.indexOf(':') + 2, err.length))
				if(status === 412) { // edit conflict
					var message = $tw.language.getString("Error/EditConflict");
					callback(message);
				} else {
					callback(err); // fail
				}
			} else {
				self.etag = xhr.getResponseHeader("ETag");
				if(self.etag == null) {
					retrieveETag(self);
				}
				callback(null); // success
			}
		}
	});
	return true;
};

/*
Information about this saver
*/
PutSaver.prototype.info = {
	name: "put",
	priority: 2000,
	capabilities: ["save","autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return /^https?:/.test(location.protocol);
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new PutSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/tiddlyfox.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/tiddlyfox.js
type: application/javascript
module-type: saver

Handles saving changes via the TiddlyFox file extension

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false, netscape: false, Components: false */
"use strict";

var TiddlyFoxSaver = function(wiki) {
};

TiddlyFoxSaver.prototype.save = function(text,method,callback) {
	var messageBox = document.getElementById("tiddlyfox-message-box");
	if(messageBox) {
		// Get the pathname of this document
		var pathname = document.location.toString().split("#")[0];
		// Replace file://localhost/ with file:///
		if(pathname.indexOf("file://localhost/") === 0) {
			pathname = "file://" + pathname.substr(16);
		}
		// Windows path file:///x:/blah/blah --> x:\blah\blah
		if(/^file\:\/\/\/[A-Z]\:\//i.test(pathname)) {
			// Remove the leading slash and convert slashes to backslashes
			pathname = pathname.substr(8).replace(/\//g,"\\");
		// Firefox Windows network path file://///server/share/blah/blah --> //server/share/blah/blah
		} else if(pathname.indexOf("file://///") === 0) {
			pathname = "\\\\" + unescape(pathname.substr(10)).replace(/\//g,"\\");
		// Mac/Unix local path file:///path/path --> /path/path
		} else if(pathname.indexOf("file:///") === 0) {
			pathname = unescape(pathname.substr(7));
		// Mac/Unix local path file:/path/path --> /path/path
		} else if(pathname.indexOf("file:/") === 0) {
			pathname = unescape(pathname.substr(5));
		// Otherwise Windows networth path file://server/share/path/path --> \\server\share\path\path
		} else {
			pathname = "\\\\" + unescape(pathname.substr(7)).replace(new RegExp("/","g"),"\\");
		}
		// Create the message element and put it in the message box
		var message = document.createElement("div");
		message.setAttribute("data-tiddlyfox-path",decodeURIComponent(pathname));
		message.setAttribute("data-tiddlyfox-content",text);
		messageBox.appendChild(message);
		// Add an event handler for when the file has been saved
		message.addEventListener("tiddlyfox-have-saved-file",function(event) {
			callback(null);
		}, false);
		// Create and dispatch the custom event to the extension
		var event = document.createEvent("Events");
		event.initEvent("tiddlyfox-save-file",true,false);
		message.dispatchEvent(event);
		return true;
	} else {
		return false;
	}
};

/*
Information about this saver
*/
TiddlyFoxSaver.prototype.info = {
	name: "tiddlyfox",
	priority: 1500,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new TiddlyFoxSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/tiddlyie.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/tiddlyie.js
type: application/javascript
module-type: saver

Handles saving changes via Internet Explorer BHO extenion (TiddlyIE)

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var TiddlyIESaver = function(wiki) {
};

TiddlyIESaver.prototype.save = function(text,method,callback) {
	// Check existence of TiddlyIE BHO extension (note: only works after document is complete)
	if(typeof(window.TiddlyIE) != "undefined") {
		// Get the pathname of this document
		var pathname = unescape(document.location.pathname);
		// Test for a Windows path of the form /x:/blah...
		if(/^\/[A-Z]\:\/[^\/]+/i.test(pathname)) {	// ie: ^/[a-z]:/[^/]+ (is this better?: ^/[a-z]:/[^/]+(/[^/]+)*\.[^/]+ )
			// Remove the leading slash
			pathname = pathname.substr(1);
			// Convert slashes to backslashes
			pathname = pathname.replace(/\//g,"\\");
		} else if(document.hostname !== "" && /^\/[^\/]+\/[^\/]+/i.test(pathname)) {	// test for \\server\share\blah... - ^/[^/]+/[^/]+
			// Convert slashes to backslashes
			pathname = pathname.replace(/\//g,"\\");
			// reconstruct UNC path
			pathname = "\\\\" + document.location.hostname + pathname;
		} else return false;
		// Prompt the user to save the file
		window.TiddlyIE.save(pathname, text);
		// Callback that we succeeded
		callback(null);
		return true;
	} else {
		return false;
	}
};

/*
Information about this saver
*/
TiddlyIESaver.prototype.info = {
	name: "tiddlyiesaver",
	priority: 1500,
	capabilities: ["save"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return (window.location.protocol === "file:");
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new TiddlyIESaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/twedit.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/twedit.js
type: application/javascript
module-type: saver

Handles saving changes via the TWEdit iOS app

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false, netscape: false, Components: false */
"use strict";

var TWEditSaver = function(wiki) {
};

TWEditSaver.prototype.save = function(text,method,callback) {
	// Bail if we're not running under TWEdit
	if(typeof DeviceInfo !== "object") {
		return false;
	}
	// Get the pathname of this document
	var pathname = decodeURIComponent(document.location.pathname);
	// Strip any query or location part
	var p = pathname.indexOf("?");
	if(p !== -1) {
		pathname = pathname.substr(0,p);
	}
	p = pathname.indexOf("#");
	if(p !== -1) {
		pathname = pathname.substr(0,p);
	}
	// Remove the leading "/Documents" from path
	var prefix = "/Documents";
	if(pathname.indexOf(prefix) === 0) {
		pathname = pathname.substr(prefix.length);
	}
	// Error handler
	var errorHandler = function(event) {
		// Error
		callback($tw.language.getString("Error/SavingToTWEdit") + ": " + event.target.error.code);
	};
	// Get the file system
	window.requestFileSystem(LocalFileSystem.PERSISTENT,0,function(fileSystem) {
		// Now we've got the filesystem, get the fileEntry
		fileSystem.root.getFile(pathname, {create: true}, function(fileEntry) {
			// Now we've got the fileEntry, create the writer
			fileEntry.createWriter(function(writer) {
				writer.onerror = errorHandler;
				writer.onwrite = function() {
					callback(null);
				};
				writer.position = 0;
				writer.write(text);
			},errorHandler);
		}, errorHandler);
	}, errorHandler);
	return true;
};

/*
Information about this saver
*/
TWEditSaver.prototype.info = {
	name: "twedit",
	priority: 1600,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new TWEditSaver(wiki);
};

/////////////////////////// Hack
// HACK: This ensures that TWEdit recognises us as a TiddlyWiki document
if($tw.browser) {
	window.version = {title: "TiddlyWiki"};
}

})();

;})();
return exports;
}));
_define("$:/core/modules/savers/upload.js","saver",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/savers/upload.js
type: application/javascript
module-type: saver

Handles saving changes via upload to a server.

Designed to be compatible with BidiX's UploadPlugin at http://tiddlywiki.bidix.info/#UploadPlugin

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var UploadSaver = function(wiki) {
	this.wiki = wiki;
};

UploadSaver.prototype.save = function(text,method,callback) {
	// Get the various parameters we need
	var backupDir = this.wiki.getTextReference("$:/UploadBackupDir") || ".",
		username = this.wiki.getTextReference("$:/UploadName"),
		password = $tw.utils.getPassword("upload"),
		uploadDir = this.wiki.getTextReference("$:/UploadDir") || ".",
		uploadFilename = this.wiki.getTextReference("$:/UploadFilename") || "index.html",
		url = this.wiki.getTextReference("$:/UploadURL");
	// Bail out if we don't have the bits we need
	if(!username || username.toString().trim() === "" || !password || password.toString().trim() === "") {
		return false;
	}
	// Construct the url if not provided
	if(!url) {
		url = "http://" + username + ".tiddlyspot.com/store.cgi";
	}
	// Assemble the header
	var boundary = "---------------------------" + "AaB03x";	
	var uploadFormName = "UploadPlugin";
	var head = [];
	head.push("--" + boundary + "\r\nContent-disposition: form-data; name=\"UploadPlugin\"\r\n");
	head.push("backupDir=" + backupDir + ";user=" + username + ";password=" + password + ";uploaddir=" + uploadDir + ";;"); 
	head.push("\r\n" + "--" + boundary);
	head.push("Content-disposition: form-data; name=\"userfile\"; filename=\"" + uploadFilename + "\"");
	head.push("Content-Type: text/html;charset=UTF-8");
	head.push("Content-Length: " + text.length + "\r\n");
	head.push("");
	// Assemble the tail and the data itself
	var tail = "\r\n--" + boundary + "--\r\n",
		data = head.join("\r\n") + text + tail;
	// Do the HTTP post
	var http = new XMLHttpRequest();
	http.open("POST",url,true,username,password);
	http.setRequestHeader("Content-Type","multipart/form-data; charset=UTF-8; boundary=" + boundary);
	http.onreadystatechange = function() {
		if(http.readyState == 4 && http.status == 200) {
			if(http.responseText.substr(0,4) === "0 - ") {
				callback(null);
			} else {
				callback(http.responseText);
			}
		}
	};
	try {
		http.send(data);
	} catch(ex) {
		return callback($tw.language.getString("Error/Caption") + ":" + ex);
	}
	$tw.notifier.display("$:/language/Notifications/Save/Starting");
	return true;
};

/*
Information about this saver
*/
UploadSaver.prototype.info = {
	name: "upload",
	priority: 2000,
	capabilities: ["save", "autosave"]
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new UploadSaver(wiki);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/server/authenticators/basic.js","authenticator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/authenticators/basic.js
type: application/javascript
module-type: authenticator

Authenticator for WWW basic authentication

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

if($tw.node) {
	var util = require("util"),
		fs = require("fs"),
		url = require("url"),
		path = require("path");
}

function BasicAuthenticator(server) {
	this.server = server;
	this.credentialsData = [];
}

/*
Returns true if the authenticator is active, false if it is inactive, or a string if there is an error
*/
BasicAuthenticator.prototype.init = function() {
	// Read the credentials data
	this.credentialsFilepath = this.server.get("credentials");
	if(this.credentialsFilepath) {
		var resolveCredentialsFilepath = path.resolve($tw.boot.wikiPath,this.credentialsFilepath);
		if(fs.existsSync(resolveCredentialsFilepath) && !fs.statSync(resolveCredentialsFilepath).isDirectory()) {
			var credentialsText = fs.readFileSync(resolveCredentialsFilepath,"utf8"),
				credentialsData = $tw.utils.parseCsvStringWithHeader(credentialsText);
			if(typeof credentialsData === "string") {
				return "Error: " + credentialsData + " reading credentials from '" + resolveCredentialsFilepath + "'";
			} else {
				this.credentialsData = credentialsData;
			}
		} else {
			return "Error: Unable to load user credentials from '" + resolveCredentialsFilepath + "'";
		}
	}
	// Add the hardcoded username and password if specified
	if(this.server.get("username") && this.server.get("password")) {
		this.credentialsData = this.credentialsData || [];
		this.credentialsData.push({
			username: this.server.get("username"),
			password: this.server.get("password")
		});
	}
	return this.credentialsData.length > 0;
};

/*
Returns true if the request is authenticated and assigns the "authenticatedUsername" state variable.
Returns false if the request couldn't be authenticated having sent an appropriate response to the browser
*/
BasicAuthenticator.prototype.authenticateRequest = function(request,response,state) {
	// Extract the incoming username and password from the request
	var header = request.headers.authorization || "";
	if(!header && state.allowAnon) {
		// If there's no header and anonymous access is allowed then we don't set authenticatedUsername
		return true;
	}
	var token = header.split(/\s+/).pop() || "",
		auth = $tw.utils.base64Decode(token),
		parts = auth.split(/:/),
		incomingUsername = parts[0],
		incomingPassword = parts[1];
	// Check that at least one of the credentials matches
	var matchingCredentials = this.credentialsData.find(function(credential) {
		return credential.username === incomingUsername && credential.password === incomingPassword;
	});
	if(matchingCredentials) {
		// If so, add the authenticated username to the request state
		state.authenticatedUsername = incomingUsername;
		return true;
	} else {
		// If not, return an authentication challenge
		response.writeHead(401,"Authentication required",{
			"WWW-Authenticate": 'Basic realm="Please provide your username and password to login to ' + state.server.servername + '"'
		});
		response.end();
		return false;
	}
};

exports.AuthenticatorClass = BasicAuthenticator;

})();

;})();
return exports;
}));
_define("$:/core/modules/server/authenticators/header.js","authenticator",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/authenticators/header.js
type: application/javascript
module-type: authenticator

Authenticator for trusted header authentication

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

function HeaderAuthenticator(server) {
	this.server = server;
	this.header = server.get("authenticated-user-header");
}

/*
Returns true if the authenticator is active, false if it is inactive, or a string if there is an error
*/
HeaderAuthenticator.prototype.init = function() {
	return !!this.header;
};

/*
Returns true if the request is authenticated and assigns the "authenticatedUsername" state variable.
Returns false if the request couldn't be authenticated having sent an appropriate response to the browser
*/
HeaderAuthenticator.prototype.authenticateRequest = function(request,response,state) {
	// Otherwise, authenticate as the username in the specified header
	var username = request.headers[this.header];
	if(!username && !state.allowAnon) {
		response.writeHead(401,"Authorization header required to login to '" + state.server.servername + "'");
		response.end();
		return false;
	} else {
		// authenticatedUsername will be undefined for anonymous users
		state.authenticatedUsername = username;
		return true;
	}
};

exports.AuthenticatorClass = HeaderAuthenticator;

})();

;})();
return exports;
}));
_define("$:/core/modules/server/routes/delete-tiddler.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/delete-tiddler.js
type: application/javascript
module-type: route

DELETE /recipes/default/tiddlers/:title

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "DELETE";

exports.path = /^\/bags\/default\/tiddlers\/(.+)$/;

exports.handler = function(request,response,state) {
	var title = decodeURIComponent(state.params[0]);
	state.wiki.deleteTiddler(title);
	response.writeHead(204, "OK", {
		"Content-Type": "text/plain"
	});
	response.end();
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-favicon.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-favicon.js
type: application/javascript
module-type: route

GET /favicon.ico

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/favicon.ico$/;

exports.handler = function(request,response,state) {
	response.writeHead(200, {"Content-Type": "image/x-icon"});
	var buffer = state.wiki.getTiddlerText("$:/favicon.ico","");
	response.end(buffer,"base64");
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-file.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-file.js
type: application/javascript
module-type: route

GET /files/:filepath

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/files\/(.+)$/;

exports.handler = function(request,response,state) {
	var path = require("path"),
		fs = require("fs"),
		util = require("util");
	var filename = path.resolve($tw.boot.wikiPath,"files",decodeURIComponent(state.params[0])),
		extension = path.extname(filename);
	fs.readFile(filename,function(err,content) {
		var status,content,type = "text/plain";
		if(err) {
			if(err.code === "ENOENT") {
				status = 404;
				content = "File '" + filename + "' not found";
			} else if(err.code === "EACCES") {
				status = 403;
				content = "You do not have permission to access the file '" + filename + "'";
			} else {
				status = 500;
				content = err.toString();
			}
		} else {
			status = 200;
			content = content;
			type = ($tw.config.fileExtensionInfo[extension] ? $tw.config.fileExtensionInfo[extension].type : "application/octet-stream");
		}
		response.writeHead(status,{
			"Content-Type": type
		});
		response.end(content);
	});
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-index.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-index.js
type: application/javascript
module-type: route

GET /

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var zlib = require('zlib');

exports.method = "GET";

exports.path = /^\/$/;

exports.handler = function(request,response,state) {
	var acceptEncoding = request.headers['accept-encoding'];
	if (!acceptEncoding) { acceptEncoding = ''; }

	var text = state.wiki.renderTiddler(state.server.get("root-render-type"),state.server.get("root-tiddler"));

	var responseHeaders = {
		"Content-Type": state.server.get("root-serve-type")
	};

	/*
	If the gzip=yes flag for `listen` is set, check if the user agent permits
	compression. If so, compress our response. Note that we use the synchronous
	functions from zlib to stay in the imperative style. The current `Server`
	doesn't depend on this, and we may just as well use the async versions.
	*/
	if(state.server.enableGzip) {
		if (/\bdeflate\b/.test(acceptEncoding)) {
			responseHeaders['Content-Encoding'] = 'deflate';
			text = zlib.deflateSync(text);
		} else if (/\bgzip\b/.test(acceptEncoding)) {
			responseHeaders['Content-Encoding'] = 'gzip';
			text = zlib.gzipSync(text);
		}
	}

	response.writeHead(200, responseHeaders);
	response.end(text);
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-login-basic.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-login-basic.js
type: application/javascript
module-type: route

GET /login-basic -- force a Basic Authentication challenge

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/login-basic$/;

exports.handler = function(request,response,state) {
	if(!state.authenticatedUsername) {
		// Challenge if there's no username
		response.writeHead(401,{
			"WWW-Authenticate": 'Basic realm="Please provide your username and password to login to ' + state.server.servername + '"'
		});
		response.end();		
	} else {
		// Redirect to the root wiki if login worked
		response.writeHead(302,{
			Location: "/"
		});
		response.end();
	}
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-status.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-status.js
type: application/javascript
module-type: route

GET /status

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/status$/;

exports.handler = function(request,response,state) {
	response.writeHead(200, {"Content-Type": "application/json"});
	var text = JSON.stringify({
		username: state.authenticatedUsername || state.server.get("anon-username") || "",
		anonymous: !state.authenticatedUsername,
		read_only: !state.server.isAuthorized("writers",state.authenticatedUsername),
		space: {
			recipe: "default"
		},
		tiddlywiki_version: $tw.version
	});
	response.end(text,"utf8");
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-tiddler-html.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-tiddler-html.js
type: application/javascript
module-type: route

GET /:title

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/([^\/]+)$/;

exports.handler = function(request,response,state) {
	var title = decodeURIComponent(state.params[0]),
		tiddler = state.wiki.getTiddler(title);
	if(tiddler) {
		var renderType = tiddler.getFieldString("_render_type"),
			renderTemplate = tiddler.getFieldString("_render_template");
		// Tiddler fields '_render_type' and '_render_template' overwrite
		// system wide settings for render type and template
		if(state.wiki.isSystemTiddler(title)) {
			renderType = renderType || state.server.get("system-tiddler-render-type");
			renderTemplate = renderTemplate || state.server.get("system-tiddler-render-template");
		} else {
			renderType = renderType || state.server.get("tiddler-render-type");
			renderTemplate = renderTemplate || state.server.get("tiddler-render-template");
		}
		var text = state.wiki.renderTiddler(renderType,renderTemplate,{parseAsInline: true, variables: {currentTiddler: title}});
		// Naughty not to set a content-type, but it's the easiest way to ensure the browser will see HTML pages as HTML, and accept plain text tiddlers as CSS or JS
		response.writeHead(200);
		response.end(text,"utf8");
	} else {
		response.writeHead(404);
		response.end();
	}
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-tiddler.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-tiddler.js
type: application/javascript
module-type: route

GET /recipes/default/tiddlers/:title

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/recipes\/default\/tiddlers\/(.+)$/;

exports.handler = function(request,response,state) {
	var title = decodeURIComponent(state.params[0]),
		tiddler = state.wiki.getTiddler(title),
		tiddlerFields = {},
		knownFields = [
			"bag", "created", "creator", "modified", "modifier", "permissions", "recipe", "revision", "tags", "text", "title", "type", "uri"
		];
	if(tiddler) {
		$tw.utils.each(tiddler.fields,function(field,name) {
			var value = tiddler.getFieldString(name);
			if(knownFields.indexOf(name) !== -1) {
				tiddlerFields[name] = value;
			} else {
				tiddlerFields.fields = tiddlerFields.fields || {};
				tiddlerFields.fields[name] = value;
			}
		});
		tiddlerFields.revision = state.wiki.getChangeCount(title);
		tiddlerFields.type = tiddlerFields.type || "text/vnd.tiddlywiki";
		response.writeHead(200, {"Content-Type": "application/json"});
		response.end(JSON.stringify(tiddlerFields),"utf8");
	} else {
		response.writeHead(404);
		response.end();
	}
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/get-tiddlers-json.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/get-tiddlers-json.js
type: application/javascript
module-type: route

GET /recipes/default/tiddlers/tiddlers.json

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "GET";

exports.path = /^\/recipes\/default\/tiddlers.json$/;

exports.handler = function(request,response,state) {
	response.writeHead(200, {"Content-Type": "application/json"});
	var tiddlers = [];
	state.wiki.forEachTiddler({sortField: "title"},function(title,tiddler) {
		var tiddlerFields = {};
		$tw.utils.each(tiddler.fields,function(field,name) {
			if(name !== "text") {
				tiddlerFields[name] = tiddler.getFieldString(name);
			}
		});
		tiddlerFields.revision = state.wiki.getChangeCount(title);
		tiddlerFields.type = tiddlerFields.type || "text/vnd.tiddlywiki";
		tiddlers.push(tiddlerFields);
	});
	var text = JSON.stringify(tiddlers);
	response.end(text,"utf8");
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/routes/put-tiddler.js","route",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/routes/put-tiddler.js
type: application/javascript
module-type: route

PUT /recipes/default/tiddlers/:title

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.method = "PUT";

exports.path = /^\/recipes\/default\/tiddlers\/(.+)$/;

exports.handler = function(request,response,state) {
	var title = decodeURIComponent(state.params[0]),
	fields = JSON.parse(state.data);
	// Pull up any subfields in the `fields` object
	if(fields.fields) {
		$tw.utils.each(fields.fields,function(field,name) {
			fields[name] = field;
		});
		delete fields.fields;
	}
	// Remove any revision field
	if(fields.revision) {
		delete fields.revision;
	}
	state.wiki.addTiddler(new $tw.Tiddler(state.wiki.getCreationFields(),fields,{title: title},state.wiki.getModificationFields()));
	var changeCount = state.wiki.getChangeCount(title).toString();
	response.writeHead(204, "OK",{
		Etag: "\"default/" + encodeURIComponent(title) + "/" + changeCount + ":\"",
		"Content-Type": "text/plain"
	});
	response.end();
};

}());

;})();
return exports;
}));
_define("$:/core/modules/server/server.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/server/server.js
type: application/javascript
module-type: library

Serve tiddlers over http

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

if($tw.node) {
	var util = require("util"),
		fs = require("fs"),
		url = require("url"),
		path = require("path");
}

/*
A simple HTTP server with regexp-based routes
options: variables - optional hashmap of variables to set (a misnomer - they are really constant parameters)
		 routes - optional array of routes to use
		 wiki - reference to wiki object
*/
function Server(options) {
	var self = this;
	this.routes = options.routes || [];
	this.authenticators = options.authenticators || [];
	this.wiki = options.wiki;
	this.servername = $tw.utils.transliterateToSafeASCII(this.wiki.getTiddlerText("$:/SiteTitle") || "TiddlyWiki5");
	// Initialise the variables
	this.variables = $tw.utils.extend({},this.defaultVariables);
	if(options.variables) {
		for(var variable in options.variables) {
			if(options.variables[variable]) {
				this.variables[variable] = options.variables[variable];
			}
		}		
	}
	$tw.utils.extend({},this.defaultVariables,options.variables);
	// Initialise CSRF
	this.csrfDisable = this.get("csrf-disable") === "yes";
	// Initialize Gzip compression
	this.enableGzip = this.get("gzip") === "yes";
	// Initialise authorization
	var authorizedUserName = (this.get("username") && this.get("password")) ? this.get("username") : "(anon)";
	this.authorizationPrincipals = {
		readers: (this.get("readers") || authorizedUserName).split(",").map($tw.utils.trim),
		writers: (this.get("writers") || authorizedUserName).split(",").map($tw.utils.trim)
	}
	// Load and initialise authenticators
	$tw.modules.forEachModuleOfType("authenticator", function(title,authenticatorDefinition) {
		// console.log("Loading server route " + title);
		self.addAuthenticator(authenticatorDefinition.AuthenticatorClass);
	});
	// Load route handlers
	$tw.modules.forEachModuleOfType("route", function(title,routeDefinition) {
		// console.log("Loading server route " + title);
		self.addRoute(routeDefinition);
	});
	// Initialise the http vs https
	this.listenOptions = null;
	this.protocol = "http";
	var tlsKeyFilepath = this.get("tls-key"),
		tlsCertFilepath = this.get("tls-cert");
	if(tlsCertFilepath && tlsKeyFilepath) {
		this.listenOptions = {
			key: fs.readFileSync(path.resolve($tw.boot.wikiPath,tlsKeyFilepath),"utf8"),
			cert: fs.readFileSync(path.resolve($tw.boot.wikiPath,tlsCertFilepath),"utf8")
		};
		this.protocol = "https";
	}
	this.transport = require(this.protocol);
}

Server.prototype.defaultVariables = {
	port: "8080",
	host: "127.0.0.1",
	"root-tiddler": "$:/core/save/all",
	"root-render-type": "text/plain",
	"root-serve-type": "text/html",
	"tiddler-render-type": "text/html",
	"tiddler-render-template": "$:/core/templates/server/static.tiddler.html",
	"system-tiddler-render-type": "text/plain",
	"system-tiddler-render-template": "$:/core/templates/wikified-tiddler",
	"debug-level": "none",
	"gzip": "no"
};

Server.prototype.get = function(name) {
	return this.variables[name];
};

Server.prototype.addRoute = function(route) {
	this.routes.push(route);
};

Server.prototype.addAuthenticator = function(AuthenticatorClass) {
	// Instantiate and initialise the authenticator
	var authenticator = new AuthenticatorClass(this),
		result = authenticator.init();
	if(typeof result === "string") {
		$tw.utils.error("Error: " + result);
	} else if(result) {
		// Only use the authenticator if it initialised successfully
		this.authenticators.push(authenticator);
	}
};

Server.prototype.findMatchingRoute = function(request,state) {
	var pathprefix = this.get("path-prefix") || "";
	for(var t=0; t<this.routes.length; t++) {
		var potentialRoute = this.routes[t],
			pathRegExp = potentialRoute.path,
			pathname = state.urlInfo.pathname,
			match;
		if(pathprefix) {
			if(pathname.substr(0,pathprefix.length) === pathprefix) {
				pathname = pathname.substr(pathprefix.length) || "/";
				match = potentialRoute.path.exec(pathname);
			} else {
				match = false;
			}
		} else {
			match = potentialRoute.path.exec(pathname);
		}
		if(match && request.method === potentialRoute.method) {
			state.params = [];
			for(var p=1; p<match.length; p++) {
				state.params.push(match[p]);
			}
			return potentialRoute;
		}
	}
	return null;
};

Server.prototype.methodMappings = {
	"GET": "readers",
	"OPTIONS": "readers",
	"HEAD": "readers",
	"PUT": "writers",
	"POST": "writers",
	"DELETE": "writers"
};

/*
Check whether a given user is authorized for the specified authorizationType ("readers" or "writers"). Pass null or undefined as the username to check for anonymous access
*/
Server.prototype.isAuthorized = function(authorizationType,username) {
	var principals = this.authorizationPrincipals[authorizationType] || [];
	return principals.indexOf("(anon)") !== -1 || (username && (principals.indexOf("(authenticated)") !== -1 || principals.indexOf(username) !== -1));
}

Server.prototype.requestHandler = function(request,response) {
	// Compose the state object
	var self = this;
	var state = {};
	state.wiki = self.wiki;
	state.server = self;
	state.urlInfo = url.parse(request.url);
	// Get the principals authorized to access this resource
	var authorizationType = this.methodMappings[request.method] || "readers";
	// Check for the CSRF header if this is a write
	if(!this.csrfDisable && authorizationType === "writers" && request.headers["x-requested-with"] !== "TiddlyWiki") {
		response.writeHead(403,"'X-Requested-With' header required to login to '" + this.servername + "'");
		response.end();
		return;		
	}
	// Check whether anonymous access is granted
	state.allowAnon = this.isAuthorized(authorizationType,null);
	// Authenticate with the first active authenticator
	if(this.authenticators.length > 0) {
		if(!this.authenticators[0].authenticateRequest(request,response,state)) {
			// Bail if we failed (the authenticator will have sent the response)
			return;
		}		
	}
	// Authorize with the authenticated username
	if(!this.isAuthorized(authorizationType,state.authenticatedUsername)) {
		response.writeHead(401,"'" + state.authenticatedUsername + "' is not authorized to access '" + this.servername + "'");
		response.end();
		return;
	}
	// Find the route that matches this path
	var route = self.findMatchingRoute(request,state);
	// Optionally output debug info
	if(self.get("debug-level") !== "none") {
		console.log("Request path:",JSON.stringify(state.urlInfo));
		console.log("Request headers:",JSON.stringify(request.headers));
		console.log("authenticatedUsername:",state.authenticatedUsername);
	}
	// Return a 404 if we didn't find a route
	if(!route) {
		response.writeHead(404);
		response.end();
		return;
	}
	// Receive the request body if necessary and hand off to the route handler
	if(route.bodyFormat === "stream" || request.method === "GET" || request.method === "HEAD") {
		// Let the route handle the request stream itself
		route.handler(request,response,state);
	} else if(route.bodyFormat === "string" || !route.bodyFormat) {
		// Set the encoding for the incoming request
		request.setEncoding("utf8");
		var data = "";
		request.on("data",function(chunk) {
			data += chunk.toString();
		});
		request.on("end",function() {
			state.data = data;
			route.handler(request,response,state);
		});
	} else if(route.bodyFormat === "buffer") {
		var data = [];
		request.on("data",function(chunk) {
			data.push(chunk);
		});
		request.on("end",function() {
			state.data = Buffer.concat(data);
			route.handler(request,response,state);
		})
	} else {
		response.writeHead(400,"Invalid bodyFormat " + route.bodyFormat + " in route " + route.method + " " + route.path.source);
		response.end();
	}
};

/*
Listen for requests
port: optional port number (falls back to value of "port" variable)
host: optional host address (falls back to value of "host" variable)
prefix: optional prefix (falls back to value of "path-prefix" variable)
*/
Server.prototype.listen = function(port,host,prefix) {
	// Handle defaults for port and host
	port = port || this.get("port");
	host = host || this.get("host");
	prefix = prefix || this.get("path-prefix") || "";
	// Check for the port being a string and look it up as an environment variable
	if(parseInt(port,10).toString() !== port) {
		port = process.env[port] || 8080;
	}
	$tw.utils.log("Serving on " + this.protocol + "://" + host + ":" + port + prefix,"brown/orange");
	$tw.utils.log("(press ctrl-C to exit)","red");
	// Warn if required plugins are missing
	if(!$tw.wiki.getTiddler("$:/plugins/tiddlywiki/tiddlyweb") || !$tw.wiki.getTiddler("$:/plugins/tiddlywiki/filesystem")) {
		$tw.utils.warning("Warning: Plugins required for client-server operation (\"tiddlywiki/filesystem\" and \"tiddlywiki/tiddlyweb\") are missing from tiddlywiki.info file");
	}
	// Listen
	var server;
	if(this.listenOptions) {
		server = this.transport.createServer(this.listenOptions,this.requestHandler.bind(this));
	} else {
		server = this.transport.createServer(this.requestHandler.bind(this));
	}
	return server.listen(port,host);
};

exports.Server = Server;

})();

;})();
return exports;
}));
_define("$:/core/modules/browser-messaging.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/browser-messaging.js
type: application/javascript
module-type: startup

Browser message handling

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "browser-messaging";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;

/*
Load a specified url as an iframe and call the callback when it is loaded. If the url is already loaded then the existing iframe instance is used
*/
function loadIFrame(url,callback) {
	// Check if iframe already exists
	var iframeInfo = $tw.browserMessaging.iframeInfoMap[url];
	if(iframeInfo) {
		// We've already got the iframe
		callback(null,iframeInfo);
	} else {
		// Create the iframe and save it in the list
		var iframe = document.createElement("iframe");
		iframeInfo = {
			url: url,
			status: "loading",
			domNode: iframe
		};
		$tw.browserMessaging.iframeInfoMap[url] = iframeInfo;
		saveIFrameInfoTiddler(iframeInfo);
		// Add the iframe to the DOM and hide it
		iframe.style.display = "none";
		iframe.setAttribute("library","true");
		document.body.appendChild(iframe);
		// Set up onload
		iframe.onload = function() {
			iframeInfo.status = "loaded";
			saveIFrameInfoTiddler(iframeInfo);
			callback(null,iframeInfo);
		};
		iframe.onerror = function() {
			callback("Cannot load iframe");
		};
		try {
			iframe.src = url;
		} catch(ex) {
			callback(ex);
		}
	}
}

/*
Unload library iframe for given url
*/
function unloadIFrame(url){
	$tw.utils.each(document.getElementsByTagName('iframe'), function(iframe) {
		if(iframe.getAttribute("library") === "true" &&
		  iframe.getAttribute("src") === url) {
			iframe.parentNode.removeChild(iframe);
		}
	});
}

function saveIFrameInfoTiddler(iframeInfo) {
	$tw.wiki.addTiddler(new $tw.Tiddler($tw.wiki.getCreationFields(),{
		title: "$:/temp/ServerConnection/" + iframeInfo.url,
		text: iframeInfo.status,
		tags: ["$:/tags/ServerConnection"],
		url: iframeInfo.url
	},$tw.wiki.getModificationFields()));
}

exports.startup = function() {
	// Initialise the store of iframes we've created
	$tw.browserMessaging = {
		iframeInfoMap: {} // Hashmap by URL of {url:,status:"loading/loaded",domNode:}
	};
	// Listen for widget messages to control loading the plugin library
	$tw.rootWidget.addEventListener("tm-load-plugin-library",function(event) {
		var paramObject = event.paramObject || {},
			url = paramObject.url;
		if(url) {
			loadIFrame(url,function(err,iframeInfo) {
				if(err) {
					alert($tw.language.getString("Error/LoadingPluginLibrary") + ": " + url);
				} else {
					iframeInfo.domNode.contentWindow.postMessage({
						verb: "GET",
						url: "recipes/library/tiddlers.json",
						cookies: {
							type: "save-info",
							infoTitlePrefix: paramObject.infoTitlePrefix || "$:/temp/RemoteAssetInfo/",
							url: url
						}
					},"*");
				}
			});
		}
	});
	// Listen for widget messages to control unloading the plugin library
	$tw.rootWidget.addEventListener("tm-unload-plugin-library",function(event) {
		var paramObject = event.paramObject || {},
			url = paramObject.url;
		$tw.browserMessaging.iframeInfoMap[url] = undefined;
		if(url) {
			unloadIFrame(url);
			$tw.utils.each(
				$tw.wiki.filterTiddlers("[[$:/temp/ServerConnection/" + url + "]] [prefix[$:/temp/RemoteAssetInfo/" + url + "/]]"),
				function(title) {
					$tw.wiki.deleteTiddler(title);
				}
			);
		}
	});
	$tw.rootWidget.addEventListener("tm-load-plugin-from-library",function(event) {
		var paramObject = event.paramObject || {},
			url = paramObject.url,
			title = paramObject.title;
		if(url && title) {
			loadIFrame(url,function(err,iframeInfo) {
				if(err) {
					alert($tw.language.getString("Error/LoadingPluginLibrary") + ": " + url);
				} else {
					iframeInfo.domNode.contentWindow.postMessage({
						verb: "GET",
						url: "recipes/library/tiddlers/" + encodeURIComponent(title) + ".json",
						cookies: {
							type: "save-tiddler",
							url: url
						}
					},"*");
				}
			});
		}
	});
	// Listen for window messages from other windows
	window.addEventListener("message",function listener(event){
		// console.log("browser-messaging: ",document.location.toString())
		// console.log("browser-messaging: Received message from",event.origin);
		// console.log("browser-messaging: Message content",event.data);
		switch(event.data.verb) {
			case "GET-RESPONSE":
				if(event.data.status.charAt(0) === "2") {
					if(event.data.cookies) {
						if(event.data.cookies.type === "save-info") {
							var tiddlers = JSON.parse(event.data.body);
							$tw.utils.each(tiddlers,function(tiddler) {
								$tw.wiki.addTiddler(new $tw.Tiddler($tw.wiki.getCreationFields(),tiddler,{
									title: event.data.cookies.infoTitlePrefix + event.data.cookies.url + "/" + tiddler.title,
									"original-title": tiddler.title,
									text: "",
									type: "text/vnd.tiddlywiki",
									"original-type": tiddler.type,
									"plugin-type": undefined,
									"original-plugin-type": tiddler["plugin-type"],
									"module-type": undefined,
									"original-module-type": tiddler["module-type"],
									tags: ["$:/tags/RemoteAssetInfo"],
									"original-tags": $tw.utils.stringifyList(tiddler.tags || []),
									"server-url": event.data.cookies.url
								},$tw.wiki.getModificationFields()));
							});
						} else if(event.data.cookies.type === "save-tiddler") {
							var tiddler = JSON.parse(event.data.body);
							$tw.wiki.addTiddler(new $tw.Tiddler(tiddler));
						}
					}
				}
				break;
		}
	},false);
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/commands.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/commands.js
type: application/javascript
module-type: startup

Command processing

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "commands";
exports.platforms = ["node"];
exports.after = ["story"];
exports.synchronous = false;

exports.startup = function(callback) {
	// On the server, start a commander with the command line arguments
	var commander = new $tw.Commander(
		$tw.boot.argv,
		function(err) {
			if(err) {
				return $tw.utils.error("Error: " + err);
			}
			callback();
		},
		$tw.wiki,
		{output: process.stdout, error: process.stderr}
	);
	commander.execute();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/CSSescape.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/CSSescape.js
type: application/javascript
module-type: startup

Polyfill for CSS.escape()

\*/
(function(root,factory){
/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "css-escape";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;

/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
// https://github.com/umdjs/umd/blob/master/returnExports.js
exports.startup = factory(root);
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;

}));

;})();
return exports;
}));
_define("$:/core/modules/startup/favicon.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/favicon.js
type: application/javascript
module-type: startup

Favicon handling

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "favicon";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;
		
// Favicon tiddler
var FAVICON_TITLE = "$:/favicon.ico";

exports.startup = function() {
	// Set up the favicon
	setFavicon();
	// Reset the favicon when the tiddler changes
	$tw.wiki.addEventListener("change",function(changes) {
		if($tw.utils.hop(changes,FAVICON_TITLE)) {
			setFavicon();
		}
	});
};

function setFavicon() {
	var tiddler = $tw.wiki.getTiddler(FAVICON_TITLE);
	if(tiddler) {
		var faviconLink = document.getElementById("faviconLink");
		faviconLink.setAttribute("href","data:" + tiddler.fields.type + ";base64," + tiddler.fields.text);
	}
}

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/info.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/info.js
type: application/javascript
module-type: startup

Initialise $:/info tiddlers via $:/temp/info-plugin pseudo-plugin

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "info";
exports.before = ["startup"];
exports.after = ["load-modules"];
exports.synchronous = true;

exports.startup = function() {
	// Collect up the info tiddlers
	var infoTiddlerFields = {};
	// Give each info module a chance to fill in as many info tiddlers as they want
	$tw.modules.forEachModuleOfType("info",function(title,moduleExports) {
		if(moduleExports && moduleExports.getInfoTiddlerFields) {
			var tiddlerFieldsArray = moduleExports.getInfoTiddlerFields(infoTiddlerFields);
			$tw.utils.each(tiddlerFieldsArray,function(fields) {
				if(fields) {
					infoTiddlerFields[fields.title] = fields;
				}
			});
		}
	});
	// Bake the info tiddlers into a plugin
	var fields = {
		title: "$:/temp/info-plugin",
		type: "application/json",
		"plugin-type": "info",
		text: JSON.stringify({tiddlers: infoTiddlerFields},null,$tw.config.preferences.jsonSpaces)
	};
	$tw.wiki.addTiddler(new $tw.Tiddler(fields));
	$tw.wiki.readPluginInfo();
	$tw.wiki.registerPluginTiddlers("info");
	$tw.wiki.unpackPluginTiddlers();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/load-modules.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/load-modules.js
type: application/javascript
module-type: startup

Load core modules

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "load-modules";
exports.synchronous = true;

exports.startup = function() {
	// Load modules
	$tw.modules.applyMethods("utils",$tw.utils);
	if($tw.node) {
		$tw.modules.applyMethods("utils-node",$tw.utils);
	}
	$tw.modules.applyMethods("global",$tw);
	$tw.modules.applyMethods("config",$tw.config);
	$tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap("tiddlerfield");
	$tw.modules.applyMethods("tiddlermethod",$tw.Tiddler.prototype);
	$tw.modules.applyMethods("wikimethod",$tw.Wiki.prototype);
	$tw.wiki.addIndexersToWiki();
	$tw.modules.applyMethods("tiddlerdeserializer",$tw.Wiki.tiddlerDeserializerModules);
	$tw.macros = $tw.modules.getModulesByTypeAsHashmap("macro");
	$tw.wiki.initParsers();
	$tw.Commander.initCommands();
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/password.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/password.js
type: application/javascript
module-type: startup

Password handling

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "password";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;

exports.startup = function() {
	$tw.rootWidget.addEventListener("tm-set-password",function(event) {
		$tw.passwordPrompt.createPrompt({
			serviceName: $tw.language.getString("Encryption/PromptSetPassword"),
			noUserName: true,
			submitText: $tw.language.getString("Encryption/SetPassword"),
			canCancel: true,
			repeatPassword: true,
			callback: function(data) {
				if(data) {
					$tw.crypto.setPassword(data.password);
				}
				return true; // Get rid of the password prompt
			}
		});
	});
	$tw.rootWidget.addEventListener("tm-clear-password",function(event) {
		if($tw.browser) {
			if(!confirm($tw.language.getString("Encryption/ConfirmClearPassword"))) {
				return;
			}
		}
		$tw.crypto.setPassword(null);
	});
	// Ensure that $:/isEncrypted is maintained properly
	$tw.wiki.addEventListener("change",function(changes) {
		if($tw.utils.hop(changes,"$:/isEncrypted")) {
			$tw.crypto.updateCryptoStateTiddler();
		}
	});
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/render.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/render.js
type: application/javascript
module-type: startup

Title, stylesheet and page rendering

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "render";
exports.platforms = ["browser"];
exports.after = ["story"];
exports.synchronous = true;

// Default story and history lists
var PAGE_TITLE_TITLE = "$:/core/wiki/title";
var PAGE_STYLESHEET_TITLE = "$:/core/ui/PageStylesheet";
var PAGE_TEMPLATE_TITLE = "$:/core/ui/PageTemplate";

// Time (in ms) that we defer refreshing changes to draft tiddlers
var DRAFT_TIDDLER_TIMEOUT_TITLE = "$:/config/Drafts/TypingTimeout";
var DRAFT_TIDDLER_TIMEOUT = 400;

exports.startup = function() {
	// Set up the title
	$tw.titleWidgetNode = $tw.wiki.makeTranscludeWidget(PAGE_TITLE_TITLE,{document: $tw.fakeDocument, parseAsInline: true});
	$tw.titleContainer = $tw.fakeDocument.createElement("div");
	$tw.titleWidgetNode.render($tw.titleContainer,null);
	document.title = $tw.titleContainer.textContent;
	$tw.wiki.addEventListener("change",function(changes) {
		if($tw.titleWidgetNode.refresh(changes,$tw.titleContainer,null)) {
			document.title = $tw.titleContainer.textContent;
		}
	});
	// Set up the styles
	$tw.styleWidgetNode = $tw.wiki.makeTranscludeWidget(PAGE_STYLESHEET_TITLE,{document: $tw.fakeDocument});
	$tw.styleContainer = $tw.fakeDocument.createElement("style");
	$tw.styleWidgetNode.render($tw.styleContainer,null);
	$tw.styleElement = document.createElement("style");
	$tw.styleElement.innerHTML = $tw.styleContainer.textContent;
	document.head.insertBefore($tw.styleElement,document.head.firstChild);
	$tw.wiki.addEventListener("change",$tw.perf.report("styleRefresh",function(changes) {
		if($tw.styleWidgetNode.refresh(changes,$tw.styleContainer,null)) {
			$tw.styleElement.innerHTML = $tw.styleContainer.textContent;
		}
	}));
	// Display the $:/core/ui/PageTemplate tiddler to kick off the display
	$tw.perf.report("mainRender",function() {
		$tw.pageWidgetNode = $tw.wiki.makeTranscludeWidget(PAGE_TEMPLATE_TITLE,{document: document, parentWidget: $tw.rootWidget});
		$tw.pageContainer = document.createElement("div");
		$tw.utils.addClass($tw.pageContainer,"tc-page-container-wrapper");
		document.body.insertBefore($tw.pageContainer,document.body.firstChild);
		$tw.pageWidgetNode.render($tw.pageContainer,null);
   		$tw.hooks.invokeHook("th-page-refreshed");
	})();
	// Remove any splash screen elements
	var removeList = document.querySelectorAll(".tc-remove-when-wiki-loaded");
	$tw.utils.each(removeList,function(removeItem) {
		if(removeItem.parentNode) {
			removeItem.parentNode.removeChild(removeItem);
		}
	});
	// Prepare refresh mechanism
	var deferredChanges = Object.create(null),
		timerId;
	function refresh() {
		// Process the refresh
		$tw.hooks.invokeHook("th-page-refreshing");
		$tw.pageWidgetNode.refresh(deferredChanges);
		deferredChanges = Object.create(null);
		$tw.hooks.invokeHook("th-page-refreshed");
	}
	// Add the change event handler
	$tw.wiki.addEventListener("change",$tw.perf.report("mainRefresh",function(changes) {
		// Check if only drafts have changed
		var onlyDraftsHaveChanged = true;
		for(var title in changes) {
			var tiddler = $tw.wiki.getTiddler(title);
			if(!tiddler || !tiddler.hasField("draft.of")) {
				onlyDraftsHaveChanged = false;
			}
		}
		// Defer the change if only drafts have changed
		if(timerId) {
			clearTimeout(timerId);
		}
		timerId = null;
		if(onlyDraftsHaveChanged) {
			var timeout = parseInt($tw.wiki.getTiddlerText(DRAFT_TIDDLER_TIMEOUT_TITLE,""),10);
			if(isNaN(timeout)) {
				timeout = DRAFT_TIDDLER_TIMEOUT;
			}
			timerId = setTimeout(refresh,timeout);
			$tw.utils.extend(deferredChanges,changes);
		} else {
			$tw.utils.extend(deferredChanges,changes);
			refresh();
		}
	}));
	// Fix up the link between the root widget and the page container
	$tw.rootWidget.domNodes = [$tw.pageContainer];
	$tw.rootWidget.children = [$tw.pageWidgetNode];
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/rootwidget.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/rootwidget.js
type: application/javascript
module-type: startup

Setup the root widget and the core root widget handlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "rootwidget";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.before = ["story"];
exports.synchronous = true;

exports.startup = function() {
	// Install the modal message mechanism
	$tw.modal = new $tw.utils.Modal($tw.wiki);
	$tw.rootWidget.addEventListener("tm-modal",function(event) {
		$tw.modal.display(event.param,{variables: event.paramObject, event: event});
	});
	// Install the notification  mechanism
	$tw.notifier = new $tw.utils.Notifier($tw.wiki);
	$tw.rootWidget.addEventListener("tm-notify",function(event) {
		$tw.notifier.display(event.param,{variables: event.paramObject});
	});
	// Install the copy-to-clipboard  mechanism
	$tw.rootWidget.addEventListener("tm-copy-to-clipboard",function(event) {
		$tw.utils.copyToClipboard(event.param);
	});
	// Install the tm-focus-selector message
	$tw.rootWidget.addEventListener("tm-focus-selector",function(event) {
		var selector = event.param || "",
			element;
		try {
			element = document.querySelector(selector);
		} catch(e) {
			console.log("Error in selector: ",selector)
		}
		if(element && element.focus) {
			element.focus();
		}
	});
	// Install the scroller
	$tw.pageScroller = new $tw.utils.PageScroller();
	$tw.rootWidget.addEventListener("tm-scroll",function(event) {
		$tw.pageScroller.handleEvent(event);
	});
	var fullscreen = $tw.utils.getFullScreenApis();
	if(fullscreen) {
		$tw.rootWidget.addEventListener("tm-full-screen",function(event) {
			var fullScreenDocument = event.event ? event.event.target.ownerDocument : document;
			if(event.param === "enter") {
				fullScreenDocument.documentElement[fullscreen._requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
			} else if(event.param === "exit") {
				fullScreenDocument[fullscreen._exitFullscreen]();
			} else {
				if(fullScreenDocument[fullscreen._fullscreenElement]) {
					fullScreenDocument[fullscreen._exitFullscreen]();
				} else {
					fullScreenDocument.documentElement[fullscreen._requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
				}				
			}
		});
	}
	// If we're being viewed on a data: URI then give instructions for how to save
	if(document.location.protocol === "data:") {
		$tw.rootWidget.dispatchEvent({
			type: "tm-modal",
			param: "$:/language/Modals/SaveInstructions"
		});
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup.js
type: application/javascript
module-type: startup

Miscellaneous startup logic for both the client and server.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "startup";
exports.after = ["load-modules"];
exports.synchronous = true;

// Set to `true` to enable performance instrumentation
var PERFORMANCE_INSTRUMENTATION_CONFIG_TITLE = "$:/config/Performance/Instrumentation";

var widget = require("$:/core/modules/widgets/widget.js");

exports.startup = function() {
	var modules,n,m,f;
	// Minimal browser detection
	if($tw.browser) {
		$tw.browser.isIE = (/msie|trident/i.test(navigator.userAgent));
		$tw.browser.isFirefox = !!document.mozFullScreenEnabled;
	}
	// Platform detection
	$tw.platform = {};
	if($tw.browser) {
		$tw.platform.isMac = /Mac/.test(navigator.platform);
		$tw.platform.isWindows = /win/i.test(navigator.platform);
		$tw.platform.isLinux = /Linux/i.test(navigator.platform);
	} else {
		switch(require("os").platform()) {
			case "darwin":
				$tw.platform.isMac = true;
				break;
			case "win32":
				$tw.platform.isWindows = true;
				break;
			case "freebsd":
				$tw.platform.isLinux = true;
				break;
			case "linux":
				$tw.platform.isLinux = true;
				break;
		}
	}
	// Initialise version
	$tw.version = $tw.utils.extractVersionInfo();
	// Set up the performance framework
	$tw.perf = new $tw.Performance($tw.wiki.getTiddlerText(PERFORMANCE_INSTRUMENTATION_CONFIG_TITLE,"no") === "yes");
	// Create a root widget for attaching event handlers. By using it as the parentWidget for another widget tree, one can reuse the event handlers
	$tw.rootWidget = new widget.widget({
		type: "widget",
		children: []
	},{
		wiki: $tw.wiki,
		document: $tw.browser ? document : $tw.fakeDocument
	});
	// Execute any startup actions
	var executeStartupTiddlers = function(tag) {
		$tw.utils.each($tw.wiki.filterTiddlers("[all[shadows+tiddlers]tag[" + tag + "]!has[draft.of]]"),function(title) {
			$tw.rootWidget.invokeActionString($tw.wiki.getTiddlerText(title),$tw.rootWidget);
		});
	};
	executeStartupTiddlers("$:/tags/StartupAction");
	if($tw.browser) {
		executeStartupTiddlers("$:/tags/StartupAction/Browser");		
	}
	if($tw.node) {
		executeStartupTiddlers("$:/tags/StartupAction/Node");		
	}
	// Kick off the language manager and switcher
	$tw.language = new $tw.Language();
	$tw.languageSwitcher = new $tw.PluginSwitcher({
		wiki: $tw.wiki,
		pluginType: "language",
		controllerTitle: "$:/language",
		defaultPlugins: [
			"$:/languages/en-GB"
		],
		onSwitch: function(plugins) {
			if($tw.browser) {
				var pluginTiddler = $tw.wiki.getTiddler(plugins[0]);
				if(pluginTiddler) {
					document.documentElement.setAttribute("dir",pluginTiddler.getFieldString("text-direction") || "auto");
				} else {
					document.documentElement.removeAttribute("dir");
				}
			}
		}
	});
	// Kick off the theme manager
	$tw.themeManager = new $tw.PluginSwitcher({
		wiki: $tw.wiki,
		pluginType: "theme",
		controllerTitle: "$:/theme",
		defaultPlugins: [
			"$:/themes/tiddlywiki/snowwhite",
			"$:/themes/tiddlywiki/vanilla"
		]
	});
	// Kick off the keyboard manager
	$tw.keyboardManager = new $tw.KeyboardManager();
	// Listen for shortcuts
	if($tw.browser) {
		$tw.utils.addEventListeners(document,[{
			name: "keydown",
			handlerObject: $tw.keyboardManager,
			handlerMethod: "handleKeydownEvent"
		}]);
	}
	// Clear outstanding tiddler store change events to avoid an unnecessary refresh cycle at startup
	$tw.wiki.clearTiddlerEventQueue();
	// Find a working syncadaptor
	$tw.syncadaptor = undefined;
	$tw.modules.forEachModuleOfType("syncadaptor",function(title,module) {
		if(!$tw.syncadaptor && module.adaptorClass) {
			$tw.syncadaptor = new module.adaptorClass({wiki: $tw.wiki});
		}
	});
	// Set up the syncer object if we've got a syncadaptor
	if($tw.syncadaptor) {
		$tw.syncer = new $tw.Syncer({wiki: $tw.wiki, syncadaptor: $tw.syncadaptor});
	} 
	// Setup the saver handler
	$tw.saverHandler = new $tw.SaverHandler({
		wiki: $tw.wiki,
		dirtyTracking: !$tw.syncadaptor,
		preloadDirty: $tw.boot.preloadDirty || []
	});
	// Host-specific startup
	if($tw.browser) {
		// Install the popup manager
		$tw.popup = new $tw.utils.Popup();
		// Install the animator
		$tw.anim = new $tw.utils.Animator();
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/story.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/story.js
type: application/javascript
module-type: startup

Load core modules

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "story";
exports.after = ["startup"];
exports.synchronous = true;

// Default story and history lists
var DEFAULT_STORY_TITLE = "$:/StoryList";
var DEFAULT_HISTORY_TITLE = "$:/HistoryList";

// Default tiddlers
var DEFAULT_TIDDLERS_TITLE = "$:/DefaultTiddlers";

// Config
var CONFIG_UPDATE_ADDRESS_BAR = "$:/config/Navigation/UpdateAddressBar"; // Can be "no", "permalink", "permaview"
var CONFIG_UPDATE_HISTORY = "$:/config/Navigation/UpdateHistory"; // Can be "yes" or "no"
var CONFIG_PERMALINKVIEW_COPY_TO_CLIPBOARD = "$:/config/Navigation/Permalinkview/CopyToClipboard"; // Can be "yes" (default) or "no"
var CONFIG_PERMALINKVIEW_UPDATE_ADDRESS_BAR = "$:/config/Navigation/Permalinkview/UpdateAddressBar"; // Can be "yes" (default) or "no"


// Links to help, if there is no param
var HELP_OPEN_EXTERNAL_WINDOW = "http://tiddlywiki.com/#WidgetMessage%3A%20tm-open-external-window";

exports.startup = function() {
	// Open startup tiddlers
	openStartupTiddlers({
		disableHistory: $tw.boot.disableStartupNavigation
	});
	if($tw.browser) {
		// Set up location hash update
		$tw.wiki.addEventListener("change",function(changes) {
			if($tw.utils.hop(changes,DEFAULT_STORY_TITLE) || $tw.utils.hop(changes,DEFAULT_HISTORY_TITLE)) {
				updateLocationHash({
					updateAddressBar: $tw.wiki.getTiddlerText(CONFIG_UPDATE_ADDRESS_BAR,"permaview").trim(),
					updateHistory: $tw.wiki.getTiddlerText(CONFIG_UPDATE_HISTORY,"no").trim()
				});
			}
		});
		// Listen for changes to the browser location hash
		window.addEventListener("hashchange",function() {
			var hash = $tw.utils.getLocationHash();
			if(hash !== $tw.locationHash) {
				$tw.locationHash = hash;
				openStartupTiddlers({defaultToCurrentStory: true});
			}
		},false);
		// Listen for the tm-browser-refresh message
		$tw.rootWidget.addEventListener("tm-browser-refresh",function(event) {
			window.location.reload(true);
		});
		// Listen for tm-open-external-window message
		$tw.rootWidget.addEventListener("tm-open-external-window",function(event) {
			var paramObject = event.paramObject || {},
				strUrl = event.param || HELP_OPEN_EXTERNAL_WINDOW,
				strWindowName = paramObject.windowName,
				strWindowFeatures = paramObject.windowFeatures;
			window.open(strUrl, strWindowName, strWindowFeatures);
		});
		// Listen for the tm-print message
		$tw.rootWidget.addEventListener("tm-print",function(event) {
			(event.event.view || window).print();
		});
		// Listen for the tm-home message
		$tw.rootWidget.addEventListener("tm-home",function(event) {
			window.location.hash = "";
			var storyFilter = $tw.wiki.getTiddlerText(DEFAULT_TIDDLERS_TITLE),
				storyList = $tw.wiki.filterTiddlers(storyFilter);
			//invoke any hooks that might change the default story list
			storyList = $tw.hooks.invokeHook("th-opening-default-tiddlers-list",storyList);
			$tw.wiki.addTiddler({title: DEFAULT_STORY_TITLE, text: "", list: storyList},$tw.wiki.getModificationFields());
			if(storyList[0]) {
				$tw.wiki.addToHistory(storyList[0]);
			}
		});
		// Listen for the tm-permalink message
		$tw.rootWidget.addEventListener("tm-permalink",function(event) {
			updateLocationHash({
				updateAddressBar: $tw.wiki.getTiddlerText(CONFIG_PERMALINKVIEW_UPDATE_ADDRESS_BAR,"yes").trim() === "yes" ? "permalink" : "none",
				updateHistory: $tw.wiki.getTiddlerText(CONFIG_UPDATE_HISTORY,"no").trim(),
				targetTiddler: event.param || event.tiddlerTitle,
				copyToClipboard: $tw.wiki.getTiddlerText(CONFIG_PERMALINKVIEW_COPY_TO_CLIPBOARD,"yes").trim() === "yes" ? "permalink" : "none"
			});
		});
		// Listen for the tm-permaview message
		$tw.rootWidget.addEventListener("tm-permaview",function(event) {
			updateLocationHash({
				updateAddressBar: $tw.wiki.getTiddlerText(CONFIG_PERMALINKVIEW_UPDATE_ADDRESS_BAR,"yes").trim() === "yes" ? "permaview" : "none",
				updateHistory: $tw.wiki.getTiddlerText(CONFIG_UPDATE_HISTORY,"no").trim(),
				targetTiddler: event.param || event.tiddlerTitle,
				copyToClipboard: $tw.wiki.getTiddlerText(CONFIG_PERMALINKVIEW_COPY_TO_CLIPBOARD,"yes").trim() === "yes" ? "permaview" : "none"
			});				
		});
	}
};

/*
Process the location hash to open the specified tiddlers. Options:
disableHistory: if true $:/History is NOT updated
defaultToCurrentStory: If true, the current story is retained as the default, instead of opening the default tiddlers
*/
function openStartupTiddlers(options) {
	options = options || {};
	// Work out the target tiddler and the story filter. "null" means "unspecified"
	var target = null,
		storyFilter = null;
	if($tw.locationHash.length > 1) {
		var hash = $tw.locationHash.substr(1),
			split = hash.indexOf(":");
		if(split === -1) {
			target = decodeURIComponent(hash.trim());
		} else {
			target = decodeURIComponent(hash.substr(0,split).trim());
			storyFilter = decodeURIComponent(hash.substr(split + 1).trim());
		}
	}
	// If the story wasn't specified use the current tiddlers or a blank story
	if(storyFilter === null) {
		if(options.defaultToCurrentStory) {
			var currStoryList = $tw.wiki.getTiddlerList(DEFAULT_STORY_TITLE);
			storyFilter = $tw.utils.stringifyList(currStoryList);
		} else {
			if(target && target !== "") {
				storyFilter = "";
			} else {
				storyFilter = $tw.wiki.getTiddlerText(DEFAULT_TIDDLERS_TITLE);
			}
		}
	}
	// Process the story filter to get the story list
	var storyList = $tw.wiki.filterTiddlers(storyFilter);
	// Invoke any hooks that want to change the default story list
	storyList = $tw.hooks.invokeHook("th-opening-default-tiddlers-list",storyList);
	// If the target tiddler isn't included then splice it in at the top
	if(target && storyList.indexOf(target) === -1) {
		storyList.unshift(target);
	}
	// Save the story list
	$tw.wiki.addTiddler({title: DEFAULT_STORY_TITLE, text: "", list: storyList},$tw.wiki.getModificationFields());
	// Update history
	if(!options.disableHistory) {
		// If a target tiddler was specified add it to the history stack
		if(target && target !== "") {
			// The target tiddler doesn't need double square brackets, but we'll silently remove them if they're present
			if(target.indexOf("[[") === 0 && target.substr(-2) === "]]") {
				target = target.substr(2,target.length - 4);
			}
			$tw.wiki.addToHistory(target);
		} else if(storyList.length > 0) {
			$tw.wiki.addToHistory(storyList[0]);
		}		
	}
}

/*
options: See below
options.updateAddressBar: "permalink", "permaview" or "no" (defaults to "permaview")
options.updateHistory: "yes" or "no" (defaults to "no")
options.copyToClipboard: "permalink", "permaview" or "no" (defaults to "no")
options.targetTiddler: optional title of target tiddler for permalink
*/
function updateLocationHash(options) {
	// Get the story and the history stack
	var storyList = $tw.wiki.getTiddlerList(DEFAULT_STORY_TITLE),
		historyList = $tw.wiki.getTiddlerData(DEFAULT_HISTORY_TITLE,[]),
		targetTiddler = "";
	if(options.targetTiddler) {
		targetTiddler = options.targetTiddler;
	} else {
		// The target tiddler is the one at the top of the stack
		if(historyList.length > 0) {
			targetTiddler = historyList[historyList.length-1].title;
		}
		// Blank the target tiddler if it isn't present in the story
		if(storyList.indexOf(targetTiddler) === -1) {
			targetTiddler = "";
		}
	}
	// Assemble the location hash
	switch(options.updateAddressBar) {
		case "permalink":
			$tw.locationHash = "#" + encodeURIComponent(targetTiddler);
			break;
		case "permaview":
			$tw.locationHash = "#" + encodeURIComponent(targetTiddler) + ":" + encodeURIComponent($tw.utils.stringifyList(storyList));
			break;
	}
	// Copy URL to the clipboard
	switch(options.copyToClipboard) {
		case "permalink":
			$tw.utils.copyToClipboard($tw.utils.getLocationPath() + "#" + encodeURIComponent(targetTiddler));
			break;
		case "permaview":
			$tw.utils.copyToClipboard($tw.utils.getLocationPath() + "#" + encodeURIComponent(targetTiddler) + ":" + encodeURIComponent($tw.utils.stringifyList(storyList)));
			break;
	}
	// Only change the location hash if we must, thus avoiding unnecessary onhashchange events
	if($tw.utils.getLocationHash() !== $tw.locationHash) {
		if(options.updateHistory === "yes") {
			// Assign the location hash so that history is updated
			window.location.hash = $tw.locationHash;
		} else {
			// We use replace so that browser history isn't affected
			window.location.replace(window.location.toString().split("#")[0] + $tw.locationHash);
		}
	}
}

})();

;})();
return exports;
}));
_define("$:/core/modules/startup/windows.js","startup",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/startup/windows.js
type: application/javascript
module-type: startup

Setup root widget handlers for the messages concerned with opening external browser windows

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Export name and synchronous status
exports.name = "windows";
exports.platforms = ["browser"];
exports.after = ["startup"];
exports.synchronous = true;

// Global to keep track of open windows (hashmap by title)
var windows = {};

exports.startup = function() {
	// Handle open window message
	$tw.rootWidget.addEventListener("tm-open-window",function(event) {
		// Get the parameters
		var refreshHandler,
			title = event.param || event.tiddlerTitle,
			paramObject = event.paramObject || {},
			windowTitle = paramObject.windowTitle || title,
			template = paramObject.template || "$:/core/templates/single.tiddler.window",
			width = paramObject.width || "700",
			height = paramObject.height || "600",
			variables = $tw.utils.extend({},paramObject,{currentTiddler: title});
		// Open the window
		var srcWindow,
		    srcDocument;
		// In case that popup blockers deny opening a new window
		try {
			srcWindow = window.open("","external-" + title,"scrollbars,width=" + width + ",height=" + height),
			srcDocument = srcWindow.document;
		}
		catch(e) {
			return;
		}
		windows[title] = srcWindow;
		// Check for reopening the same window
		if(srcWindow.haveInitialisedWindow) {
			return;
		}
		// Initialise the document
		srcDocument.write("<html><head></head><body class='tc-body tc-single-tiddler-window'></body></html>");
		srcDocument.close();
		srcDocument.title = windowTitle;
		srcWindow.addEventListener("beforeunload",function(event) {
			delete windows[title];
			$tw.wiki.removeEventListener("change",refreshHandler);
		},false);
		// Set up the styles
		var styleWidgetNode = $tw.wiki.makeTranscludeWidget("$:/core/ui/PageStylesheet",{
				document: $tw.fakeDocument,
				variables: variables,
				importPageMacros: true}),
			styleContainer = $tw.fakeDocument.createElement("style");
		styleWidgetNode.render(styleContainer,null);
		var styleElement = srcDocument.createElement("style");
		styleElement.innerHTML = styleContainer.textContent;
		srcDocument.head.insertBefore(styleElement,srcDocument.head.firstChild);
		// Render the text of the tiddler
		var parser = $tw.wiki.parseTiddler(template),
			widgetNode = $tw.wiki.makeWidget(parser,{document: srcDocument, parentWidget: $tw.rootWidget, variables: variables});
		widgetNode.render(srcDocument.body,srcDocument.body.firstChild);
		// Function to handle refreshes
		refreshHandler = function(changes) {
			if(styleWidgetNode.refresh(changes,styleContainer,null)) {
				styleElement.innerHTML = styleContainer.textContent;
			}
			widgetNode.refresh(changes);
		};
		$tw.wiki.addEventListener("change",refreshHandler);
		// Listen for keyboard shortcuts
		$tw.utils.addEventListeners(srcDocument,[{
			name: "keydown",
			handlerObject: $tw.keyboardManager,
			handlerMethod: "handleKeydownEvent"
		},{
			name: "click",
			handlerObject: $tw.popup,
			handlerMethod: "handleEvent"
		}]);
		srcWindow.haveInitialisedWindow = true;
	});
	// Close open windows when unloading main window
	$tw.addUnloadTask(function() {
		$tw.utils.each(windows,function(win) {
			win.close();
		});
	});

};

})();

;})();
return exports;
}));
_define("$:/core/modules/story.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/story.js
type: application/javascript
module-type: global

Lightweight object for managing interactions with the story and history lists.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Construct Story object with options:
wiki: reference to wiki object to use to resolve tiddler titles
storyTitle: title of story list tiddler
historyTitle: title of history list tiddler
*/
function Story(options) {
	options = options || {};
	this.wiki = options.wiki || $tw.wiki;
	this.storyTitle = options.storyTitle || "$:/StoryList";
	this.historyTitle = options.historyTitle || "$:/HistoryList";
};

Story.prototype.navigateTiddler = function(navigateTo,navigateFromTitle,navigateFromClientRect) {
	this.addToStory(navigateTo,navigateFromTitle);
	this.addToHistory(navigateTo,navigateFromClientRect);
};

Story.prototype.getStoryList = function() {
	return this.wiki.getTiddlerList(this.storyTitle) || [];
};

Story.prototype.addToStory = function(navigateTo,navigateFromTitle,options) {
	options = options || {};
	var storyList = this.getStoryList();
	// See if the tiddler is already there
	var slot = storyList.indexOf(navigateTo);
	// Quit if it already exists in the story river
	if(slot >= 0) {
		return;
	}
	// First we try to find the position of the story element we navigated from
	var fromIndex = storyList.indexOf(navigateFromTitle);
	if(fromIndex >= 0) {
		// The tiddler is added from inside the river
		// Determine where to insert the tiddler; Fallback is "below"
		switch(options.openLinkFromInsideRiver) {
			case "top":
				slot = 0;
				break;
			case "bottom":
				slot = storyList.length;
				break;
			case "above":
				slot = fromIndex;
				break;
			case "below": // Intentional fall-through
			default:
				slot = fromIndex + 1;
				break;
		}
	} else {
		// The tiddler is opened from outside the river. Determine where to insert the tiddler; default is "top"
		if(options.openLinkFromOutsideRiver === "bottom") {
			// Insert at bottom
			slot = storyList.length;
		} else {
			// Insert at top
			slot = 0;
		}
	}
	// Add the tiddler
	storyList.splice(slot,0,navigateTo);
	// Save the story
	this.saveStoryList(storyList);
};

Story.prototype.saveStoryList = function(storyList) {
	var storyTiddler = this.wiki.getTiddler(this.storyTitle);
	this.wiki.addTiddler(new $tw.Tiddler(
		this.wiki.getCreationFields(),
		{title: this.storyTitle},
		storyTiddler,
		{list: storyList},
		this.wiki.getModificationFields()
	));
};

Story.prototype.addToHistory = function(navigateTo,navigateFromClientRect) {
	var titles = $tw.utils.isArray(navigateTo) ? navigateTo : [navigateTo];
	// Add a new record to the top of the history stack
	var historyList = this.wiki.getTiddlerData(this.historyTitle,[]);
	$tw.utils.each(titles,function(title) {
		historyList.push({title: title, fromPageRect: navigateFromClientRect});
	});
	this.wiki.setTiddlerData(this.historyTitle,historyList,{"current-tiddler": titles[titles.length-1]});
};

Story.prototype.storyCloseTiddler = function(targetTitle) {
// TBD
};

Story.prototype.storyCloseAllTiddlers = function() {
// TBD
};

Story.prototype.storyCloseOtherTiddlers = function(targetTitle) {
// TBD
};

Story.prototype.storyEditTiddler = function(targetTitle) {
// TBD
};

Story.prototype.storyDeleteTiddler = function(targetTitle) {
// TBD
};

Story.prototype.storySaveTiddler = function(targetTitle) {
// TBD
};

Story.prototype.storyCancelTiddler = function(targetTitle) {
// TBD
};

Story.prototype.storyNewTiddler = function(targetTitle) {
// TBD
};

exports.Story = Story;


})();

;})();
return exports;
}));
_define("$:/core/modules/storyviews/classic.js","storyview",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/storyviews/classic.js
type: application/javascript
module-type: storyview

Views the story as a linear sequence

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var easing = "cubic-bezier(0.645, 0.045, 0.355, 1)"; // From http://easings.net/#easeInOutCubic

var ClassicStoryView = function(listWidget) {
	this.listWidget = listWidget;
};

ClassicStoryView.prototype.navigateTo = function(historyInfo) {
	var duration = $tw.utils.getAnimationDuration()
	var listElementIndex = this.listWidget.findListItem(0,historyInfo.title);
	if(listElementIndex === undefined) {
		return;
	}
	var listItemWidget = this.listWidget.children[listElementIndex],
		targetElement = listItemWidget.findFirstDomNode();
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		return;
	}
	if(duration) {
		// Scroll the node into view
		this.listWidget.dispatchEvent({type: "tm-scroll", target: targetElement});	
	} else {
		targetElement.scrollIntoView();
	}
};

ClassicStoryView.prototype.insert = function(widget) {
	var duration = $tw.utils.getAnimationDuration();
	if(duration) {
		var targetElement = widget.findFirstDomNode();
		// Abandon if the list entry isn't a DOM element (it might be a text node)
		if(!(targetElement instanceof Element)) {
			return;
		}
		// Get the current height of the tiddler
		var computedStyle = window.getComputedStyle(targetElement),
			currMarginBottom = parseInt(computedStyle.marginBottom,10),
			currMarginTop = parseInt(computedStyle.marginTop,10),
			currHeight = targetElement.offsetHeight + currMarginTop;
		// Reset the margin once the transition is over
		setTimeout(function() {
			$tw.utils.setStyle(targetElement,[
				{transition: "none"},
				{marginBottom: ""}
			]);
		},duration);
		// Set up the initial position of the element
		$tw.utils.setStyle(targetElement,[
			{transition: "none"},
			{marginBottom: (-currHeight) + "px"},
			{opacity: "0.0"}
		]);
		$tw.utils.forceLayout(targetElement);
		// Transition to the final position
		$tw.utils.setStyle(targetElement,[
			{transition: "opacity " + duration + "ms " + easing + ", " +
						"margin-bottom " + duration + "ms " + easing},
			{marginBottom: currMarginBottom + "px"},
			{opacity: "1.0"}
	]);
	}
};

ClassicStoryView.prototype.remove = function(widget) {
	var duration = $tw.utils.getAnimationDuration();
	if(duration) {
		var targetElement = widget.findFirstDomNode(),
			removeElement = function() {
				widget.removeChildDomNodes();
			};
		// Abandon if the list entry isn't a DOM element (it might be a text node)
		if(!(targetElement instanceof Element)) {
			removeElement();
			return;
		}
		// Get the current height of the tiddler
		var currWidth = targetElement.offsetWidth,
			computedStyle = window.getComputedStyle(targetElement),
			currMarginBottom = parseInt(computedStyle.marginBottom,10),
			currMarginTop = parseInt(computedStyle.marginTop,10),
			currHeight = targetElement.offsetHeight + currMarginTop;
		// Remove the dom nodes of the widget at the end of the transition
		setTimeout(removeElement,duration);
		// Animate the closure
		$tw.utils.setStyle(targetElement,[
			{transition: "none"},
			{transform: "translateX(0px)"},
			{marginBottom:  currMarginBottom + "px"},
			{opacity: "1.0"}
		]);
		$tw.utils.forceLayout(targetElement);
		$tw.utils.setStyle(targetElement,[
			{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", " +
						"opacity " + duration + "ms " + easing + ", " +
						"margin-bottom " + duration + "ms " + easing},
			{transform: "translateX(-" + currWidth + "px)"},
			{marginBottom: (-currHeight) + "px"},
			{opacity: "0.0"}
		]);
	} else {
		widget.removeChildDomNodes();
	}
};

exports.classic = ClassicStoryView;

})();
;})();
return exports;
}));
_define("$:/core/modules/storyviews/pop.js","storyview",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/storyviews/pop.js
type: application/javascript
module-type: storyview

Animates list insertions and removals

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var PopStoryView = function(listWidget) {
	this.listWidget = listWidget;
};

PopStoryView.prototype.navigateTo = function(historyInfo) {
	var listElementIndex = this.listWidget.findListItem(0,historyInfo.title);
	if(listElementIndex === undefined) {
		return;
	}
	var listItemWidget = this.listWidget.children[listElementIndex],
		targetElement = listItemWidget.findFirstDomNode();
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		return;
	}
	// Scroll the node into view
	this.listWidget.dispatchEvent({type: "tm-scroll", target: targetElement});
};

PopStoryView.prototype.insert = function(widget) {
	var targetElement = widget.findFirstDomNode(),
		duration = $tw.utils.getAnimationDuration();
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		return;
	}
	// Reset once the transition is over
	setTimeout(function() {
		$tw.utils.setStyle(targetElement,[
			{transition: "none"},
			{transform: "none"}
		]);
		$tw.utils.setStyle(widget.document.body,[
			{"overflow-x": ""}
		]);
	},duration);
	// Prevent the page from overscrolling due to the zoom factor
	$tw.utils.setStyle(widget.document.body,[
		{"overflow-x": "hidden"}
	]);
	// Set up the initial position of the element
	$tw.utils.setStyle(targetElement,[
		{transition: "none"},
		{transform: "scale(2)"},
		{opacity: "0.0"}
	]);
	$tw.utils.forceLayout(targetElement);
	// Transition to the final position
	$tw.utils.setStyle(targetElement,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms ease-in-out, " +
					"opacity " + duration + "ms ease-in-out"},
		{transform: "scale(1)"},
		{opacity: "1.0"}
	]);
};

PopStoryView.prototype.remove = function(widget) {
	var targetElement = widget.findFirstDomNode(),
		duration = $tw.utils.getAnimationDuration(),
		removeElement = function() {
			if(targetElement.parentNode) {
				widget.removeChildDomNodes();
			}
		};
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		removeElement();
		return;
	}
	// Remove the element at the end of the transition
	setTimeout(removeElement,duration);
	// Animate the closure
	$tw.utils.setStyle(targetElement,[
		{transition: "none"},
		{transform: "scale(1)"},
		{opacity: "1.0"}
	]);
	$tw.utils.forceLayout(targetElement);
	$tw.utils.setStyle(targetElement,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms ease-in-out, " +
					"opacity " + duration + "ms ease-in-out"},
		{transform: "scale(0.1)"},
		{opacity: "0.0"}
	]);
};

exports.pop = PopStoryView;

})();

;})();
return exports;
}));
_define("$:/core/modules/storyviews/zoomin.js","storyview",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/storyviews/zoomin.js
type: application/javascript
module-type: storyview

Zooms between individual tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var easing = "cubic-bezier(0.645, 0.045, 0.355, 1)"; // From http://easings.net/#easeInOutCubic

var ZoominListView = function(listWidget) {
	var self = this;
	this.listWidget = listWidget;
	// Get the index of the tiddler that is at the top of the history
	var history = this.listWidget.wiki.getTiddlerDataCached(this.listWidget.historyTitle,[]),
		targetTiddler;
	if(history.length > 0) {
		targetTiddler = history[history.length-1].title;
	}
	// Make all the tiddlers position absolute, and hide all but the top (or first) one
	$tw.utils.each(this.listWidget.children,function(itemWidget,index) {
		var domNode = itemWidget.findFirstDomNode();
		// Abandon if the list entry isn't a DOM element (it might be a text node)
		if(!(domNode instanceof Element)) {
			return;
		}
		if((targetTiddler && targetTiddler !== itemWidget.parseTreeNode.itemTitle) || (!targetTiddler && index)) {
			domNode.style.display = "none";
		} else {
			self.currentTiddlerDomNode = domNode;
		}
		$tw.utils.addClass(domNode,"tc-storyview-zoomin-tiddler");
	});
};

ZoominListView.prototype.navigateTo = function(historyInfo) {
	var duration = $tw.utils.getAnimationDuration(),
		listElementIndex = this.listWidget.findListItem(0,historyInfo.title);
	if(listElementIndex === undefined) {
		return;
	}
	var listItemWidget = this.listWidget.children[listElementIndex],
		targetElement = listItemWidget.findFirstDomNode();
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		return;
	}
	// Make the new tiddler be position absolute and visible so that we can measure it
	$tw.utils.addClass(targetElement,"tc-storyview-zoomin-tiddler");
	$tw.utils.setStyle(targetElement,[
		{display: "block"},
		{transformOrigin: "0 0"},
		{transform: "translateX(0px) translateY(0px) scale(1)"},
		{transition: "none"},
		{opacity: "0.0"}
	]);
	// Get the position of the source node, or use the centre of the window as the source position
	var sourceBounds = historyInfo.fromPageRect || {
			left: window.innerWidth/2 - 2,
			top: window.innerHeight/2 - 2,
			width: window.innerWidth/8,
			height: window.innerHeight/8
		};
	// Try to find the title node in the target tiddler
	var titleDomNode = findTitleDomNode(listItemWidget) || listItemWidget.findFirstDomNode(),
		zoomBounds = titleDomNode.getBoundingClientRect();
	// Compute the transform for the target tiddler to make the title lie over the source rectange
	var targetBounds = targetElement.getBoundingClientRect(),
		scale = sourceBounds.width / zoomBounds.width,
		x = sourceBounds.left - targetBounds.left - (zoomBounds.left - targetBounds.left) * scale,
		y = sourceBounds.top - targetBounds.top - (zoomBounds.top - targetBounds.top) * scale;
	// Transform the target tiddler to its starting position
	$tw.utils.setStyle(targetElement,[
		{transform: "translateX(" + x + "px) translateY(" + y + "px) scale(" + scale + ")"}
	]);
	// Force layout
	$tw.utils.forceLayout(targetElement);
	// Apply the ending transitions with a timeout to ensure that the previously applied transformations are applied first
	var self = this,
		prevCurrentTiddler = this.currentTiddlerDomNode;
	this.currentTiddlerDomNode = targetElement;
	// Transform the target tiddler to its natural size
	$tw.utils.setStyle(targetElement,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
		{opacity: "1.0"},
		{transform: "translateX(0px) translateY(0px) scale(1)"},
		{zIndex: "500"},
	]);
	// Transform the previous tiddler out of the way and then hide it
	if(prevCurrentTiddler && prevCurrentTiddler !== targetElement) {
		scale = zoomBounds.width / sourceBounds.width;
		x =  zoomBounds.left - targetBounds.left - (sourceBounds.left - targetBounds.left) * scale;
		y =  zoomBounds.top - targetBounds.top - (sourceBounds.top - targetBounds.top) * scale;
		$tw.utils.setStyle(prevCurrentTiddler,[
			{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
			{opacity: "0.0"},
			{transformOrigin: "0 0"},
			{transform: "translateX(" + x + "px) translateY(" + y + "px) scale(" + scale + ")"},
			{zIndex: "0"}
		]);
		// Hide the tiddler when the transition has finished
		setTimeout(function() {
			if(self.currentTiddlerDomNode !== prevCurrentTiddler) {
				prevCurrentTiddler.style.display = "none";
			}
		},duration);
	}
	// Scroll the target into view
//	$tw.pageScroller.scrollIntoView(targetElement);
};

/*
Find the first child DOM node of a widget that has the class "tc-title"
*/
function findTitleDomNode(widget,targetClass) {
	targetClass = targetClass || "tc-title";
	var domNode = widget.findFirstDomNode();
	if(domNode && domNode.querySelector) {
		return domNode.querySelector("." + targetClass);
	}
	return null;
}

ZoominListView.prototype.insert = function(widget) {
	var targetElement = widget.findFirstDomNode();
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		return;
	}
	// Make the newly inserted node position absolute and hidden
	$tw.utils.addClass(targetElement,"tc-storyview-zoomin-tiddler");
	$tw.utils.setStyle(targetElement,[
		{display: "none"}
	]);
};

ZoominListView.prototype.remove = function(widget) {
	var targetElement = widget.findFirstDomNode(),
		duration = $tw.utils.getAnimationDuration(),
		removeElement = function() {
			widget.removeChildDomNodes();
		};
	// Abandon if the list entry isn't a DOM element (it might be a text node)
	if(!(targetElement instanceof Element)) {
		removeElement();
		return;
	}
	// Abandon if hidden
	if(targetElement.style.display != "block" ) {
		removeElement();
		return;
	}
	// Set up the tiddler that is being closed
	$tw.utils.addClass(targetElement,"tc-storyview-zoomin-tiddler");
	$tw.utils.setStyle(targetElement,[
		{display: "block"},
		{transformOrigin: "50% 50%"},
		{transform: "translateX(0px) translateY(0px) scale(1)"},
		{transition: "none"},
		{zIndex: "0"}
	]);
	// We'll move back to the previous or next element in the story
	var toWidget = widget.previousSibling();
	if(!toWidget) {
		toWidget = widget.nextSibling();
	}
	var toWidgetDomNode = toWidget && toWidget.findFirstDomNode();
	// Set up the tiddler we're moving back in
	if(toWidgetDomNode) {
		$tw.utils.addClass(toWidgetDomNode,"tc-storyview-zoomin-tiddler");
		$tw.utils.setStyle(toWidgetDomNode,[
			{display: "block"},
			{transformOrigin: "50% 50%"},
			{transform: "translateX(0px) translateY(0px) scale(10)"},
			{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
			{opacity: "0"},
			{zIndex: "500"}
		]);
		this.currentTiddlerDomNode = toWidgetDomNode;
	}
	// Animate them both
	// Force layout
	$tw.utils.forceLayout(this.listWidget.parentDomNode);
	// First, the tiddler we're closing
	$tw.utils.setStyle(targetElement,[
		{transformOrigin: "50% 50%"},
		{transform: "translateX(0px) translateY(0px) scale(0.1)"},
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
		{opacity: "0"},
		{zIndex: "0"}
	]);
	setTimeout(removeElement,duration);
	// Now the tiddler we're going back to
	if(toWidgetDomNode) {
		$tw.utils.setStyle(toWidgetDomNode,[
			{transform: "translateX(0px) translateY(0px) scale(1)"},
			{opacity: "1"}
		]);
	}
	return true; // Indicate that we'll delete the DOM node
};

exports.zoomin = ZoominListView;

})();

;})();
return exports;
}));
_define("$:/core/modules/syncer.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/syncer.js
type: application/javascript
module-type: global

The syncer tracks changes to the store. If a syncadaptor is used then individual tiddlers are synchronised through it. If there is no syncadaptor then the entire wiki is saved via saver modules.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Defaults
*/
Syncer.prototype.titleIsLoggedIn = "$:/status/IsLoggedIn";
Syncer.prototype.titleIsAnonymous = "$:/status/IsAnonymous";
Syncer.prototype.titleIsReadOnly = "$:/status/IsReadOnly";
Syncer.prototype.titleUserName = "$:/status/UserName";
Syncer.prototype.titleSyncFilter = "$:/config/SyncFilter";
Syncer.prototype.titleSyncPollingInterval = "$:/config/SyncPollingInterval";
Syncer.prototype.titleSavedNotification = "$:/language/Notifications/Save/Done";
Syncer.prototype.taskTimerInterval = 1 * 1000; // Interval for sync timer
Syncer.prototype.throttleInterval = 1 * 1000; // Defer saving tiddlers if they've changed in the last 1s...
Syncer.prototype.fallbackInterval = 10 * 1000; // Unless the task is older than 10s
Syncer.prototype.pollTimerInterval = 60 * 1000; // Interval for polling for changes from the adaptor

/*
Instantiate the syncer with the following options:
syncadaptor: reference to syncadaptor to be used
wiki: wiki to be synced
*/
function Syncer(options) {
	var self = this;
	this.wiki = options.wiki;
	this.syncadaptor = options.syncadaptor;
	this.disableUI = !!options.disableUI;
	this.titleIsLoggedIn = options.titleIsLoggedIn || this.titleIsLoggedIn;
	this.titleUserName = options.titleUserName || this.titleUserName;
	this.titleSyncFilter = options.titleSyncFilter || this.titleSyncFilter;
	this.titleSavedNotification = options.titleSavedNotification || this.titleSavedNotification;
	this.taskTimerInterval = options.taskTimerInterval || this.taskTimerInterval;
	this.throttleInterval = options.throttleInterval || this.throttleInterval;
	this.fallbackInterval = options.fallbackInterval || this.fallbackInterval;
	this.pollTimerInterval = options.pollTimerInterval || parseInt(this.wiki.getTiddlerText(this.titleSyncPollingInterval,""),10) || this.pollTimerInterval;
	this.logging = "logging" in options ? options.logging : true;
	// Make a logger
	this.logger = new $tw.utils.Logger("syncer" + ($tw.browser ? "-browser" : "") + ($tw.node ? "-server" : "")  + (this.syncadaptor.name ? ("-" + this.syncadaptor.name) : ""),{
			colour: "cyan",
			enable: this.logging
		});
	// Compile the dirty tiddler filter
	this.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter));
	// Record information for known tiddlers
	this.readTiddlerInfo();
	// Tasks are {type: "load"/"save"/"delete", title:, queueTime:, lastModificationTime:}
	this.taskQueue = {}; // Hashmap of tasks yet to be performed
	this.taskInProgress = {}; // Hash of tasks in progress
	this.taskTimerId = null; // Timer for task dispatch
	this.pollTimerId = null; // Timer for polling server
	// Listen out for changes to tiddlers
	this.wiki.addEventListener("change",function(changes) {
		self.syncToServer(changes);
	});
	// Browser event handlers
	if($tw.browser && !this.disableUI) {
		// Set up our beforeunload handler
		$tw.addUnloadTask(function(event) {
			var confirmationMessage;
			if(self.isDirty()) {
				confirmationMessage = $tw.language.getString("UnsavedChangesWarning");
				event.returnValue = confirmationMessage; // Gecko
			}
			return confirmationMessage;
		});
		// Listen out for login/logout/refresh events in the browser
		$tw.rootWidget.addEventListener("tm-login",function() {
			self.handleLoginEvent();
		});
		$tw.rootWidget.addEventListener("tm-logout",function() {
			self.handleLogoutEvent();
		});
		$tw.rootWidget.addEventListener("tm-server-refresh",function() {
			self.handleRefreshEvent();
		});
	}
	// Listen out for lazyLoad events
	if(!this.disableUI) {
		this.wiki.addEventListener("lazyLoad",function(title) {
			self.handleLazyLoadEvent(title);
		});		
	}
	// Get the login status
	this.getStatus(function(err,isLoggedIn) {
		// Do a sync from the server
		self.syncFromServer();
	});
}

/*
Read (or re-read) the latest tiddler info from the store
*/
Syncer.prototype.readTiddlerInfo = function() {
	// Hashmap by title of {revision:,changeCount:,adaptorInfo:}
	this.tiddlerInfo = {};
	// Record information for known tiddlers
	var self = this,
		tiddlers = this.filterFn.call(this.wiki);
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = self.wiki.getTiddler(title);
		self.tiddlerInfo[title] = {
			revision: tiddler.fields.revision,
			adaptorInfo: self.syncadaptor && self.syncadaptor.getTiddlerInfo(tiddler),
			changeCount: self.wiki.getChangeCount(title),
			hasBeenLazyLoaded: false
		};
	});
};

/*
Create an tiddlerInfo structure if it doesn't already exist
*/
Syncer.prototype.createTiddlerInfo = function(title) {
	if(!$tw.utils.hop(this.tiddlerInfo,title)) {
		this.tiddlerInfo[title] = {
			revision: null,
			adaptorInfo: {},
			changeCount: -1,
			hasBeenLazyLoaded: false
		};
	}
};

/*
Checks whether the wiki is dirty (ie the window shouldn't be closed)
*/
Syncer.prototype.isDirty = function() {
	return (this.numTasksInQueue() > 0) || (this.numTasksInProgress() > 0);
};

/*
Update the document body with the class "tc-dirty" if the wiki has unsaved/unsynced changes
*/
Syncer.prototype.updateDirtyStatus = function() {
	if($tw.browser && !this.disableUI) {
		$tw.utils.toggleClass(document.body,"tc-dirty",this.isDirty());
	}
};

/*
Save an incoming tiddler in the store, and updates the associated tiddlerInfo
*/
Syncer.prototype.storeTiddler = function(tiddlerFields,hasBeenLazyLoaded) {
	// Save the tiddler
	var tiddler = new $tw.Tiddler(tiddlerFields);
	this.wiki.addTiddler(tiddler);
	// Save the tiddler revision and changeCount details
	this.tiddlerInfo[tiddlerFields.title] = {
		revision: tiddlerFields.revision,
		adaptorInfo: this.syncadaptor.getTiddlerInfo(tiddler),
		changeCount: this.wiki.getChangeCount(tiddlerFields.title),
		hasBeenLazyLoaded: hasBeenLazyLoaded !== undefined ? hasBeenLazyLoaded : true
	};
};

Syncer.prototype.getStatus = function(callback) {
	var self = this;
	// Check if the adaptor supports getStatus()
	if(this.syncadaptor && this.syncadaptor.getStatus) {
		// Mark us as not logged in
		this.wiki.addTiddler({title: this.titleIsLoggedIn,text: "no"});
		// Get login status
		this.syncadaptor.getStatus(function(err,isLoggedIn,username,isReadOnly,isAnonymous) {
			if(err) {
				self.logger.alert(err);
				return;
			}
			// Set the various status tiddlers
			self.wiki.addTiddler({title: self.titleIsReadOnly,text: isReadOnly ? "yes" : "no"});
			self.wiki.addTiddler({title: self.titleIsAnonymous,text: isAnonymous ? "yes" : "no"});
			self.wiki.addTiddler({title: self.titleIsLoggedIn,text: isLoggedIn ? "yes" : "no"});
			if(isLoggedIn) {
				self.wiki.addTiddler({title: self.titleUserName,text: username || ""});
			}
			// Invoke the callback
			if(callback) {
				callback(err,isLoggedIn,username);
			}
		});
	} else {
		callback(null,true,"UNAUTHENTICATED");
	}
};

/*
Synchronise from the server by reading the skinny tiddler list and queuing up loads for any tiddlers that we don't already have up to date
*/
Syncer.prototype.syncFromServer = function() {
	if(this.syncadaptor && this.syncadaptor.getSkinnyTiddlers) {
		this.logger.log("Retrieving skinny tiddler list");
		var self = this;
		if(this.pollTimerId) {
			clearTimeout(this.pollTimerId);
			this.pollTimerId = null;
		}
		this.syncadaptor.getSkinnyTiddlers(function(err,tiddlers) {
			// Trigger the next sync
			self.pollTimerId = setTimeout(function() {
				self.pollTimerId = null;
				self.syncFromServer.call(self);
			},self.pollTimerInterval);
			// Check for errors
			if(err) {
				self.logger.alert($tw.language.getString("Error/RetrievingSkinny") + ":",err);
				return;
			}
			// Process each incoming tiddler
			for(var t=0; t<tiddlers.length; t++) {
				// Get the incoming tiddler fields, and the existing tiddler
				var tiddlerFields = tiddlers[t],
					incomingRevision = tiddlerFields.revision + "",
					tiddler = self.wiki.getTiddler(tiddlerFields.title),
					tiddlerInfo = self.tiddlerInfo[tiddlerFields.title],
					currRevision = tiddlerInfo ? tiddlerInfo.revision : null;
				// Ignore the incoming tiddler if it's the same as the revision we've already got
				if(currRevision !== incomingRevision) {
					// Do a full load if we've already got a fat version of the tiddler
					if(tiddler && tiddler.fields.text !== undefined) {
						// Do a full load of this tiddler
						self.enqueueSyncTask({
							type: "load",
							title: tiddlerFields.title
						});
					} else {
						// Load the skinny version of the tiddler
						self.storeTiddler(tiddlerFields,false);
					}
				}
			}
		});
	}
};

/*
Synchronise a set of changes to the server
*/
Syncer.prototype.syncToServer = function(changes) {
	var self = this,
		now = Date.now(),
		filteredChanges = this.filterFn.call(this.wiki,function(callback) {
			$tw.utils.each(changes,function(change,title) {
				var tiddler = self.wiki.getTiddler(title);
				callback(tiddler,title);
			});
		});
	$tw.utils.each(changes,function(change,title,object) {
		// Process the change if it is a deletion of a tiddler we're already syncing, or is on the filtered change list
		if((change.deleted && $tw.utils.hop(self.tiddlerInfo,title)) || filteredChanges.indexOf(title) !== -1) {
			// Queue a task to sync this tiddler
			self.enqueueSyncTask({
				type: change.deleted ? "delete" : "save",
				title: title
			});
		}
	});
};

/*
Lazily load a skinny tiddler if we can
*/
Syncer.prototype.handleLazyLoadEvent = function(title) {
	// Don't lazy load the same tiddler twice
	var info = this.tiddlerInfo[title];
	if(!info || !info.hasBeenLazyLoaded) {
		// Don't lazy load if the tiddler isn't included in the sync filter
		if(this.filterFn.call(this.wiki).indexOf(title) !== -1) {
			this.createTiddlerInfo(title);
			this.tiddlerInfo[title].hasBeenLazyLoaded = true;
			// Queue up a sync task to load this tiddler
			this.enqueueSyncTask({
				type: "load",
				title: title
			});
		}
	}
};

/*
Dispay a password prompt and allow the user to login
*/
Syncer.prototype.handleLoginEvent = function() {
	var self = this;
	this.getStatus(function(err,isLoggedIn,username) {
		if(!isLoggedIn) {
			$tw.passwordPrompt.createPrompt({
				serviceName: $tw.language.getString("LoginToTiddlySpace"),
				callback: function(data) {
					self.login(data.username,data.password,function(err,isLoggedIn) {
						self.syncFromServer();
					});
					return true; // Get rid of the password prompt
				}
			});
		}
	});
};

/*
Attempt to login to TiddlyWeb.
	username: username
	password: password
	callback: invoked with arguments (err,isLoggedIn)
*/
Syncer.prototype.login = function(username,password,callback) {
	this.logger.log("Attempting to login as",username);
	var self = this;
	if(this.syncadaptor.login) {
		this.syncadaptor.login(username,password,function(err) {
			if(err) {
				return callback(err);
			}
			self.getStatus(function(err,isLoggedIn,username) {
				if(callback) {
					callback(null,isLoggedIn);
				}
			});
		});
	} else {
		callback(null,true);
	}
};

/*
Attempt to log out of TiddlyWeb
*/
Syncer.prototype.handleLogoutEvent = function() {
	this.logger.log("Attempting to logout");
	var self = this;
	if(this.syncadaptor.logout) {
		this.syncadaptor.logout(function(err) {
			if(err) {
				self.logger.alert(err);
			} else {
				self.getStatus();
			}
		});
	}
};

/*
Immediately refresh from the server
*/
Syncer.prototype.handleRefreshEvent = function() {
	this.syncFromServer();
};

/*
Queue up a sync task. If there is already a pending task for the tiddler, just update the last modification time
*/
Syncer.prototype.enqueueSyncTask = function(task) {
	var self = this,
		now = Date.now();
	// Set the timestamps on this task
	task.queueTime = now;
	task.lastModificationTime = now;
	// Fill in some tiddlerInfo if the tiddler is one we haven't seen before
	this.createTiddlerInfo(task.title);
	// Bail if this is a save and the tiddler is already at the changeCount that the server has
	if(task.type === "save" && this.wiki.getChangeCount(task.title) <= this.tiddlerInfo[task.title].changeCount) {
		return;
	}
	// Check if this tiddler is already in the queue
	if($tw.utils.hop(this.taskQueue,task.title)) {
		// this.logger.log("Re-queueing up sync task with type:",task.type,"title:",task.title);
		var existingTask = this.taskQueue[task.title];
		// If so, just update the last modification time
		existingTask.lastModificationTime = task.lastModificationTime;
		// If the new task is a save then we upgrade the existing task to a save. Thus a pending load is turned into a save if the tiddler changes locally in the meantime. But a pending save is not modified to become a load
		if(task.type === "save" || task.type === "delete") {
			existingTask.type = task.type;
		}
	} else {
		// this.logger.log("Queuing up sync task with type:",task.type,"title:",task.title);
		// If it is not in the queue, insert it
		this.taskQueue[task.title] = task;
		this.updateDirtyStatus();
	}
	// Process the queue
	$tw.utils.nextTick(function() {self.processTaskQueue.call(self);});
};

/*
Return the number of tasks in progress
*/
Syncer.prototype.numTasksInProgress = function() {
	return $tw.utils.count(this.taskInProgress);
};

/*
Return the number of tasks in the queue
*/
Syncer.prototype.numTasksInQueue = function() {
	return $tw.utils.count(this.taskQueue);
};

/*
Trigger a timeout if one isn't already outstanding
*/
Syncer.prototype.triggerTimeout = function() {
	var self = this;
	if(!this.taskTimerId) {
		this.taskTimerId = setTimeout(function() {
			self.taskTimerId = null;
			self.processTaskQueue.call(self);
		},self.taskTimerInterval);
	}
};

/*
Process the task queue, performing the next task if appropriate
*/
Syncer.prototype.processTaskQueue = function() {
	var self = this;
	// Only process a task if the sync adaptor is fully initialised and we're not already performing a task. If we are already performing a task then we'll dispatch the next one when it completes
	if((!this.syncadaptor.isReady || this.syncadaptor.isReady()) && this.numTasksInProgress() === 0) {
		// Choose the next task to perform
		var task = this.chooseNextTask();
		// Perform the task if we had one
		if(task) {
			// Remove the task from the queue and add it to the in progress list
			delete this.taskQueue[task.title];
			this.taskInProgress[task.title] = task;
			this.updateDirtyStatus();
			// Dispatch the task
			this.dispatchTask(task,function(err) {
				if(err) {
					self.logger.alert("Sync error while processing '" + task.title + "':\n" + err);
				}
				// Mark that this task is no longer in progress
				delete self.taskInProgress[task.title];
				self.updateDirtyStatus();
				// Process the next task
				self.processTaskQueue.call(self);
			});
		} else {
			// Make sure we've set a time if there wasn't a task to perform, but we've still got tasks in the queue
			if(this.numTasksInQueue() > 0) {
				this.triggerTimeout();
			}
		}
	}
};

/*
Choose the next applicable task
*/
Syncer.prototype.chooseNextTask = function() {
	var self = this,
		candidateTask = null,
		now = Date.now();
	// Select the best candidate task
	$tw.utils.each(this.taskQueue,function(task,title) {
		// Exclude the task if there's one of the same name in progress
		if($tw.utils.hop(self.taskInProgress,title)) {
			return;
		}
		// Exclude the task if it is a save and the tiddler has been modified recently, but not hit the fallback time
		if(task.type === "save" && (now - task.lastModificationTime) < self.throttleInterval &&
			(now - task.queueTime) < self.fallbackInterval) {
			return;
		}
		// Exclude the task if it is newer than the current best candidate
		if(candidateTask && candidateTask.queueTime < task.queueTime) {
			return;
		}
		// Now this is our best candidate
		candidateTask = task;
	});
	return candidateTask;
};

/*
Dispatch a task and invoke the callback
*/
Syncer.prototype.dispatchTask = function(task,callback) {
	var self = this;
	if(task.type === "save") {
		var changeCount = this.wiki.getChangeCount(task.title),
			tiddler = this.wiki.getTiddler(task.title);
		this.logger.log("Dispatching 'save' task:",task.title);
		if(tiddler) {
			this.syncadaptor.saveTiddler(tiddler,function(err,adaptorInfo,revision) {
				if(err) {
					return callback(err);
				}
				// Adjust the info stored about this tiddler
				self.tiddlerInfo[task.title] = {
					changeCount: changeCount,
					adaptorInfo: adaptorInfo,
					revision: revision
				};
				// Invoke the callback
				callback(null);
			},{
				tiddlerInfo: self.tiddlerInfo[task.title]
			});
		} else {
			this.logger.log(" Not Dispatching 'save' task:",task.title,"tiddler does not exist");
			return callback(null);
		}
	} else if(task.type === "load") {
		// Load the tiddler
		this.logger.log("Dispatching 'load' task:",task.title);
		this.syncadaptor.loadTiddler(task.title,function(err,tiddlerFields) {
			if(err) {
				return callback(err);
			}
			// Store the tiddler
			if(tiddlerFields) {
				self.storeTiddler(tiddlerFields,true);
			}
			// Invoke the callback
			callback(null);
		});
	} else if(task.type === "delete") {
		// Delete the tiddler
		this.logger.log("Dispatching 'delete' task:",task.title);
		this.syncadaptor.deleteTiddler(task.title,function(err) {
			if(err) {
				return callback(err);
			}
			delete self.tiddlerInfo[task.title];
			// Invoke the callback
			callback(null);
		},{
			tiddlerInfo: self.tiddlerInfo[task.title]
		});
	}
};

exports.Syncer = Syncer;

})();

;})();
return exports;
}));
_define("$:/core/modules/tiddler.js","tiddlermethod",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/tiddler.js
type: application/javascript
module-type: tiddlermethod

Extension methods for the $tw.Tiddler object (constructor and methods required at boot time are in boot/boot.js)

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.hasTag = function(tag) {
	return this.fields.tags && this.fields.tags.indexOf(tag) !== -1;
};

exports.isPlugin = function() {
	return this.fields.type === "application/json" && this.hasField("plugin-type");
};

exports.isDraft = function() {
	return this.hasField("draft.of");
};

exports.getFieldString = function(field) {
	var value = this.fields[field];
	// Check for a missing field
	if(value === undefined || value === null) {
		return "";
	}
	// Parse the field with the associated module (if any)
	var fieldModule = $tw.Tiddler.fieldModules[field];
	if(fieldModule && fieldModule.stringify) {
		return fieldModule.stringify.call(this,value);
	} else {
		return value.toString();
	}
};

/*
Get the value of a field as a list
*/
exports.getFieldList = function(field) {
	var value = this.fields[field];
	// Check for a missing field
	if(value === undefined || value === null) {
		return [];
	}
	return $tw.utils.parseStringArray(value);
};

/*
Get all the fields as a hashmap of strings. Options:
	exclude: an array of field names to exclude
*/
exports.getFieldStrings = function(options) {
	options = options || {};
	var exclude = options.exclude || [];
	var fields = {};
	for(var field in this.fields) {
		if($tw.utils.hop(this.fields,field)) {
			if(exclude.indexOf(field) === -1) {
				fields[field] = this.getFieldString(field);
			}
		}
	}
	return fields;
};

/*
Get all the fields as a name:value block. Options:
	exclude: an array of field names to exclude
*/
exports.getFieldStringBlock = function(options) {
	options = options || {};
	var exclude = options.exclude || [],
		fields = Object.keys(this.fields).sort(),
		result = [];
	for(var t=0; t<fields.length; t++) {
		var field = fields[t];
		if(exclude.indexOf(field) === -1) {
			result.push(field + ": " + this.getFieldString(field));
		}
	}
	return result.join("\n");
};

exports.getFieldDay = function(field) {
	if(this.cache && this.cache.day && $tw.utils.hop(this.cache.day,field) ) {
		return this.cache.day[field];
	}
	var day = "";
	if(this.fields[field]) {
		day = (new Date($tw.utils.parseDate(this.fields[field]))).setHours(0,0,0,0);
	}
	this.cache.day = this.cache.day || {};
	this.cache.day[field] = day;
	return day;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/upgraders/plugins.js","upgrader",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/upgraders/plugins.js
type: application/javascript
module-type: upgrader

Upgrader module that checks that plugins are newer than any already installed version

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var UPGRADE_LIBRARY_TITLE = "$:/UpgradeLibrary";

var BLOCKED_PLUGINS = {
	"$:/themes/tiddlywiki/stickytitles": {
		versions: ["*"]
	},
	"$:/plugins/tiddlywiki/fullscreen": {
		versions: ["*"]
	}
};

exports.upgrade = function(wiki,titles,tiddlers) {
	var self = this,
		messages = {},
		upgradeLibrary,
		getLibraryTiddler = function(title) {
			if(!upgradeLibrary) {
				upgradeLibrary = wiki.getTiddlerData(UPGRADE_LIBRARY_TITLE,{});
				upgradeLibrary.tiddlers = upgradeLibrary.tiddlers || {};
			}
			return upgradeLibrary.tiddlers[title];
		};

	// Go through all the incoming tiddlers
	$tw.utils.each(titles,function(title) {
		var incomingTiddler = tiddlers[title];
		// Check if we're dealing with a plugin
		if(incomingTiddler && incomingTiddler["plugin-type"] && incomingTiddler.version) {
			// Upgrade the incoming plugin if it is in the upgrade library
			var libraryTiddler = getLibraryTiddler(title);
			if(libraryTiddler && libraryTiddler["plugin-type"] && libraryTiddler.version) {
				tiddlers[title] = libraryTiddler;
				messages[title] = $tw.language.getString("Import/Upgrader/Plugins/Upgraded",{variables: {incoming: incomingTiddler.version, upgraded: libraryTiddler.version}});
				return;
			}
			// Suppress the incoming plugin if it is older than the currently installed one
			var existingTiddler = wiki.getTiddler(title);
			if(existingTiddler && existingTiddler.hasField("plugin-type") && existingTiddler.hasField("version")) {
				// Reject the incoming plugin by blanking all its fields
				if($tw.utils.checkVersions(existingTiddler.fields.version,incomingTiddler.version)) {
					tiddlers[title] = Object.create(null);
					messages[title] = $tw.language.getString("Import/Upgrader/Plugins/Suppressed/Version",{variables: {incoming: incomingTiddler.version, existing: existingTiddler.fields.version}});
					return;
				}
			}
		}
		if(incomingTiddler && incomingTiddler["plugin-type"]) {
			// Check whether the plugin is on the blocked list
			var blockInfo = BLOCKED_PLUGINS[title];
			if(blockInfo) {
				if(blockInfo.versions.indexOf("*") !== -1 || (incomingTiddler.version && blockInfo.versions.indexOf(incomingTiddler.version) !== -1)) {
					tiddlers[title] = Object.create(null);
					messages[title] = $tw.language.getString("Import/Upgrader/Plugins/Suppressed/Incompatible");
					return;
				}
			}
		}
	});
	return messages;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/upgraders/system.js","upgrader",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/upgraders/system.js
type: application/javascript
module-type: upgrader

Upgrader module that suppresses certain system tiddlers that shouldn't be imported

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var DONT_IMPORT_LIST = ["$:/StoryList","$:/HistoryList"],
	DONT_IMPORT_PREFIX_LIST = ["$:/temp/","$:/state/","$:/Import"],
	WARN_IMPORT_PREFIX_LIST = ["$:/core/modules/"];

exports.upgrade = function(wiki,titles,tiddlers) {
	var self = this,
		messages = {},
		showAlert = false;
	// Check for tiddlers on our list
	$tw.utils.each(titles,function(title) {
		if(DONT_IMPORT_LIST.indexOf(title) !== -1) {
			tiddlers[title] = Object.create(null);
			messages[title] = $tw.language.getString("Import/Upgrader/System/Suppressed");
		} else {
			for(var t=0; t<DONT_IMPORT_PREFIX_LIST.length; t++) {
				var prefix = DONT_IMPORT_PREFIX_LIST[t];
				if(title.substr(0,prefix.length) === prefix) {
					tiddlers[title] = Object.create(null);
					messages[title] = $tw.language.getString("Import/Upgrader/State/Suppressed");
				}
			}
			for(var t=0; t<WARN_IMPORT_PREFIX_LIST.length; t++) {
				var prefix = WARN_IMPORT_PREFIX_LIST[t];
				if(title.substr(0,prefix.length) === prefix) {
					showAlert = true;
					messages[title] = $tw.language.getString("Import/Upgrader/System/Warning");
				}
			}
		}
		if(showAlert) {
			var logger = new $tw.utils.Logger("import");
			logger.alert($tw.language.getString("Import/Upgrader/System/Alert"));
		}
	});
	return messages;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/upgraders/themetweaks.js","upgrader",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/upgraders/themetweaks.js
type: application/javascript
module-type: upgrader

Upgrader module that handles the change in theme tweak storage introduced in 5.0.14-beta.

Previously, theme tweaks were stored in two data tiddlers:

* $:/themes/tiddlywiki/vanilla/metrics
* $:/themes/tiddlywiki/vanilla/settings

Now, each tweak is stored in its own separate tiddler.

This upgrader copies any values from the old format to the new. The old data tiddlers are not deleted in case they have been used to store additional indexes.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var MAPPINGS = {
	"$:/themes/tiddlywiki/vanilla/metrics": {
		"fontsize": "$:/themes/tiddlywiki/vanilla/metrics/fontsize",
		"lineheight": "$:/themes/tiddlywiki/vanilla/metrics/lineheight",
		"storyleft": "$:/themes/tiddlywiki/vanilla/metrics/storyleft",
		"storytop": "$:/themes/tiddlywiki/vanilla/metrics/storytop",
		"storyright": "$:/themes/tiddlywiki/vanilla/metrics/storyright",
		"storywidth": "$:/themes/tiddlywiki/vanilla/metrics/storywidth",
		"tiddlerwidth": "$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth"
	},
	"$:/themes/tiddlywiki/vanilla/settings": {
		"fontfamily": "$:/themes/tiddlywiki/vanilla/settings/fontfamily"
	}
};

exports.upgrade = function(wiki,titles,tiddlers) {
	var self = this,
		messages = {};
	// Check for tiddlers on our list
	$tw.utils.each(titles,function(title) {
		var mapping = MAPPINGS[title];
		if(mapping) {
			var tiddler = new $tw.Tiddler(tiddlers[title]),
				tiddlerData = wiki.getTiddlerDataCached(tiddler,{});
			for(var index in mapping) {
				var mappedTitle = mapping[index];
				if(!tiddlers[mappedTitle] || tiddlers[mappedTitle].title !== mappedTitle) {
					tiddlers[mappedTitle] = {
						title: mappedTitle,
						text: tiddlerData[index]
					};
					messages[mappedTitle] = $tw.language.getString("Import/Upgrader/ThemeTweaks/Created",{variables: {
						from: title + "##" + index
					}});
				}
			}
		}
	});
	return messages;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/base64-utf8/base64-utf8.module.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
(function(){// From https://gist.github.com/Nijikokun/5192472
//
// UTF8 Module
//
// Cleaner and modularized utf-8 encoding and decoding library for javascript.
//
// copyright: MIT
// author: Nijiko Yonskai, @nijikokun, nijikokun@gmail.com
!function(r,e,o,t){void 0!==o.module&&o.module.exports?o.module.exports=e.apply(o):void 0!==o.define&&"function"===o.define&&o.define.amd?define("utf8",[],e):o.utf8=e.apply(o)}(0,function(){return{encode:function(r){if("string"!=typeof r)return r;r=r.replace(/\r\n/g,"\n");for(var e,o="",t=0;t<r.length;t++)(e=r.charCodeAt(t))<128?o+=String.fromCharCode(e):e>127&&e<2048?(o+=String.fromCharCode(e>>6|192),o+=String.fromCharCode(63&e|128)):(o+=String.fromCharCode(e>>12|224),o+=String.fromCharCode(e>>6&63|128),o+=String.fromCharCode(63&e|128));return o},decode:function(r){if("string"!=typeof r)return r;for(var e="",o=0,t=0;o<r.length;)(t=r.charCodeAt(o))<128?(e+=String.fromCharCode(t),o++):t>191&&t<224?(e+=String.fromCharCode((31&t)<<6|63&r.charCodeAt(o+1)),o+=2):(e+=String.fromCharCode((15&t)<<12|(63&r.charCodeAt(o+1))<<6|63&r.charCodeAt(o+2)),o+=3);return e}}},this),function(r,e,o,t){if(void 0!==o.module&&o.module.exports){if(t&&o.require)for(var n=0;n<t.length;n++)o[t[n]]=o.require(t[n]);o.module.exports=e.apply(o)}else void 0!==o.define&&"function"===o.define&&o.define.amd?define("base64",t||[],e):o.base64=e.apply(o)}(0,function(r){var e=r||this.utf8,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";return{encode:function(r){if(void 0===e)throw{error:"MissingMethod",message:"UTF8 Module is missing."};if("string"!=typeof r)return r;r=e.encode(r);for(var t,n,i,d,f,a,h,c="",u=0;u<r.length;)d=(t=r.charCodeAt(u++))>>2,f=(3&t)<<4|(n=r.charCodeAt(u++))>>4,a=(15&n)<<2|(i=r.charCodeAt(u++))>>6,h=63&i,isNaN(n)?a=h=64:isNaN(i)&&(h=64),c+=o.charAt(d)+o.charAt(f)+o.charAt(a)+o.charAt(h);return c},decode:function(r){if(void 0===e)throw{error:"MissingMethod",message:"UTF8 Module is missing."};if("string"!=typeof r)return r;r=r.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(var t,n,i,d,f,a,h="",c=0;c<r.length;)t=o.indexOf(r.charAt(c++))<<2|(d=o.indexOf(r.charAt(c++)))>>4,n=(15&d)<<4|(f=o.indexOf(r.charAt(c++)))>>2,i=(3&f)<<6|(a=o.indexOf(r.charAt(c++))),h+=String.fromCharCode(t),64!=f&&(h+=String.fromCharCode(n)),64!=a&&(h+=String.fromCharCode(i));return e.decode(h)}}},this,["utf8"]);}).call(exports);
;})();
return exports;
}));
_define("$:/core/modules/utils/crypto.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/crypto.js
type: application/javascript
module-type: utils

Utility functions related to crypto.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Look for an encrypted store area in the text of a TiddlyWiki file
*/
exports.extractEncryptedStoreArea = function(text) {
	var encryptedStoreAreaStartMarker = "<pre id=\"encryptedStoreArea\" type=\"text/plain\" style=\"display:none;\">",
		encryptedStoreAreaStart = text.indexOf(encryptedStoreAreaStartMarker);
	if(encryptedStoreAreaStart !== -1) {
		var encryptedStoreAreaEnd = text.indexOf("</pre>",encryptedStoreAreaStart);
		if(encryptedStoreAreaEnd !== -1) {
			return $tw.utils.htmlDecode(text.substring(encryptedStoreAreaStart + encryptedStoreAreaStartMarker.length,encryptedStoreAreaEnd-1));
		}
	}
	return null;
};

/*
Attempt to extract the tiddlers from an encrypted store area using the current password. If the password is not provided then the password in the password store will be used
*/
exports.decryptStoreArea = function(encryptedStoreArea,password) {
	var decryptedText = $tw.crypto.decrypt(encryptedStoreArea,password);
	if(decryptedText) {
		var json = JSON.parse(decryptedText),
			tiddlers = [];
		for(var title in json) {
			if(title !== "$:/isEncrypted") {
				tiddlers.push(json[title]);
			}
		}
		return tiddlers;
	} else {
		return null;
	}
};


/*
Attempt to extract the tiddlers from an encrypted store area using the current password. If that fails, the user is prompted for a password.
encryptedStoreArea: text of the TiddlyWiki encrypted store area
callback: function(tiddlers) called with the array of decrypted tiddlers

The following configuration settings are supported:

$tw.config.usePasswordVault: causes any password entered by the user to also be put into the system password vault
*/
exports.decryptStoreAreaInteractive = function(encryptedStoreArea,callback,options) {
	// Try to decrypt with the current password
	var tiddlers = $tw.utils.decryptStoreArea(encryptedStoreArea);
	if(tiddlers) {
		callback(tiddlers);
	} else {
		// Prompt for a new password and keep trying
		$tw.passwordPrompt.createPrompt({
			serviceName: "Enter a password to decrypt the imported TiddlyWiki",
			noUserName: true,
			canCancel: true,
			submitText: "Decrypt",
			callback: function(data) {
				// Exit if the user cancelled
				if(!data) {
					return false;
				}
				// Attempt to decrypt the tiddlers
				var tiddlers = $tw.utils.decryptStoreArea(encryptedStoreArea,data.password);
				if(tiddlers) {
					if($tw.config.usePasswordVault) {
						$tw.crypto.setPassword(data.password);
					}
					callback(tiddlers);
					// Exit and remove the password prompt
					return true;
				} else {
					// We didn't decrypt everything, so continue to prompt for password
					return false;
				}
			}
		});
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/csv.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/csv.js
type: application/javascript
module-type: utils

A barebones CSV parser

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Parse a CSV string with a header row and return an array of hashmaps.
*/
exports.parseCsvStringWithHeader = function(text,options) {
	options = options || {};
	var separator = options.separator || ",",
		rows = text.split(/\r?\n/mg).map(function(row) {
			return $tw.utils.trim(row);
		}).filter(function(row) {
			return row !== "";
		});
	if(rows.length < 1) {
		return "Missing header row";
	}
	var headings = rows[0].split(separator),
		results = [];
	for(var row=1; row<rows.length; row++) {
		var columns = rows[row].split(separator),
			columnResult = Object.create(null);
		if(columns.length !== headings.length) {
			return "Malformed CSV row '" + rows[row] + "'";
		}
		for(var column=0; column<columns.length; column++) {
			var columnName = headings[column];
			columnResult[columnName] = $tw.utils.trim(columns[column] || "");
		}
		results.push(columnResult);			
	}
	return results;
}

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/diff-match-patch/diff_match_patch.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
(function(){function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=.5;this.Patch_Margin=4;this.Match_MaxBits=32}var DIFF_DELETE=-1,DIFF_INSERT=1,DIFF_EQUAL=0;
diff_match_patch.prototype.diff_main=function(a,b,c,d){"undefined"==typeof d&&(d=0>=this.Diff_Timeout?Number.MAX_VALUE:(new Date).getTime()+1E3*this.Diff_Timeout);if(null==a||null==b)throw Error("Null input. (diff_main)");if(a==b)return a?[[DIFF_EQUAL,a]]:[];"undefined"==typeof c&&(c=!0);var e=c,f=this.diff_commonPrefix(a,b);c=a.substring(0,f);a=a.substring(f);b=b.substring(f);f=this.diff_commonSuffix(a,b);var g=a.substring(a.length-f);a=a.substring(0,a.length-f);b=b.substring(0,b.length-f);a=this.diff_compute_(a,
b,e,d);c&&a.unshift([DIFF_EQUAL,c]);g&&a.push([DIFF_EQUAL,g]);this.diff_cleanupMerge(a);return a};
diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[DIFF_INSERT,b]];if(!b)return[[DIFF_DELETE,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);return-1!=g?(c=[[DIFF_INSERT,e.substring(0,g)],[DIFF_EQUAL,f],[DIFF_INSERT,e.substring(g+f.length)]],a.length>b.length&&(c[0][0]=c[2][0]=DIFF_DELETE),c):1==f.length?[[DIFF_DELETE,a],[DIFF_INSERT,b]]:(e=this.diff_halfMatch_(a,b))?(b=e[1],f=e[3],a=e[4],e=this.diff_main(e[0],e[2],c,d),c=this.diff_main(b,f,c,d),e.concat([[DIFF_EQUAL,
a]],c)):c&&100<a.length&&100<b.length?this.diff_lineMode_(a,b,d):this.diff_bisect_(a,b,d)};
diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b);a=d.chars1;b=d.chars2;d=d.lineArray;a=this.diff_main(a,b,!1,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([DIFF_EQUAL,""]);for(var e=d=b=0,f="",g="";b<a.length;){switch(a[b][0]){case DIFF_INSERT:e++;g+=a[b][1];break;case DIFF_DELETE:d++;f+=a[b][1];break;case DIFF_EQUAL:if(1<=d&&1<=e){a.splice(b-d-e,d+e);b=b-d-e;d=this.diff_main(f,g,!1,c);for(e=d.length-1;0<=e;e--)a.splice(b,0,d[e]);b+=
d.length}d=e=0;g=f=""}b++}a.pop();return a};
diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=2*f,h=Array(g),l=Array(g),k=0;k<g;k++)h[k]=-1,l[k]=-1;h[f+1]=0;l[f+1]=0;k=d-e;for(var m=0!=k%2,p=0,x=0,w=0,q=0,t=0;t<f&&!((new Date).getTime()>c);t++){for(var v=-t+p;v<=t-x;v+=2){var n=f+v;var r=v==-t||v!=t&&h[n-1]<h[n+1]?h[n+1]:h[n-1]+1;for(var y=r-v;r<d&&y<e&&a.charAt(r)==b.charAt(y);)r++,y++;h[n]=r;if(r>d)x+=2;else if(y>e)p+=2;else if(m&&(n=f+k-v,0<=n&&n<g&&-1!=l[n])){var u=d-l[n];if(r>=
u)return this.diff_bisectSplit_(a,b,r,y,c)}}for(v=-t+w;v<=t-q;v+=2){n=f+v;u=v==-t||v!=t&&l[n-1]<l[n+1]?l[n+1]:l[n-1]+1;for(r=u-v;u<d&&r<e&&a.charAt(d-u-1)==b.charAt(e-r-1);)u++,r++;l[n]=u;if(u>d)q+=2;else if(r>e)w+=2;else if(!m&&(n=f+k-v,0<=n&&n<g&&-1!=h[n]&&(r=h[n],y=f+r-n,u=d-u,r>=u)))return this.diff_bisectSplit_(a,b,r,y,c)}}return[[DIFF_DELETE,a],[DIFF_INSERT,b]]};
diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d);a=a.substring(c);b=b.substring(d);f=this.diff_main(f,g,!1,e);e=this.diff_main(a,b,!1,e);return f.concat(e)};
diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(a){for(var b="",c=0,f=-1,g=d.length;f<a.length-1;){f=a.indexOf("\n",c);-1==f&&(f=a.length-1);var h=a.substring(c,f+1);c=f+1;(e.hasOwnProperty?e.hasOwnProperty(h):void 0!==e[h])?b+=String.fromCharCode(e[h]):(b+=String.fromCharCode(g),e[h]=g,d[g++]=h)}return b}var d=[],e={};d[0]="";var f=c(a),g=c(b);return{chars1:f,chars2:g,lineArray:d}};
diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(f,e)==b.substring(f,e)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(0==c||0==d)return 0;c>d?a=a.substring(c-d):c<d&&(b=b.substring(0,c));c=Math.min(c,d);if(a==b)return c;d=0;for(var e=1;;){var f=a.substring(c-e);f=b.indexOf(f);if(-1==f)return d;e+=f;if(0==f||a.substring(c-e)==b.substring(0,e))d=e,e++}};
diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(a,b,c){for(var d=a.substring(c,c+Math.floor(a.length/4)),e=-1,g="",h,k,l,m;-1!=(e=b.indexOf(d,e+1));){var p=f.diff_commonPrefix(a.substring(c),b.substring(e)),u=f.diff_commonSuffix(a.substring(0,c),b.substring(0,e));g.length<u+p&&(g=b.substring(e-u,e)+b.substring(e,e+p),h=a.substring(0,c-u),k=a.substring(c+p),l=b.substring(0,e-u),m=b.substring(e+p))}return 2*g.length>=a.length?[h,k,l,m,g]:null}if(0>=this.Diff_Timeout)return null;
var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(4>d.length||2*e.length<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4));d=c(d,e,Math.ceil(d.length/2));if(g||d)g=d?g?g[4].length>d[4].length?g:d:d:g;else return null;if(a.length>b.length){d=g[0];e=g[1];var h=g[2];var l=g[3]}else h=g[0],l=g[1],d=g[2],e=g[3];return[d,e,h,l,g[4]]};
diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=0,h=0,l=0,k=0;f<a.length;)a[f][0]==DIFF_EQUAL?(c[d++]=f,g=l,h=k,k=l=0,e=a[f][1]):(a[f][0]==DIFF_INSERT?l+=a[f][1].length:k+=a[f][1].length,e&&e.length<=Math.max(g,h)&&e.length<=Math.max(l,k)&&(a.splice(c[d-1],0,[DIFF_DELETE,e]),a[c[d-1]+1][0]=DIFF_INSERT,d--,d--,f=0<d?c[d-1]:-1,k=l=h=g=0,e=null,b=!0)),f++;b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(a[f-1][0]==
DIFF_DELETE&&a[f][0]==DIFF_INSERT){b=a[f-1][1];c=a[f][1];d=this.diff_commonOverlap_(b,c);e=this.diff_commonOverlap_(c,b);if(d>=e){if(d>=b.length/2||d>=c.length/2)a.splice(f,0,[DIFF_EQUAL,c.substring(0,d)]),a[f-1][1]=b.substring(0,b.length-d),a[f+1][1]=c.substring(d),f++}else if(e>=b.length/2||e>=c.length/2)a.splice(f,0,[DIFF_EQUAL,b.substring(0,e)]),a[f-1][0]=DIFF_INSERT,a[f-1][1]=c.substring(0,c.length-e),a[f+1][0]=DIFF_DELETE,a[f+1][1]=b.substring(e),f++;f++}f++}};
diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(a,b){if(!a||!b)return 6;var c=a.charAt(a.length-1),d=b.charAt(0),e=c.match(diff_match_patch.nonAlphaNumericRegex_),f=d.match(diff_match_patch.nonAlphaNumericRegex_),g=e&&c.match(diff_match_patch.whitespaceRegex_),h=f&&d.match(diff_match_patch.whitespaceRegex_);c=g&&c.match(diff_match_patch.linebreakRegex_);d=h&&d.match(diff_match_patch.linebreakRegex_);var k=c&&a.match(diff_match_patch.blanklineEndRegex_),l=d&&b.match(diff_match_patch.blanklineStartRegex_);
return k||l?5:c||d?4:e&&!g&&h?3:g||h?2:e||f?1:0}for(var c=1;c<a.length-1;){if(a[c-1][0]==DIFF_EQUAL&&a[c+1][0]==DIFF_EQUAL){var d=a[c-1][1],e=a[c][1],f=a[c+1][1],g=this.diff_commonSuffix(d,e);if(g){var h=e.substring(e.length-g);d=d.substring(0,d.length-g);e=h+e.substring(0,e.length-g);f=h+f}g=d;h=e;for(var l=f,k=b(d,e)+b(e,f);e.charAt(0)===f.charAt(0);){d+=e.charAt(0);e=e.substring(1)+f.charAt(0);f=f.substring(1);var m=b(d,e)+b(e,f);m>=k&&(k=m,g=d,h=e,l=f)}a[c-1][1]!=g&&(g?a[c-1][1]=g:(a.splice(c-
1,1),c--),a[c][1]=h,l?a[c+1][1]=l:(a.splice(c+1,1),c--))}c++}};diff_match_patch.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/;diff_match_patch.whitespaceRegex_=/\s/;diff_match_patch.linebreakRegex_=/[\r\n]/;diff_match_patch.blanklineEndRegex_=/\n\r?\n$/;diff_match_patch.blanklineStartRegex_=/^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=!1,h=!1,l=!1,k=!1;f<a.length;)a[f][0]==DIFF_EQUAL?(a[f][1].length<this.Diff_EditCost&&(l||k)?(c[d++]=f,g=l,h=k,e=a[f][1]):(d=0,e=null),l=k=!1):(a[f][0]==DIFF_DELETE?k=!0:l=!0,e&&(g&&h&&l&&k||e.length<this.Diff_EditCost/2&&3==g+h+l+k)&&(a.splice(c[d-1],0,[DIFF_DELETE,e]),a[c[d-1]+1][0]=DIFF_INSERT,d--,e=null,g&&h?(l=k=!0,d=0):(d--,f=0<d?c[d-1]:-1,l=k=!1),b=!0)),f++;b&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([DIFF_EQUAL,""]);for(var b=0,c=0,d=0,e="",f="",g;b<a.length;)switch(a[b][0]){case DIFF_INSERT:d++;f+=a[b][1];b++;break;case DIFF_DELETE:c++;e+=a[b][1];b++;break;case DIFF_EQUAL:1<c+d?(0!==c&&0!==d&&(g=this.diff_commonPrefix(f,e),0!==g&&(0<b-c-d&&a[b-c-d-1][0]==DIFF_EQUAL?a[b-c-d-1][1]+=f.substring(0,g):(a.splice(0,0,[DIFF_EQUAL,f.substring(0,g)]),b++),f=f.substring(g),e=e.substring(g)),g=this.diff_commonSuffix(f,e),0!==g&&(a[b][1]=f.substring(f.length-
g)+a[b][1],f=f.substring(0,f.length-g),e=e.substring(0,e.length-g))),0===c?a.splice(b-d,c+d,[DIFF_INSERT,f]):0===d?a.splice(b-c,c+d,[DIFF_DELETE,e]):a.splice(b-c-d,c+d,[DIFF_DELETE,e],[DIFF_INSERT,f]),b=b-c-d+(c?1:0)+(d?1:0)+1):0!==b&&a[b-1][0]==DIFF_EQUAL?(a[b-1][1]+=a[b][1],a.splice(b,1)):b++,c=d=0,f=e=""}""===a[a.length-1][1]&&a.pop();c=!1;for(b=1;b<a.length-1;)a[b-1][0]==DIFF_EQUAL&&a[b+1][0]==DIFF_EQUAL&&(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]?(a[b][1]=a[b-1][1]+a[b][1].substring(0,
a[b][1].length-a[b-1][1].length),a[b+1][1]=a[b-1][1]+a[b+1][1],a.splice(b-1,1),c=!0):a[b][1].substring(0,a[b+1][1].length)==a[b+1][1]&&(a[b-1][1]+=a[b+1][1],a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1],a.splice(b+1,1),c=!0)),b++;c&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){a[g][0]!==DIFF_INSERT&&(c+=a[g][1].length);a[g][0]!==DIFF_DELETE&&(d+=a[g][1].length);if(c>b)break;e=c;f=d}return a.length!=g&&a[g][0]===DIFF_DELETE?f:f+(b-e)};
diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=/&/g,d=/</g,e=/>/g,f=/\n/g,g=0;g<a.length;g++){var h=a[g][0],l=a[g][1].replace(c,"&amp;").replace(d,"&lt;").replace(e,"&gt;").replace(f,"&para;<br>");switch(h){case DIFF_INSERT:b[g]='<ins style="background:#e6ffe6;">'+l+"</ins>";break;case DIFF_DELETE:b[g]='<del style="background:#ffe6e6;">'+l+"</del>";break;case DIFF_EQUAL:b[g]="<span>"+l+"</span>"}}return b.join("")};
diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)a[c][0]!==DIFF_INSERT&&(b[c]=a[c][1]);return b.join("")};diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)a[c][0]!==DIFF_DELETE&&(b[c]=a[c][1]);return b.join("")};
diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][1];switch(a[e][0]){case DIFF_INSERT:c+=f.length;break;case DIFF_DELETE:d+=f.length;break;case DIFF_EQUAL:b+=Math.max(c,d),d=c=0}}return b+=Math.max(c,d)};
diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case DIFF_INSERT:b[c]="+"+encodeURI(a[c][1]);break;case DIFF_DELETE:b[c]="-"+a[c][1].length;break;case DIFF_EQUAL:b[c]="="+a[c][1].length}return b.join("\t").replace(/%20/g," ")};
diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case "+":try{c[d++]=[DIFF_INSERT,decodeURI(h)]}catch(k){throw Error("Illegal escape in diff_fromDelta: "+h);}break;case "-":case "=":var l=parseInt(h,10);if(isNaN(l)||0>l)throw Error("Invalid number in diff_fromDelta: "+h);h=a.substring(e,e+=l);"="==f[g].charAt(0)?c[d++]=[DIFF_EQUAL,h]:c[d++]=[DIFF_DELETE,h];break;default:if(f[g])throw Error("Invalid diff operation in diff_fromDelta: "+
f[g]);}}if(e!=a.length)throw Error("Delta length ("+e+") does not equal source text length ("+a.length+").");return c};diff_match_patch.prototype.match_main=function(a,b,c){if(null==a||null==b||null==c)throw Error("Null input. (match_main)");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};
diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(a,d){var e=a/b.length,g=Math.abs(c-d);return f.Match_Distance?e+g/f.Match_Distance:g?1:e}if(b.length>this.Match_MaxBits)throw Error("Pattern too long for this browser.");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);-1!=h&&(g=Math.min(d(0,h),g),h=a.lastIndexOf(b,c+b.length),-1!=h&&(g=Math.min(d(0,h),g)));var l=1<<b.length-1;h=-1;for(var k,m,p=b.length+a.length,x,w=0;w<b.length;w++){k=0;for(m=p;k<m;)d(w,
c+m)<=g?k=m:p=m,m=Math.floor((p-k)/2+k);p=m;k=Math.max(1,c-m+1);var q=Math.min(c+m,a.length)+b.length;m=Array(q+2);for(m[q+1]=(1<<w)-1;q>=k;q--){var t=e[a.charAt(q-1)];m[q]=0===w?(m[q+1]<<1|1)&t:(m[q+1]<<1|1)&t|(x[q+1]|x[q])<<1|1|x[q+1];if(m[q]&l&&(t=d(w,q-1),t<=g))if(g=t,h=q-1,h>c)k=Math.max(1,2*c-h);else break}if(d(w+1,c)>g)break;x=m}return h};
diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};
diff_match_patch.prototype.patch_addContext_=function(a,b){if(0!=b.length){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)d+=this.Patch_Margin,c=b.substring(a.start2-d,a.start2+a.length1+d);d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([DIFF_EQUAL,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([DIFF_EQUAL,d]);a.start1-=c.length;a.start2-=
c.length;a.length1+=c.length+d.length;a.length2+=c.length+d.length}};
diff_match_patch.prototype.patch_make=function(a,b,c){if("string"==typeof a&&"string"==typeof b&&"undefined"==typeof c){var d=a;b=this.diff_main(d,b,!0);2<b.length&&(this.diff_cleanupSemantic(b),this.diff_cleanupEfficiency(b))}else if(a&&"object"==typeof a&&"undefined"==typeof b&&"undefined"==typeof c)b=a,d=this.diff_text1(b);else if("string"==typeof a&&b&&"object"==typeof b&&"undefined"==typeof c)d=a;else if("string"==typeof a&&"string"==typeof b&&c&&"object"==typeof c)d=a,b=c;else throw Error("Unknown call format to patch_make.");
if(0===b.length)return[];c=[];a=new diff_match_patch.patch_obj;for(var e=0,f=0,g=0,h=d,l=0;l<b.length;l++){var k=b[l][0],m=b[l][1];e||k===DIFF_EQUAL||(a.start1=f,a.start2=g);switch(k){case DIFF_INSERT:a.diffs[e++]=b[l];a.length2+=m.length;d=d.substring(0,g)+m+d.substring(g);break;case DIFF_DELETE:a.length1+=m.length;a.diffs[e++]=b[l];d=d.substring(0,g)+d.substring(g+m.length);break;case DIFF_EQUAL:m.length<=2*this.Patch_Margin&&e&&b.length!=l+1?(a.diffs[e++]=b[l],a.length1+=m.length,a.length2+=m.length):
m.length>=2*this.Patch_Margin&&e&&(this.patch_addContext_(a,h),c.push(a),a=new diff_match_patch.patch_obj,e=0,h=d,f=g)}k!==DIFF_INSERT&&(f+=m.length);k!==DIFF_DELETE&&(g+=m.length)}e&&(this.patch_addContext_(a,h),c.push(a));return c};
diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new diff_match_patch.patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};
diff_match_patch.prototype.patch_apply=function(a,b){if(0==a.length)return[b,[]];a=this.patch_deepCopy(a);var c=this.patch_addPadding(a);b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),l=-1;if(h.length>this.Match_MaxBits){var k=this.match_main(b,h.substring(0,this.Match_MaxBits),g);-1!=k&&(l=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits),-1==l||k>=l)&&(k=-1)}else k=this.match_main(b,h,
g);if(-1==k)e[f]=!1,d-=a[f].length2-a[f].length1;else if(e[f]=!0,d=k-g,g=-1==l?b.substring(k,k+h.length):b.substring(k,l+this.Match_MaxBits),h==g)b=b.substring(0,k)+this.diff_text2(a[f].diffs)+b.substring(k+h.length);else if(g=this.diff_main(h,g,!1),h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=!1;else{this.diff_cleanupSemanticLossless(g);h=0;var m;for(l=0;l<a[f].diffs.length;l++){var p=a[f].diffs[l];p[0]!==DIFF_EQUAL&&(m=this.diff_xIndex(g,h));p[0]===
DIFF_INSERT?b=b.substring(0,k+m)+p[1]+b.substring(k+m):p[0]===DIFF_DELETE&&(b=b.substring(0,k+m)+b.substring(k+this.diff_xIndex(g,h+p[1].length)));p[0]!==DIFF_DELETE&&(h+=p[1].length)}}}b=b.substring(c.length,b.length-c.length);return[b,e]};
diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++)a[d].start1+=b,a[d].start2+=b;d=a[0];var e=d.diffs;if(0==e.length||e[0][0]!=DIFF_EQUAL)e.unshift([DIFF_EQUAL,c]),d.start1-=b,d.start2-=b,d.length1+=b,d.length2+=b;else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;0==e.length||e[e.length-
1][0]!=DIFF_EQUAL?(e.push([DIFF_EQUAL,c]),d.length1+=b,d.length2+=b):b>e[e.length-1][1].length&&(f=b-e[e.length-1][1].length,e[e.length-1][1]+=c.substring(0,f),d.length1+=f,d.length2+=f);return c};
diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(!(a[c].length1<=b)){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="";0!==d.diffs.length;){var h=new diff_match_patch.patch_obj,l=!0;h.start1=e-g.length;h.start2=f-g.length;""!==g&&(h.length1=h.length2=g.length,h.diffs.push([DIFF_EQUAL,g]));for(;0!==d.diffs.length&&h.length1<b-this.Patch_Margin;){g=d.diffs[0][0];var k=d.diffs[0][1];g===DIFF_INSERT?(h.length2+=k.length,f+=k.length,h.diffs.push(d.diffs.shift()),
l=!1):g===DIFF_DELETE&&1==h.diffs.length&&h.diffs[0][0]==DIFF_EQUAL&&k.length>2*b?(h.length1+=k.length,e+=k.length,l=!1,h.diffs.push([g,k]),d.diffs.shift()):(k=k.substring(0,b-h.length1-this.Patch_Margin),h.length1+=k.length,e+=k.length,g===DIFF_EQUAL?(h.length2+=k.length,f+=k.length):l=!1,h.diffs.push([g,k]),k==d.diffs[0][1]?d.diffs.shift():d.diffs[0][1]=d.diffs[0][1].substring(k.length))}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);k=this.diff_text1(d.diffs).substring(0,
this.Patch_Margin);""!==k&&(h.length1+=k.length,h.length2+=k.length,0!==h.diffs.length&&h.diffs[h.diffs.length-1][0]===DIFF_EQUAL?h.diffs[h.diffs.length-1][1]+=k:h.diffs.push([DIFF_EQUAL,k]));l||a.splice(++c,0,h)}}};diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("")};
diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;a=a.split("\n");for(var c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error("Invalid patch string: "+a[c]);var f=new diff_match_patch.patch_obj;b.push(f);f.start1=parseInt(e[1],10);""===e[2]?(f.start1--,f.length1=1):"0"==e[2]?f.length1=0:(f.start1--,f.length1=parseInt(e[2],10));f.start2=parseInt(e[3],10);""===e[4]?(f.start2--,f.length2=1):"0"==e[4]?f.length2=0:(f.start2--,f.length2=
parseInt(e[4],10));for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error("Illegal escape in patch_fromText: "+g);}if("-"==e)f.diffs.push([DIFF_DELETE,g]);else if("+"==e)f.diffs.push([DIFF_INSERT,g]);else if(" "==e)f.diffs.push([DIFF_EQUAL,g]);else if("@"==e)break;else if(""!==e)throw Error('Invalid patch mode "'+e+'" in: '+g);c++}}return b};diff_match_patch.patch_obj=function(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0};
diff_match_patch.patch_obj.prototype.toString=function(){for(var a=["@@ -"+(0===this.length1?this.start1+",0":1==this.length1?this.start1+1:this.start1+1+","+this.length1)+" +"+(0===this.length2?this.start2+",0":1==this.length2?this.start2+1:this.start2+1+","+this.length2)+" @@\n"],b,c=0;c<this.diffs.length;c++){switch(this.diffs[c][0]){case DIFF_INSERT:b="+";break;case DIFF_DELETE:b="-";break;case DIFF_EQUAL:b=" "}a[c+1]=b+encodeURI(this.diffs[c][1])+"\n"}return a.join("").replace(/%20/g," ")};
this.diff_match_patch=diff_match_patch;this.DIFF_DELETE=DIFF_DELETE;this.DIFF_INSERT=DIFF_INSERT;this.DIFF_EQUAL=DIFF_EQUAL;
}).call(exports);
;})();
return exports;
}));
_define("$:/core/modules/utils/dom/animations/slide.js","animation",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/animations/slide.js
type: application/javascript
module-type: animation

A simple slide animation that varies the height of the element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

function slideOpen(domNode,options) {
	options = options || {};
	var duration = options.duration || $tw.utils.getAnimationDuration();
	// Get the current height of the domNode
	var computedStyle = window.getComputedStyle(domNode),
		currMarginBottom = parseInt(computedStyle.marginBottom,10),
		currMarginTop = parseInt(computedStyle.marginTop,10),
		currPaddingBottom = parseInt(computedStyle.paddingBottom,10),
		currPaddingTop = parseInt(computedStyle.paddingTop,10),
		currHeight = domNode.offsetHeight;
	// Reset the margin once the transition is over
	setTimeout(function() {
		$tw.utils.setStyle(domNode,[
			{transition: "none"},
			{marginBottom: ""},
			{marginTop: ""},
			{paddingBottom: ""},
			{paddingTop: ""},
			{height: "auto"},
			{opacity: ""}
		]);
		if(options.callback) {
			options.callback();
		}
	},duration);
	// Set up the initial position of the element
	$tw.utils.setStyle(domNode,[
		{transition: "none"},
		{marginTop: "0px"},
		{marginBottom: "0px"},
		{paddingTop: "0px"},
		{paddingBottom: "0px"},
		{height: "0px"},
		{opacity: "0"}
	]);
	$tw.utils.forceLayout(domNode);
	// Transition to the final position
	$tw.utils.setStyle(domNode,[
		{transition: "margin-top " + duration + "ms ease-in-out, " +
					"margin-bottom " + duration + "ms ease-in-out, " +
					"padding-top " + duration + "ms ease-in-out, " +
					"padding-bottom " + duration + "ms ease-in-out, " +
					"height " + duration + "ms ease-in-out, " +
					"opacity " + duration + "ms ease-in-out"},
		{marginBottom: currMarginBottom + "px"},
		{marginTop: currMarginTop + "px"},
		{paddingBottom: currPaddingBottom + "px"},
		{paddingTop: currPaddingTop + "px"},
		{height: currHeight + "px"},
		{opacity: "1"}
	]);
}

function slideClosed(domNode,options) {
	options = options || {};
	var duration = options.duration || $tw.utils.getAnimationDuration(),
		currHeight = domNode.offsetHeight;
	// Clear the properties we've set when the animation is over
	setTimeout(function() {
		$tw.utils.setStyle(domNode,[
			{transition: "none"},
			{marginBottom: ""},
			{marginTop: ""},
			{paddingBottom: ""},
			{paddingTop: ""},
			{height: "auto"},
			{opacity: ""}
		]);
		if(options.callback) {
			options.callback();
		}
	},duration);
	// Set up the initial position of the element
	$tw.utils.setStyle(domNode,[
		{height: currHeight + "px"},
		{opacity: "1"}
	]);
	$tw.utils.forceLayout(domNode);
	// Transition to the final position
	$tw.utils.setStyle(domNode,[
		{transition: "margin-top " + duration + "ms ease-in-out, " +
					"margin-bottom " + duration + "ms ease-in-out, " +
					"padding-top " + duration + "ms ease-in-out, " +
					"padding-bottom " + duration + "ms ease-in-out, " +
					"height " + duration + "ms ease-in-out, " +
					"opacity " + duration + "ms ease-in-out"},
		{marginTop: "0px"},
		{marginBottom: "0px"},
		{paddingTop: "0px"},
		{paddingBottom: "0px"},
		{height: "0px"},
		{opacity: "0"}
	]);
}

exports.slide = {
	open: slideOpen,
	close: slideClosed
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/animator.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/animator.js
type: application/javascript
module-type: utils

Orchestrates animations and transitions

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

function Animator() {
	// Get the registered animation modules
	this.animations = {};
	$tw.modules.applyMethods("animation",this.animations);
}

Animator.prototype.perform = function(type,domNode,options) {
	options = options || {};
	// Find an animation that can handle this type
	var chosenAnimation;
	$tw.utils.each(this.animations,function(animation,name) {
		if($tw.utils.hop(animation,type)) {
			chosenAnimation = animation[type];
		}
	});
	if(!chosenAnimation) {
		chosenAnimation = function(domNode,options) {
			if(options.callback) {
				options.callback();
			}
		};
	}
	// Call the animation
	chosenAnimation(domNode,options);
};

exports.Animator = Animator;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/browser.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/browser.js
type: application/javascript
module-type: utils

Browser feature detection

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Set style properties of an element
	element: dom node
	styles: ordered array of {name: value} pairs
*/
exports.setStyle = function(element,styles) {
	if(element.nodeType === 1) { // Element.ELEMENT_NODE
		for(var t=0; t<styles.length; t++) {
			for(var styleName in styles[t]) {
				element.style[$tw.utils.convertStyleNameToPropertyName(styleName)] = styles[t][styleName];
			}
		}
	}
};

/*
Converts a standard CSS property name into the local browser-specific equivalent. For example:
	"background-color" --> "backgroundColor"
	"transition" --> "webkitTransition"
*/

var styleNameCache = {}; // We'll cache the style name conversions

exports.convertStyleNameToPropertyName = function(styleName) {
	// Return from the cache if we can
	if(styleNameCache[styleName]) {
		return styleNameCache[styleName];
	}
	// Convert it by first removing any hyphens
	var propertyName = $tw.utils.unHyphenateCss(styleName);
	// Then check if it needs a prefix
	if($tw.browser && document.body.style[propertyName] === undefined) {
		var prefixes = ["O","MS","Moz","webkit"];
		for(var t=0; t<prefixes.length; t++) {
			var prefixedName = prefixes[t] + propertyName.substr(0,1).toUpperCase() + propertyName.substr(1);
			if(document.body.style[prefixedName] !== undefined) {
				propertyName = prefixedName;
				break;
			}
		}
	}
	// Put it in the cache too
	styleNameCache[styleName] = propertyName;
	return propertyName;
};

/*
Converts a JS format CSS property name back into the dashed form used in CSS declarations. For example:
	"backgroundColor" --> "background-color"
	"webkitTransform" --> "-webkit-transform"
*/
exports.convertPropertyNameToStyleName = function(propertyName) {
	// Rehyphenate the name
	var styleName = $tw.utils.hyphenateCss(propertyName);
	// If there's a webkit prefix, add a dash (other browsers have uppercase prefixes, and so get the dash automatically)
	if(styleName.indexOf("webkit") === 0) {
		styleName = "-" + styleName;
	} else if(styleName.indexOf("-m-s") === 0) {
		styleName = "-ms" + styleName.substr(4);
	}
	return styleName;
};

/*
Round trip a stylename to a property name and back again. For example:
	"transform" --> "webkitTransform" --> "-webkit-transform"
*/
exports.roundTripPropertyName = function(propertyName) {
	return $tw.utils.convertPropertyNameToStyleName($tw.utils.convertStyleNameToPropertyName(propertyName));
};

/*
Converts a standard event name into the local browser specific equivalent. For example:
	"animationEnd" --> "webkitAnimationEnd"
*/

var eventNameCache = {}; // We'll cache the conversions

var eventNameMappings = {
	"transitionEnd": {
		correspondingCssProperty: "transition",
		mappings: {
			transition: "transitionend",
			OTransition: "oTransitionEnd",
			MSTransition: "msTransitionEnd",
			MozTransition: "transitionend",
			webkitTransition: "webkitTransitionEnd"
		}
	},
	"animationEnd": {
		correspondingCssProperty: "animation",
		mappings: {
			animation: "animationend",
			OAnimation: "oAnimationEnd",
			MSAnimation: "msAnimationEnd",
			MozAnimation: "animationend",
			webkitAnimation: "webkitAnimationEnd"
		}
	}
};

exports.convertEventName = function(eventName) {
	if(eventNameCache[eventName]) {
		return eventNameCache[eventName];
	}
	var newEventName = eventName,
		mappings = eventNameMappings[eventName];
	if(mappings) {
		var convertedProperty = $tw.utils.convertStyleNameToPropertyName(mappings.correspondingCssProperty);
		if(mappings.mappings[convertedProperty]) {
			newEventName = mappings.mappings[convertedProperty];
		}
	}
	// Put it in the cache too
	eventNameCache[eventName] = newEventName;
	return newEventName;
};

/*
Return the names of the fullscreen APIs
*/
exports.getFullScreenApis = function() {
	var d = document,
		db = d.body,
		result = {
		"_requestFullscreen": db.webkitRequestFullscreen !== undefined ? "webkitRequestFullscreen" :
							db.mozRequestFullScreen !== undefined ? "mozRequestFullScreen" :
							db.msRequestFullscreen !== undefined ? "msRequestFullscreen" :
							db.requestFullscreen !== undefined ? "requestFullscreen" : "",
		"_exitFullscreen": d.webkitExitFullscreen !== undefined ? "webkitExitFullscreen" :
							d.mozCancelFullScreen !== undefined ? "mozCancelFullScreen" :
							d.msExitFullscreen !== undefined ? "msExitFullscreen" :
							d.exitFullscreen !== undefined ? "exitFullscreen" : "",
		"_fullscreenElement": d.webkitFullscreenElement !== undefined ? "webkitFullscreenElement" :
							d.mozFullScreenElement !== undefined ? "mozFullScreenElement" :
							d.msFullscreenElement !== undefined ? "msFullscreenElement" :
							d.fullscreenElement !== undefined ? "fullscreenElement" : "",
		"_fullscreenChange": d.webkitFullscreenElement !== undefined ? "webkitfullscreenchange" :
							d.mozFullScreenElement !== undefined ? "mozfullscreenchange" :
							d.msFullscreenElement !== undefined ? "MSFullscreenChange" :
							d.fullscreenElement !== undefined ? "fullscreenchange" : ""
	};
	if(!result._requestFullscreen || !result._exitFullscreen || !result._fullscreenElement || !result._fullscreenChange) {
		return null;
	} else {
		return result;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/csscolorparser.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

;})();
return exports;
}));
_define("$:/core/modules/utils/dom.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom.js
type: application/javascript
module-type: utils

Various static DOM-related utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Determines whether element 'a' contains element 'b'
Code thanks to John Resig, http://ejohn.org/blog/comparing-document-position/
*/
exports.domContains = function(a,b) {
	return a.contains ?
		a !== b && a.contains(b) :
		!!(a.compareDocumentPosition(b) & 16);
};

exports.removeChildren = function(node) {
	while(node.hasChildNodes()) {
		node.removeChild(node.firstChild);
	}
};

exports.hasClass = function(el,className) {
	return el && el.className && el.className.toString().split(" ").indexOf(className) !== -1;
};

exports.addClass = function(el,className) {
	var c = el.className.split(" ");
	if(c.indexOf(className) === -1) {
		c.push(className);
	}
	el.className = c.join(" ");
};

exports.removeClass = function(el,className) {
	var c = el.className.split(" "),
		p = c.indexOf(className);
	if(p !== -1) {
		c.splice(p,1);
		el.className = c.join(" ");
	}
};

exports.toggleClass = function(el,className,status) {
	if(status === undefined) {
		status = !exports.hasClass(el,className);
	}
	if(status) {
		exports.addClass(el,className);
	} else {
		exports.removeClass(el,className);
	}
};

/*
Get the first parent element that has scrollbars or use the body as fallback.
*/
exports.getScrollContainer = function(el) {
	var doc = el.ownerDocument;
	while(el.parentNode) {	
		el = el.parentNode;
		if(el.scrollTop) {
			return el;
		}
	}
	return doc.body;
};

/*
Get the scroll position of the viewport
Returns:
	{
		x: horizontal scroll position in pixels,
		y: vertical scroll position in pixels
	}
*/
exports.getScrollPosition = function(srcWindow) {
	var scrollWindow = srcWindow || window;
	if("scrollX" in scrollWindow) {
		return {x: scrollWindow.scrollX, y: scrollWindow.scrollY};
	} else {
		return {x: scrollWindow.document.documentElement.scrollLeft, y: scrollWindow.document.documentElement.scrollTop};
	}
};

/*
Adjust the height of a textarea to fit its content, preserving scroll position, and return the height
*/
exports.resizeTextAreaToFit = function(domNode,minHeight) {
	// Get the scroll container and register the current scroll position
	var container = $tw.utils.getScrollContainer(domNode),
		scrollTop = container.scrollTop;
    // Measure the specified minimum height
	domNode.style.height = minHeight;
	var measuredHeight = domNode.offsetHeight || parseInt(minHeight,10);
	// Set its height to auto so that it snaps to the correct height
	domNode.style.height = "auto";
	// Calculate the revised height
	var newHeight = Math.max(domNode.scrollHeight + domNode.offsetHeight - domNode.clientHeight,measuredHeight);
	// Only try to change the height if it has changed
	if(newHeight !== domNode.offsetHeight) {
		domNode.style.height = newHeight + "px";
		// Make sure that the dimensions of the textarea are recalculated
		$tw.utils.forceLayout(domNode);
		// Set the container to the position we registered at the beginning
		container.scrollTop = scrollTop;
	}
	return newHeight;
};

/*
Gets the bounding rectangle of an element in absolute page coordinates
*/
exports.getBoundingPageRect = function(element) {
	var scrollPos = $tw.utils.getScrollPosition(element.ownerDocument.defaultView),
		clientRect = element.getBoundingClientRect();
	return {
		left: clientRect.left + scrollPos.x,
		width: clientRect.width,
		right: clientRect.right + scrollPos.x,
		top: clientRect.top + scrollPos.y,
		height: clientRect.height,
		bottom: clientRect.bottom + scrollPos.y
	};
};

/*
Saves a named password in the browser
*/
exports.savePassword = function(name,password) {
	var done = false;
	try {
		window.localStorage.setItem("tw5-password-" + name,password);
		done = true;
	} catch(e) {
	}
	if(!done) {
		$tw.savedPasswords = $tw.savedPasswords || Object.create(null);
		$tw.savedPasswords[name] = password;
	}
};

/*
Retrieve a named password from the browser
*/
exports.getPassword = function(name) {
	var value;
	try {
		value = window.localStorage.getItem("tw5-password-" + name);
	} catch(e) {
	}
	if(value !== undefined) {
		return value;
	} else {
		return ($tw.savedPasswords || Object.create(null))[name] || "";
	}
};

/*
Force layout of a dom node and its descendents
*/
exports.forceLayout = function(element) {
	var dummy = element.offsetWidth;
};

/*
Pulse an element for debugging purposes
*/
exports.pulseElement = function(element) {
	// Event handler to remove the class at the end
	element.addEventListener($tw.browser.animationEnd,function handler(event) {
		element.removeEventListener($tw.browser.animationEnd,handler,false);
		$tw.utils.removeClass(element,"pulse");
	},false);
	// Apply the pulse class
	$tw.utils.removeClass(element,"pulse");
	$tw.utils.forceLayout(element);
	$tw.utils.addClass(element,"pulse");
};

/*
Attach specified event handlers to a DOM node
domNode: where to attach the event handlers
events: array of event handlers to be added (see below)
Each entry in the events array is an object with these properties:
handlerFunction: optional event handler function
handlerObject: optional event handler object
handlerMethod: optionally specifies object handler method name (defaults to `handleEvent`)
*/
exports.addEventListeners = function(domNode,events) {
	$tw.utils.each(events,function(eventInfo) {
		var handler;
		if(eventInfo.handlerFunction) {
			handler = eventInfo.handlerFunction;
		} else if(eventInfo.handlerObject) {
			if(eventInfo.handlerMethod) {
				handler = function(event) {
					eventInfo.handlerObject[eventInfo.handlerMethod].call(eventInfo.handlerObject,event);
				};	
			} else {
				handler = eventInfo.handlerObject;
			}
		}
		domNode.addEventListener(eventInfo.name,handler,false);
	});
};

/*
Get the computed styles applied to an element as an array of strings of individual CSS properties
*/
exports.getComputedStyles = function(domNode) {
	var textAreaStyles = window.getComputedStyle(domNode,null),
		styleDefs = [],
		name;
	for(var t=0; t<textAreaStyles.length; t++) {
		name = textAreaStyles[t];
		styleDefs.push(name + ": " + textAreaStyles.getPropertyValue(name) + ";");
	}
	return styleDefs;
};

/*
Apply a set of styles passed as an array of strings of individual CSS properties
*/
exports.setStyles = function(domNode,styleDefs) {
	domNode.style.cssText = styleDefs.join("");
};

/*
Copy the computed styles from a source element to a destination element
*/
exports.copyStyles = function(srcDomNode,dstDomNode) {
	$tw.utils.setStyles(dstDomNode,$tw.utils.getComputedStyles(srcDomNode));
};

/*
Copy plain text to the clipboard on browsers that support it
*/
exports.copyToClipboard = function(text,options) {
	options = options || {};
	var textArea = document.createElement("textarea");
	textArea.style.position = "fixed";
	textArea.style.top = 0;
	textArea.style.left = 0;
	textArea.style.fontSize = "12pt";
	textArea.style.width = "2em";
	textArea.style.height = "2em";
	textArea.style.padding = 0;
	textArea.style.border = "none";
	textArea.style.outline = "none";
	textArea.style.boxShadow = "none";
	textArea.style.background = "transparent";
	textArea.value = text;
	document.body.appendChild(textArea);
	textArea.select();
	textArea.setSelectionRange(0,text.length);
	var succeeded = false;
	try {
		succeeded = document.execCommand("copy");
	} catch (err) {
	}
	if(!options.doNotNotify) {
		$tw.notifier.display(succeeded ? "$:/language/Notifications/CopiedToClipboard/Succeeded" : "$:/language/Notifications/CopiedToClipboard/Failed");
	}
	document.body.removeChild(textArea);
};

exports.getLocationPath = function() {
	return window.location.toString().split("#")[0];
};


})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/dragndrop.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/dragndrop.js
type: application/javascript
module-type: utils

Browser data transfer utilities, used with the clipboard and drag and drop

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Options:

domNode: dom node to make draggable
dragImageType: "pill" or "dom"
dragTiddlerFn: optional function to retrieve the title of tiddler to drag
dragFilterFn: optional function to retreive the filter defining a list of tiddlers to drag
widget: widget to use as the contect for the filter
*/
exports.makeDraggable = function(options) {
	var dragImageType = options.dragImageType || "dom",
		dragImage,
		domNode = options.domNode;
	// Make the dom node draggable (not necessary for anchor tags)
	if((domNode.tagName || "").toLowerCase() !== "a") {
		domNode.setAttribute("draggable","true");		
	}
	// Add event handlers
	$tw.utils.addEventListeners(domNode,[
		{name: "dragstart", handlerFunction: function(event) {
			if(event.dataTransfer === undefined) {
				return false;
			}
			// Collect the tiddlers being dragged
			var dragTiddler = options.dragTiddlerFn && options.dragTiddlerFn(),
				dragFilter = options.dragFilterFn && options.dragFilterFn(),
				titles = dragTiddler ? [dragTiddler] : [],
			    	startActions = options.startActions;
			if(dragFilter) {
				titles.push.apply(titles,options.widget.wiki.filterTiddlers(dragFilter,options.widget));
			}
			var titleString = $tw.utils.stringifyList(titles);
			// Check that we've something to drag
			if(titles.length > 0 && event.target === domNode) {
				// Mark the drag in progress
				$tw.dragInProgress = domNode;
				// Set the dragging class on the element being dragged
				$tw.utils.addClass(event.target,"tc-dragging");
				// Invoke drag-start actions if given
				if(startActions !== undefined) {
					options.widget.invokeActionString(startActions,options.widget,event,{actionTiddler: titleString});
				}
				// Create the drag image elements
				dragImage = options.widget.document.createElement("div");
				dragImage.className = "tc-tiddler-dragger";
				var inner = options.widget.document.createElement("div");
				inner.className = "tc-tiddler-dragger-inner";
				inner.appendChild(options.widget.document.createTextNode(
					titles.length === 1 ? 
						titles[0] :
						titles.length + " tiddlers"
				));
				dragImage.appendChild(inner);
				options.widget.document.body.appendChild(dragImage);
				// Set the data transfer properties
				var dataTransfer = event.dataTransfer;
				// Set up the image
				dataTransfer.effectAllowed = "all";
				if(dataTransfer.setDragImage) {
					if(dragImageType === "pill") {
						dataTransfer.setDragImage(dragImage.firstChild,-16,-16);
					} else {
						var r = domNode.getBoundingClientRect();
						dataTransfer.setDragImage(domNode,event.clientX-r.left,event.clientY-r.top);
					}
				}
				// Set up the data transfer
				if(dataTransfer.clearData) {
					dataTransfer.clearData();					
				}
				var jsonData = [];
				if(titles.length > 1) {
					titles.forEach(function(title) {
						jsonData.push(options.widget.wiki.getTiddlerAsJson(title));
					});
					jsonData = "[" + jsonData.join(",") + "]";
				} else {
					jsonData = options.widget.wiki.getTiddlerAsJson(titles[0]);
				}
				// IE doesn't like these content types
				if(!$tw.browser.isIE) {
					dataTransfer.setData("text/vnd.tiddler",jsonData);
					dataTransfer.setData("text/plain",titleString);
					dataTransfer.setData("text/x-moz-url","data:text/vnd.tiddler," + encodeURIComponent(jsonData));
				}
				dataTransfer.setData("URL","data:text/vnd.tiddler," + encodeURIComponent(jsonData));
				dataTransfer.setData("Text",titleString);
				event.stopPropagation();
			}
			return false;
		}},
		{name: "dragend", handlerFunction: function(event) {
			if(event.target === domNode) {
				// Collect the tiddlers being dragged
				var dragTiddler = options.dragTiddlerFn && options.dragTiddlerFn(),
					dragFilter = options.dragFilterFn && options.dragFilterFn(),
					titles = dragTiddler ? [dragTiddler] : [],
			    		endActions = options.endActions;
				if(dragFilter) {
					titles.push.apply(titles,options.widget.wiki.filterTiddlers(dragFilter,options.widget));
				}
				var titleString = $tw.utils.stringifyList(titles);
				$tw.dragInProgress = null;
				// Invoke drag-end actions if given
				if(endActions !== undefined) {
					options.widget.invokeActionString(endActions,options.widget,event,{actionTiddler: titleString});
				}
				// Remove the dragging class on the element being dragged
				$tw.utils.removeClass(event.target,"tc-dragging");
				// Delete the drag image element
				if(dragImage) {
					dragImage.parentNode.removeChild(dragImage);
					dragImage = null;
				}
			}
			return false;
		}}
	]);
};

exports.importDataTransfer = function(dataTransfer,fallbackTitle,callback) {
	// Try each provided data type in turn
	if($tw.log.IMPORT) {
		console.log("Available data types:");
		for(var type=0; type<dataTransfer.types.length; type++) {
			console.log("type",dataTransfer.types[type],dataTransfer.getData(dataTransfer.types[type]))
		}
	}
	for(var t=0; t<importDataTypes.length; t++) {
		if(!$tw.browser.isIE || importDataTypes[t].IECompatible) {
			// Get the data
			var dataType = importDataTypes[t];
				var data = dataTransfer.getData(dataType.type);
			// Import the tiddlers in the data
			if(data !== "" && data !== null) {
				if($tw.log.IMPORT) {
					console.log("Importing data type '" + dataType.type + "', data: '" + data + "'")
				}
				var tiddlerFields = dataType.toTiddlerFieldsArray(data,fallbackTitle);
				callback(tiddlerFields);
				return;
			}
		}
	}
};

var importDataTypes = [
	{type: "text/vnd.tiddler", IECompatible: false, toTiddlerFieldsArray: function(data,fallbackTitle) {
		return parseJSONTiddlers(data,fallbackTitle);
	}},
	{type: "URL", IECompatible: true, toTiddlerFieldsArray: function(data,fallbackTitle) {
		// Check for tiddler data URI
		var match = decodeURIComponent(data).match(/^data\:text\/vnd\.tiddler,(.*)/i);
		if(match) {
			return parseJSONTiddlers(match[1],fallbackTitle);
		} else {
			return [{title: fallbackTitle, text: data}]; // As URL string
		}
	}},
	{type: "text/x-moz-url", IECompatible: false, toTiddlerFieldsArray: function(data,fallbackTitle) {
		// Check for tiddler data URI
		var match = decodeURIComponent(data).match(/^data\:text\/vnd\.tiddler,(.*)/i);
		if(match) {
			return parseJSONTiddlers(match[1],fallbackTitle);
		} else {
			return [{title: fallbackTitle, text: data}]; // As URL string
		}
	}},
	{type: "text/html", IECompatible: false, toTiddlerFieldsArray: function(data,fallbackTitle) {
		return [{title: fallbackTitle, text: data}];
	}},
	{type: "text/plain", IECompatible: false, toTiddlerFieldsArray: function(data,fallbackTitle) {
		return [{title: fallbackTitle, text: data}];
	}},
	{type: "Text", IECompatible: true, toTiddlerFieldsArray: function(data,fallbackTitle) {
		return [{title: fallbackTitle, text: data}];
	}},
	{type: "text/uri-list", IECompatible: false, toTiddlerFieldsArray: function(data,fallbackTitle) {
		return [{title: fallbackTitle, text: data}];
	}}
];

function parseJSONTiddlers(json,fallbackTitle) {
	var data = JSON.parse(json);
	if(!$tw.utils.isArray(data)) {
		data = [data];
	}
	data.forEach(function(fields) {
		fields.title = fields.title || fallbackTitle;
	});
	return data;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/http.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/http.js
type: application/javascript
module-type: utils

Browser HTTP support

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
A quick and dirty HTTP function; to be refactored later. Options are:
	url: URL to retrieve
	headers: hashmap of headers to send
	type: GET, PUT, POST etc
	callback: function invoked with (err,data,xhr)
	returnProp: string name of the property to return as first argument of callback
*/
exports.httpRequest = function(options) {
	var type = options.type || "GET",
		headers = options.headers || {accept: "application/json"},
		returnProp = options.returnProp || "responseText",
		request = new XMLHttpRequest(),
		data = "",
		f,results;
	// Massage the data hashmap into a string
	if(options.data) {
		if(typeof options.data === "string") { // Already a string
			data = options.data;
		} else { // A hashmap of strings
			results = [];
			$tw.utils.each(options.data,function(dataItem,dataItemTitle) {
				results.push(dataItemTitle + "=" + encodeURIComponent(dataItem));
			});
			data = results.join("&");
		}
	}
	// Set up the state change handler
	request.onreadystatechange = function() {
		if(this.readyState === 4) {
			if(this.status === 200 || this.status === 201 || this.status === 204) {
				// Success!
				options.callback(null,this[returnProp],this);
				return;
			}
		// Something went wrong
		options.callback($tw.language.getString("Error/XMLHttpRequest") + ": " + this.status,null,this);
		}
	};
	// Make the request
	request.open(type,options.url,true);
	if(headers) {
		$tw.utils.each(headers,function(header,headerTitle,object) {
			request.setRequestHeader(headerTitle,header);
		});
	}
	if(data && !$tw.utils.hop(headers,"Content-type")) {
		request.setRequestHeader("Content-type","application/x-www-form-urlencoded; charset=UTF-8");
	}
	if(!$tw.utils.hop(headers,"X-Requested-With")) {
		request.setRequestHeader("X-Requested-With","TiddlyWiki");
	}
	try {
		request.send(data);
	} catch(e) {
		options.callback(e,null,this);
	}
	return request;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/keyboard.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/keyboard.js
type: application/javascript
module-type: utils

Keyboard utilities; now deprecated. Instead, use $tw.keyboardManager

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

["parseKeyDescriptor","checkKeyDescriptor"].forEach(function(method) {
	exports[method] = function() {
		if($tw.keyboardManager) {
			return $tw.keyboardManager[method].apply($tw.keyboardManager,Array.prototype.slice.call(arguments,0));
		} else {
			return null
		}
	};
});

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/modal.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/modal.js
type: application/javascript
module-type: utils

Modal message mechanism

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

var Modal = function(wiki) {
	this.wiki = wiki;
	this.modalCount = 0;
};

/*
Display a modal dialogue
	title: Title of tiddler to display
	options: see below
Options include:
	downloadLink: Text of a big download link to include
*/
Modal.prototype.display = function(title,options) {
	options = options || {};
	this.srcDocument = options.variables && (options.variables.rootwindow === "true" ||
				options.variables.rootwindow === "yes") ? document :
				(options.event.event && options.event.event.target ? options.event.event.target.ownerDocument : document);
	this.srcWindow = this.srcDocument.defaultView;
	var self = this,
		refreshHandler,
		duration = $tw.utils.getAnimationDuration(),
		tiddler = this.wiki.getTiddler(title);
	// Don't do anything if the tiddler doesn't exist
	if(!tiddler) {
		return;
	}
	// Create the variables
	var variables = $tw.utils.extend({currentTiddler: title},options.variables);
	// Create the wrapper divs
	var wrapper = this.srcDocument.createElement("div"),
		modalBackdrop = this.srcDocument.createElement("div"),
		modalWrapper = this.srcDocument.createElement("div"),
		modalHeader = this.srcDocument.createElement("div"),
		headerTitle = this.srcDocument.createElement("h3"),
		modalBody = this.srcDocument.createElement("div"),
		modalLink = this.srcDocument.createElement("a"),
		modalFooter = this.srcDocument.createElement("div"),
		modalFooterHelp = this.srcDocument.createElement("span"),
		modalFooterButtons = this.srcDocument.createElement("span");
	// Up the modal count and adjust the body class
	this.modalCount++;
	this.adjustPageClass();
	// Add classes
	$tw.utils.addClass(wrapper,"tc-modal-wrapper");
	$tw.utils.addClass(modalBackdrop,"tc-modal-backdrop");
	$tw.utils.addClass(modalWrapper,"tc-modal");
	$tw.utils.addClass(modalHeader,"tc-modal-header");
	$tw.utils.addClass(modalBody,"tc-modal-body");
	$tw.utils.addClass(modalFooter,"tc-modal-footer");
	// Join them together
	wrapper.appendChild(modalBackdrop);
	wrapper.appendChild(modalWrapper);
	modalHeader.appendChild(headerTitle);
	modalWrapper.appendChild(modalHeader);
	modalWrapper.appendChild(modalBody);
	modalFooter.appendChild(modalFooterHelp);
	modalFooter.appendChild(modalFooterButtons);
	modalWrapper.appendChild(modalFooter);
	// Render the title of the message
	var headerWidgetNode = this.wiki.makeTranscludeWidget(title,{
		field: "subtitle",
		mode: "inline",
		children: [{
			type: "text",
			attributes: {
				text: {
					type: "string",
					value: title
		}}}],
		parentWidget: $tw.rootWidget,
		document: this.srcDocument,
		variables: variables,
		importPageMacros: true
	});
	headerWidgetNode.render(headerTitle,null);
	// Render the body of the message
	var bodyWidgetNode = this.wiki.makeTranscludeWidget(title,{
		parentWidget: $tw.rootWidget,
		document: this.srcDocument,
		variables: variables,
		importPageMacros: true
	});
	bodyWidgetNode.render(modalBody,null);
	// Setup the link if present
	if(options.downloadLink) {
		modalLink.href = options.downloadLink;
		modalLink.appendChild(this.srcDocument.createTextNode("Right-click to save changes"));
		modalBody.appendChild(modalLink);
	}
	// Render the footer of the message
	if(tiddler && tiddler.fields && tiddler.fields.help) {
		var link = this.srcDocument.createElement("a");
		link.setAttribute("href",tiddler.fields.help);
		link.setAttribute("target","_blank");
		link.setAttribute("rel","noopener noreferrer");
		link.appendChild(this.srcDocument.createTextNode("Help"));
		modalFooterHelp.appendChild(link);
		modalFooterHelp.style.float = "left";
	}
	var footerWidgetNode = this.wiki.makeTranscludeWidget(title,{
		field: "footer",
		mode: "inline",
		children: [{
			type: "button",
			attributes: {
				message: {
					type: "string",
					value: "tm-close-tiddler"
				}
			},
			children: [{
				type: "text",
				attributes: {
					text: {
						type: "string",
						value: $tw.language.getString("Buttons/Close/Caption")
			}}}
		]}],
		parentWidget: $tw.rootWidget,
		document: this.srcDocument,
		variables: variables,
		importPageMacros: true
	});
	footerWidgetNode.render(modalFooterButtons,null);
	// Set up the refresh handler
	refreshHandler = function(changes) {
		headerWidgetNode.refresh(changes,modalHeader,null);
		bodyWidgetNode.refresh(changes,modalBody,null);
		footerWidgetNode.refresh(changes,modalFooterButtons,null);
	};
	this.wiki.addEventListener("change",refreshHandler);
	// Add the close event handler
	var closeHandler = function(event) {
		// Remove our refresh handler
		self.wiki.removeEventListener("change",refreshHandler);
		// Decrease the modal count and adjust the body class
		self.modalCount--;
		self.adjustPageClass();
		// Force layout and animate the modal message away
		$tw.utils.forceLayout(modalBackdrop);
		$tw.utils.forceLayout(modalWrapper);
		$tw.utils.setStyle(modalBackdrop,[
			{opacity: "0"}
		]);
		$tw.utils.setStyle(modalWrapper,[
			{transform: "translateY(" + self.srcWindow.innerHeight + "px)"}
		]);
		// Set up an event for the transition end
		self.srcWindow.setTimeout(function() {
			if(wrapper.parentNode) {
				// Remove the modal message from the DOM
				self.srcDocument.body.removeChild(wrapper);
			}
		},duration);
		// Don't let anyone else handle the tm-close-tiddler message
		return false;
	};
	headerWidgetNode.addEventListener("tm-close-tiddler",closeHandler,false);
	bodyWidgetNode.addEventListener("tm-close-tiddler",closeHandler,false);
	footerWidgetNode.addEventListener("tm-close-tiddler",closeHandler,false);
	// Set the initial styles for the message
	$tw.utils.setStyle(modalBackdrop,[
		{opacity: "0"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transformOrigin: "0% 0%"},
		{transform: "translateY(" + (-this.srcWindow.innerHeight) + "px)"}
	]);
	// Put the message into the document
	this.srcDocument.body.appendChild(wrapper);
	// Set up animation for the styles
	$tw.utils.setStyle(modalBackdrop,[
		{transition: "opacity " + duration + "ms ease-out"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms ease-in-out"}
	]);
	// Force layout
	$tw.utils.forceLayout(modalBackdrop);
	$tw.utils.forceLayout(modalWrapper);
	// Set final animated styles
	$tw.utils.setStyle(modalBackdrop,[
		{opacity: "0.7"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transform: "translateY(0px)"}
	]);
};

Modal.prototype.adjustPageClass = function() {
	var windowContainer = $tw.pageContainer ? ($tw.pageContainer === this.srcDocument.body.firstChild ? $tw.pageContainer : this.srcDocument.body.firstChild) : null;
	if(windowContainer) {
		$tw.utils.toggleClass(windowContainer,"tc-modal-displayed",this.modalCount > 0);
	}
};

exports.Modal = Modal;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/notifier.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/notifier.js
type: application/javascript
module-type: utils

Notifier mechanism

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

var Notifier = function(wiki) {
	this.wiki = wiki;
};

/*
Display a notification
	title: Title of tiddler containing the notification text
	options: see below
Options include:
*/
Notifier.prototype.display = function(title,options) {
	options = options || {};
	// Create the wrapper divs
	var self = this,
		notification = document.createElement("div"),
		tiddler = this.wiki.getTiddler(title),
		duration = $tw.utils.getAnimationDuration(),
		refreshHandler;
	// Don't do anything if the tiddler doesn't exist
	if(!tiddler) {
		return;
	}
	// Add classes
	$tw.utils.addClass(notification,"tc-notification");
	// Create the variables
	var variables = $tw.utils.extend({currentTiddler: title},options.variables);
	// Render the body of the notification
	var widgetNode = this.wiki.makeTranscludeWidget(title,{
		parentWidget: $tw.rootWidget,
		document: document,
		variables: variables,
		importPageMacros: true});
	widgetNode.render(notification,null);
	refreshHandler = function(changes) {
		widgetNode.refresh(changes,notification,null);
	};
	this.wiki.addEventListener("change",refreshHandler);
	// Set the initial styles for the notification
	$tw.utils.setStyle(notification,[
		{opacity: "0"},
		{transformOrigin: "0% 0%"},
		{transform: "translateY(" + (-window.innerHeight) + "px)"},
		{transition: "opacity " + duration + "ms ease-out, " + $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms ease-in-out"}
	]);
	// Add the notification to the DOM
	document.body.appendChild(notification);
	// Force layout
	$tw.utils.forceLayout(notification);
	// Set final animated styles
	$tw.utils.setStyle(notification,[
		{opacity: "1.0"},
		{transform: "translateY(0px)"}
	]);
	// Set a timer to remove the notification
	window.setTimeout(function() {
		// Remove our change event handler
		self.wiki.removeEventListener("change",refreshHandler);
		// Force layout and animate the notification away
		$tw.utils.forceLayout(notification);
		$tw.utils.setStyle(notification,[
			{opacity: "0.0"},
			{transform: "translateX(" + (notification.offsetWidth) + "px)"}
		]);
		// Remove the modal message from the DOM once the transition ends
		setTimeout(function() {
			if(notification.parentNode) {
				document.body.removeChild(notification);
			}
		},duration);
	},$tw.config.preferences.notificationDuration);
};

exports.Notifier = Notifier;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/popup.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/popup.js
type: application/javascript
module-type: utils

Module that creates a $tw.utils.Popup object prototype that manages popups in the browser

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Creates a Popup object with these options:
	rootElement: the DOM element to which the popup zapper should be attached
*/
var Popup = function(options) {
	options = options || {};
	this.rootElement = options.rootElement || document.documentElement;
	this.popups = []; // Array of {title:,wiki:,domNode:} objects
};

/*
Trigger a popup open or closed. Parameters are in a hashmap:
	title: title of the tiddler where the popup details are stored
	domNode: dom node to which the popup will be positioned (one of domNode or domNodeRect is required)
	domNodeRect: rectangle to which the popup will be positioned
	wiki: wiki
	force: if specified, forces the popup state to true or false (instead of toggling it)
	floating: if true, skips registering the popup, meaning that it will need manually clearing
*/
Popup.prototype.triggerPopup = function(options) {
	// Check if this popup is already active
	var index = this.findPopup(options.title);
	// Compute the new state
	var state = index === -1;
	if(options.force !== undefined) {
		state = options.force;
	}
	// Show or cancel the popup according to the new state
	if(state) {
		this.show(options);
	} else {
		this.cancel(index);
	}
};

Popup.prototype.findPopup = function(title) {
	var index = -1;
	for(var t=0; t<this.popups.length; t++) {
		if(this.popups[t].title === title) {
			index = t;
		}
	}
	return index;
};

Popup.prototype.handleEvent = function(event) {
	if(event.type === "click") {
		// Find out what was clicked on
		var info = this.popupInfo(event.target),
			cancelLevel = info.popupLevel - 1;
		// Don't remove the level that was clicked on if we clicked on a handle
		if(info.isHandle) {
			cancelLevel++;
		}
		// Cancel
		this.cancel(cancelLevel);
	}
};

/*
Find the popup level containing a DOM node. Returns:
popupLevel: count of the number of nested popups containing the specified element
isHandle: true if the specified element is within a popup handle
*/
Popup.prototype.popupInfo = function(domNode) {
	var isHandle = false,
		popupCount = 0,
		node = domNode;
	// First check ancestors to see if we're within a popup handle
	while(node) {
		if($tw.utils.hasClass(node,"tc-popup-handle")) {
			isHandle = true;
			popupCount++;
		}
		if($tw.utils.hasClass(node,"tc-popup-keep")) {
			isHandle = true;
		}
		node = node.parentNode;
	}
	// Then count the number of ancestor popups
	node = domNode;
	while(node) {
		if($tw.utils.hasClass(node,"tc-popup")) {
			popupCount++;
		}
		node = node.parentNode;
	}
	var info = {
		popupLevel: popupCount,
		isHandle: isHandle
	};
	return info;
};

/*
Display a popup by adding it to the stack
*/
Popup.prototype.show = function(options) {
	// Find out what was clicked on
	var info = this.popupInfo(options.domNode);
	// Cancel any higher level popups
	this.cancel(info.popupLevel);

	// Store the popup details if not already there
	if(!options.floating && this.findPopup(options.title) === -1) {
		this.popups.push({
			title: options.title,
			wiki: options.wiki,
			domNode: options.domNode
		});
	}
	// Set the state tiddler
	var rect;
	if(options.domNodeRect) {
		rect = options.domNodeRect;
	} else {
		rect = {
			left: options.domNode.offsetLeft,
			top: options.domNode.offsetTop,
			width: options.domNode.offsetWidth,
			height: options.domNode.offsetHeight
		};
	}
	var popupRect = "(" + rect.left + "," + rect.top + "," + 
				rect.width + "," + rect.height + ")";
	if(options.noStateReference) {
		options.wiki.setText(options.title,"text",undefined,popupRect);
	} else {
		options.wiki.setTextReference(options.title,popupRect);
	}
	// Add the click handler if we have any popups
	if(this.popups.length > 0) {
		this.rootElement.addEventListener("click",this,true);		
	}
};

/*
Detect if a Popup contains an input field that has focus
Returns true or false
*/
Popup.prototype.detectInputWithinPopup = function(node) {
	var withinPopup = false;
	for(var i=0; i<this.popups.length; i++) {
		var popup = (this.popups[i] && this.popups[i].domNode) ? this.popups[i].domNode : null;
		while(node && popup) {
			if(node === popup || (node.classList && node.classList.contains("tc-popup-keep"))) {
				withinPopup = true;
			}
			node = node.parentNode;
		}
	}
	return withinPopup;
};

/*
Cancel all popups at or above a specified level or DOM node
level: popup level to cancel (0 cancels all popups)
*/
Popup.prototype.cancel = function(level,focusedInputNode) {
	var numPopups = this.popups.length;
	level = Math.max(0,Math.min(level,numPopups));
	for(var t=level; t<numPopups; t++) {
		var inputWithinPopup;
		if(focusedInputNode) {
			inputWithinPopup = this.detectInputWithinPopup(focusedInputNode);
		}
		if(!inputWithinPopup) {
			var popup = this.popups.pop();
		  	if(popup.title) {
				if(popup.noStateReference) {
					popup.wiki.deleteTiddler(popup.title);
				} else {
					popup.wiki.deleteTiddler($tw.utils.parseTextReference(popup.title).title);
        			}
			}
		}
	}
	if(this.popups.length === 0) {
		this.rootElement.removeEventListener("click",this,false);
	}
};

/*
Returns true if the specified title and text identifies an active popup
*/
Popup.prototype.readPopupState = function(text) {
	var popupLocationRegExp = /^\((-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+)\)$/;
	return popupLocationRegExp.test(text);
};

exports.Popup = Popup;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/dom/scroller.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/dom/scroller.js
type: application/javascript
module-type: utils

Module that creates a $tw.utils.Scroller object prototype that manages scrolling in the browser

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Event handler for when the `tm-scroll` event hits the document body
*/
var PageScroller = function() {
	this.idRequestFrame = null;
	this.requestAnimationFrame = window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		function(callback) {
			return window.setTimeout(callback, 1000/60);
		};
	this.cancelAnimationFrame = window.cancelAnimationFrame ||
		window.webkitCancelAnimationFrame ||
		window.webkitCancelRequestAnimationFrame ||
		window.mozCancelAnimationFrame ||
		window.mozCancelRequestAnimationFrame ||
		function(id) {
			window.clearTimeout(id);
		};
};

PageScroller.prototype.isScrolling = function() {
	return this.idRequestFrame !== null;
}

PageScroller.prototype.cancelScroll = function(srcWindow) {
	if(this.idRequestFrame) {
		this.cancelAnimationFrame.call(srcWindow,this.idRequestFrame);
		this.idRequestFrame = null;
	}
};

/*
Handle an event
*/
PageScroller.prototype.handleEvent = function(event) {
	if(event.type === "tm-scroll") {
		return this.scrollIntoView(event.target);
	}
	return true;
};

/*
Handle a scroll event hitting the page document
*/
PageScroller.prototype.scrollIntoView = function(element,callback) {
	var self = this,
		duration = $tw.utils.getAnimationDuration(),
	    srcWindow = element ? element.ownerDocument.defaultView : window;
	// Now get ready to scroll the body
	this.cancelScroll(srcWindow);
	this.startTime = Date.now();
	// Get the height of any position:fixed toolbars
	var toolbar = srcWindow.document.querySelector(".tc-adjust-top-of-scroll"),
		offset = 0;
	if(toolbar) {
		offset = toolbar.offsetHeight;
	}
	// Get the client bounds of the element and adjust by the scroll position
	var getBounds = function() {
			var clientBounds = typeof callback === 'function' ? callback() : element.getBoundingClientRect(),
				scrollPosition = $tw.utils.getScrollPosition(srcWindow);
			return {
				left: clientBounds.left + scrollPosition.x,
				top: clientBounds.top + scrollPosition.y - offset,
				width: clientBounds.width,
				height: clientBounds.height
			};
		},
		// We'll consider the horizontal and vertical scroll directions separately via this function
		// targetPos/targetSize - position and size of the target element
		// currentPos/currentSize - position and size of the current scroll viewport
		// returns: new position of the scroll viewport
		getEndPos = function(targetPos,targetSize,currentPos,currentSize) {
			var newPos = targetPos;
			// If we are scrolling within 50 pixels of the top/left then snap to zero
			if(newPos < 50) {
				newPos = 0;
			}
			return newPos;
		},
		drawFrame = function drawFrame() {
			var t;
			if(duration <= 0) {
				t = 1;
			} else {
				t = ((Date.now()) - self.startTime) / duration;	
			}
			if(t >= 1) {
				self.cancelScroll(srcWindow);
				t = 1;
			}
			t = $tw.utils.slowInSlowOut(t);
			var scrollPosition = $tw.utils.getScrollPosition(srcWindow),
				bounds = getBounds(),
				endX = getEndPos(bounds.left,bounds.width,scrollPosition.x,srcWindow.innerWidth),
				endY = getEndPos(bounds.top,bounds.height,scrollPosition.y,srcWindow.innerHeight);
			srcWindow.scrollTo(scrollPosition.x + (endX - scrollPosition.x) * t,scrollPosition.y + (endY - scrollPosition.y) * t);
			if(t < 1) {
				self.idRequestFrame = self.requestAnimationFrame.call(srcWindow,drawFrame);
			}
		};
	drawFrame();
};

exports.PageScroller = PageScroller;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/edition-info.js","utils-node",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/edition-info.js
type: application/javascript
module-type: utils-node

Information about the available editions

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var fs = require("fs"),
	path = require("path");

var editionInfo;

exports.getEditionInfo = function() {
	if(!editionInfo) {
		// Enumerate the edition paths
		var editionPaths = $tw.getLibraryItemSearchPaths($tw.config.editionsPath,$tw.config.editionsEnvVar);
		editionInfo = {};
		for(var editionIndex=0; editionIndex<editionPaths.length; editionIndex++) {
			var editionPath = editionPaths[editionIndex];
			// Enumerate the folders
			var entries = fs.readdirSync(editionPath);
			for(var entryIndex=0; entryIndex<entries.length; entryIndex++) {
				var entry = entries[entryIndex];
				// Check if directories have a valid tiddlywiki.info
				if(!editionInfo[entry] && $tw.utils.isDirectory(path.resolve(editionPath,entry))) {
					var info;
					try {
						info = JSON.parse(fs.readFileSync(path.resolve(editionPath,entry,"tiddlywiki.info"),"utf8"));
					} catch(ex) {
					}
					if(info) {
						editionInfo[entry] = info;
					}
				}
			}
		}
	}
	return editionInfo;
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/fakedom.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/fakedom.js
type: application/javascript
module-type: global

A barebones implementation of DOM interfaces needed by the rendering mechanism.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Sequence number used to enable us to track objects for testing
var sequenceNumber = null;

var bumpSequenceNumber = function(object) {
	if(sequenceNumber !== null) {
		object.sequenceNumber = sequenceNumber++;
	}
};

var TW_TextNode = function(text) {
	bumpSequenceNumber(this);
	this.textContent = text + "";
};

Object.defineProperty(TW_TextNode.prototype, "nodeType", {
	get: function() {
		return 3;
	}
});

Object.defineProperty(TW_TextNode.prototype, "formattedTextContent", {
	get: function() {
		return this.textContent.replace(/(\r?\n)/g,"");
	}
});

var TW_Element = function(tag,namespace) {
	bumpSequenceNumber(this);
	this.isTiddlyWikiFakeDom = true;
	this.tag = tag;
	this.attributes = {};
	this.isRaw = false;
	this.children = [];
	this._style = {};
	this.namespaceURI = namespace || "http://www.w3.org/1999/xhtml";
};

Object.defineProperty(TW_Element.prototype, "style", {
	get: function() {
		return this._style;
	},
	set: function(str) {
		var self = this;
		str = str || "";
		$tw.utils.each(str.split(";"),function(declaration) {
			var parts = declaration.split(":"),
				name = $tw.utils.trim(parts[0]),
				value = $tw.utils.trim(parts[1]);
			if(name && value) {
				self._style[$tw.utils.convertStyleNameToPropertyName(name)] = value;
			}
		});
	}
});

Object.defineProperty(TW_Element.prototype, "nodeType", {
	get: function() {
		return 1;
	}
});

TW_Element.prototype.getAttribute = function(name) {
	if(this.isRaw) {
		throw "Cannot getAttribute on a raw TW_Element";
	}
	return this.attributes[name];
};

TW_Element.prototype.setAttribute = function(name,value) {
	if(this.isRaw) {
		throw "Cannot setAttribute on a raw TW_Element";
	}
	this.attributes[name] = value + "";
};

TW_Element.prototype.setAttributeNS = function(namespace,name,value) {
	this.setAttribute(name,value);
};

TW_Element.prototype.removeAttribute = function(name) {
	if(this.isRaw) {
		throw "Cannot removeAttribute on a raw TW_Element";
	}
	if($tw.utils.hop(this.attributes,name)) {
		delete this.attributes[name];
	}
};

TW_Element.prototype.appendChild = function(node) {
	this.children.push(node);
	node.parentNode = this;
};

TW_Element.prototype.insertBefore = function(node,nextSibling) {
	if(nextSibling) {
		var p = this.children.indexOf(nextSibling);
		if(p !== -1) {
			this.children.splice(p,0,node);
			node.parentNode = this;
		} else {
			this.appendChild(node);
		}
	} else {
		this.appendChild(node);
	}
};

TW_Element.prototype.removeChild = function(node) {
	var p = this.children.indexOf(node);
	if(p !== -1) {
		this.children.splice(p,1);
	}
};

TW_Element.prototype.hasChildNodes = function() {
	return !!this.children.length;
};

Object.defineProperty(TW_Element.prototype, "childNodes", {
	get: function() {
		return this.children;
	}
});

Object.defineProperty(TW_Element.prototype, "firstChild", {
	get: function() {
		return this.children[0];
	}
});

TW_Element.prototype.addEventListener = function(type,listener,useCapture) {
	// Do nothing
};

Object.defineProperty(TW_Element.prototype, "tagName", {
	get: function() {
		return this.tag || "";
	}
});

Object.defineProperty(TW_Element.prototype, "className", {
	get: function() {
		return this.attributes["class"] || "";
	},
	set: function(value) {
		this.attributes["class"] = value + "";
	}
});

Object.defineProperty(TW_Element.prototype, "value", {
	get: function() {
		return this.attributes.value || "";
	},
	set: function(value) {
		this.attributes.value = value + "";
	}
});

Object.defineProperty(TW_Element.prototype, "outerHTML", {
	get: function() {
		var output = [],attr,a,v;
		output.push("<",this.tag);
		if(this.attributes) {
			attr = [];
			for(a in this.attributes) {
				attr.push(a);
			}
			attr.sort();
			for(a=0; a<attr.length; a++) {
				v = this.attributes[attr[a]];
				if(v !== undefined) {
					output.push(" ",attr[a],"=\"",$tw.utils.htmlEncode(v),"\"");
				}
			}
		}
		if(this._style) {
			var style = [];
			for(var s in this._style) {
				style.push($tw.utils.convertPropertyNameToStyleName(s) + ":" + this._style[s] + ";");
			}
			if(style.length > 0) {
				output.push(" style=\"",style.join(""),"\"");
			}
		}
		output.push(">");
		if($tw.config.htmlVoidElements.indexOf(this.tag) === -1) {
			output.push(this.innerHTML);
			output.push("</",this.tag,">");
		}
		return output.join("");
	}
});

Object.defineProperty(TW_Element.prototype, "innerHTML", {
	get: function() {
		if(this.isRaw) {
			return this.rawHTML;
		} else {
			var b = [];
			$tw.utils.each(this.children,function(node) {
				if(node instanceof TW_Element) {
					b.push(node.outerHTML);
				} else if(node instanceof TW_TextNode) {
					b.push($tw.utils.htmlEncode(node.textContent));
				}
			});
			return b.join("");
		}
	},
	set: function(value) {
		this.isRaw = true;
		this.rawHTML = value;
		this.rawTextContent = null;
	}
});

Object.defineProperty(TW_Element.prototype, "textInnerHTML", {
	set: function(value) {
		if(this.isRaw) {
			this.rawTextContent = value;
		} else {
			throw "Cannot set textInnerHTML of a non-raw TW_Element";
		}
	}
});

Object.defineProperty(TW_Element.prototype, "textContent", {
	get: function() {
		if(this.isRaw) {
			if(this.rawTextContent === null) {
				return "";
			} else {
				return this.rawTextContent;
			}
		} else {
			var b = [];
			$tw.utils.each(this.children,function(node) {
				b.push(node.textContent);
			});
			return b.join("");
		}
	},
	set: function(value) {
		this.children = [new TW_TextNode(value)];
	}
});

Object.defineProperty(TW_Element.prototype, "formattedTextContent", {
	get: function() {
		if(this.isRaw) {
			return "";
		} else {
			var b = [],
				isBlock = $tw.config.htmlBlockElements.indexOf(this.tag) !== -1;
			if(isBlock) {
				b.push("\n");
			}
			if(this.tag === "li") {
				b.push("* ");
			}
			$tw.utils.each(this.children,function(node) {
				b.push(node.formattedTextContent);
			});
			if(isBlock) {
				b.push("\n");
			}
			return b.join("");
		}
	}
});

var document = {
	setSequenceNumber: function(value) {
		sequenceNumber = value;
	},
	createElementNS: function(namespace,tag) {
		return new TW_Element(tag,namespace);
	},
	createElement: function(tag) {
		return new TW_Element(tag);
	},
	createTextNode: function(text) {
		return new TW_TextNode(text);
	},
	compatMode: "CSS1Compat", // For KaTeX to know that we're not a browser in quirks mode
	isTiddlyWikiFakeDom: true
};

exports.fakeDocument = document;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/filesystem.js","utils-node",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/filesystem.js
type: application/javascript
module-type: utils-node

File system utilities

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var fs = require("fs"),
	path = require("path");

/*
Recursively (and synchronously) copy a directory and all its content
*/
exports.copyDirectory = function(srcPath,dstPath) {
	// Remove any trailing path separators
	srcPath = $tw.utils.removeTrailingSeparator(srcPath);
	dstPath = $tw.utils.removeTrailingSeparator(dstPath);
	// Create the destination directory
	var err = $tw.utils.createDirectory(dstPath);
	if(err) {
		return err;
	}
	// Function to copy a folder full of files
	var copy = function(srcPath,dstPath) {
		var srcStats = fs.lstatSync(srcPath),
			dstExists = fs.existsSync(dstPath);
		if(srcStats.isFile()) {
			$tw.utils.copyFile(srcPath,dstPath);
		} else if(srcStats.isDirectory()) {
			var items = fs.readdirSync(srcPath);
			for(var t=0; t<items.length; t++) {
				var item = items[t],
					err = copy(srcPath + path.sep + item,dstPath + path.sep + item);
				if(err) {
					return err;
				}
			}
		}
	};
	copy(srcPath,dstPath);
	return null;
};

/*
Copy a file
*/
var FILE_BUFFER_LENGTH = 64 * 1024,
	fileBuffer;

exports.copyFile = function(srcPath,dstPath) {
	// Create buffer if required
	if(!fileBuffer) {
		fileBuffer = Buffer.alloc(FILE_BUFFER_LENGTH);
	}
	// Create any directories in the destination
	$tw.utils.createDirectory(path.dirname(dstPath));
	// Copy the file
	var srcFile = fs.openSync(srcPath,"r"),
		dstFile = fs.openSync(dstPath,"w"),
		bytesRead = 1,
		pos = 0;
	while (bytesRead > 0) {
		bytesRead = fs.readSync(srcFile,fileBuffer,0,FILE_BUFFER_LENGTH,pos);
		fs.writeSync(dstFile,fileBuffer,0,bytesRead);
		pos += bytesRead;
	}
	fs.closeSync(srcFile);
	fs.closeSync(dstFile);
	return null;
};

/*
Remove trailing path separator
*/
exports.removeTrailingSeparator = function(dirPath) {
	var len = dirPath.length;
	if(dirPath.charAt(len-1) === path.sep) {
		dirPath = dirPath.substr(0,len-1);
	}
	return dirPath;
};

/*
Recursively create a directory
*/
exports.createDirectory = function(dirPath) {
	if(dirPath.substr(dirPath.length-1,1) !== path.sep) {
		dirPath = dirPath + path.sep;
	}
	var pos = 1;
	pos = dirPath.indexOf(path.sep,pos);
	while(pos !== -1) {
		var subDirPath = dirPath.substr(0,pos);
		if(!$tw.utils.isDirectory(subDirPath)) {
			try {
				fs.mkdirSync(subDirPath);
			} catch(e) {
				return "Error creating directory '" + subDirPath + "'";
			}
		}
		pos = dirPath.indexOf(path.sep,pos + 1);
	}
	return null;
};

/*
Recursively create directories needed to contain a specified file
*/
exports.createFileDirectories = function(filePath) {
	return $tw.utils.createDirectory(path.dirname(filePath));
};

/*
Recursively delete a directory
*/
exports.deleteDirectory = function(dirPath) {
	if(fs.existsSync(dirPath)) {
		var entries = fs.readdirSync(dirPath);
		for(var entryIndex=0; entryIndex<entries.length; entryIndex++) {
			var currPath = dirPath + path.sep + entries[entryIndex];
			if(fs.lstatSync(currPath).isDirectory()) {
				$tw.utils.deleteDirectory(currPath);
			} else {
				fs.unlinkSync(currPath);
			}
		}
	fs.rmdirSync(dirPath);
	}
	return null;
};

/*
Check if a path identifies a directory
*/
exports.isDirectory = function(dirPath) {
	return fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory();
};

/*
Check if a path identifies a directory that is empty
*/
exports.isDirectoryEmpty = function(dirPath) {
	if(!$tw.utils.isDirectory(dirPath)) {
		return false;
	}
	var files = fs.readdirSync(dirPath),
		empty = true;
	$tw.utils.each(files,function(file,index) {
		if(file.charAt(0) !== ".") {
			empty = false;
		}
	});
	return empty;
};

/*
Recursively delete a tree of empty directories
*/
exports.deleteEmptyDirs = function(dirpath,callback) {
	var self = this;
	fs.readdir(dirpath,function(err,files) {
		if(err) {
			return callback(err);
		}
		if(files.length > 0) {
			return callback(null);
		}
		fs.rmdir(dirpath,function(err) {
			if(err) {
				return callback(err);
			}
			self.deleteEmptyDirs(path.dirname(dirpath),callback);
		});
	});
};

/*
Create a fileInfo object for saving a tiddler:
	filepath: the absolute path to the file containing the tiddler
	type: the type of the tiddler file (NOT the type of the tiddler)
	hasMetaFile: true if the file also has a companion .meta file
Options include:
	directory: absolute path of root directory to which we are saving
	pathFilters: optional array of filters to be used to generate the base path
	wiki: optional wiki for evaluating the pathFilters
*/
exports.generateTiddlerFileInfo = function(tiddler,options) {
	var fileInfo = {};
	// Check if the tiddler has any unsafe fields that can't be expressed in a .tid or .meta file: containing control characters, or leading/trailing whitespace
	var hasUnsafeFields = false;
	$tw.utils.each(tiddler.getFieldStrings(),function(value,fieldName) {
		if(fieldName !== "text") {
			hasUnsafeFields = hasUnsafeFields || /[\x00-\x1F]/mg.test(value);
			hasUnsafeFields = hasUnsafeFields || ($tw.utils.trim(value) !== value);
		}
	});
	// Check for field values 
	if(hasUnsafeFields) {
		// Save as a JSON file
		fileInfo.type = "application/json";
		fileInfo.hasMetaFile = false;
	} else {
		// Save as a .tid or a text/binary file plus a .meta file
		var tiddlerType = tiddler.fields.type || "text/vnd.tiddlywiki";
		if(tiddlerType === "text/vnd.tiddlywiki") {
			// Save as a .tid file
			fileInfo.type = "application/x-tiddler";
			fileInfo.hasMetaFile = false;
		} else {
			// Save as a text/binary file and a .meta file
			fileInfo.type = tiddlerType;
			fileInfo.hasMetaFile = true;
		}
	}
	// Take the file extension from the tiddler content type
	var contentTypeInfo = $tw.config.contentTypeInfo[fileInfo.type] || {extension: ""};
	// Generate the filepath
	fileInfo.filepath = $tw.utils.generateTiddlerFilepath(tiddler.fields.title,{
		extension: contentTypeInfo.extension,
		directory: options.directory,
		pathFilters: options.pathFilters,
		wiki: options.wiki
	});
	return fileInfo;
};

/*
Generate the filepath for saving a tiddler
Options include:
	extension: file extension to be added the finished filepath
	directory: absolute path of root directory to which we are saving
	pathFilters: optional array of filters to be used to generate the base path
	wiki: optional wiki for evaluating the pathFilters
*/
exports.generateTiddlerFilepath = function(title,options) {
	var self = this,
		directory = options.directory || "",
		extension = options.extension || "",
		filepath;
	// Check if any of the pathFilters applies
	if(options.pathFilters && options.wiki) {
		$tw.utils.each(options.pathFilters,function(filter) {
			if(!filepath) {
				var source = options.wiki.makeTiddlerIterator([title]),
					result = options.wiki.filterTiddlers(filter,null,source);
				if(result.length > 0) {
					filepath = result[0];
				}
			}
		});
	}
	// If not, generate a base pathname
	if(!filepath) {
		filepath = title;
		// If the filepath already ends in the extension then remove it
		if(filepath.substring(filepath.length - extension.length) === extension) {
			filepath = filepath.substring(0,filepath.length - extension.length);
		}
		// Remove any forward or backward slashes so we don't create directories
		filepath = filepath.replace(/\/|\\/g,"_");
	}
	// Don't let the filename start with a dot because such files are invisible on *nix
	filepath = filepath.replace(/^\./g,"_");
	// Remove any characters that can't be used in cross-platform filenames
	filepath = $tw.utils.transliterate(filepath.replace(/<|>|\:|\"|\||\?|\*|\^/g,"_"));
	// Truncate the filename if it is too long
	if(filepath.length > 200) {
		filepath = filepath.substr(0,200);
	}
	// If the resulting filename is blank (eg because the title is just punctuation characters)
	if(!filepath) {
		// ...then just use the character codes of the title
		filepath = "";	
		$tw.utils.each(title.split(""),function(char) {
			if(filepath) {
				filepath += "-";
			}
			filepath += char.charCodeAt(0).toString();
		});
	}
	// Add a uniquifier if the file already exists
	var fullPath,
		count = 0;
	do {
		fullPath = path.resolve(directory,filepath + (count ? "_" + count : "") + extension);
		count++;
	} while(fs.existsSync(fullPath));
	// Return the full path to the file
	return fullPath;
};

/*
Save a tiddler to a file described by the fileInfo:
	filepath: the absolute path to the file containing the tiddler
	type: the type of the tiddler file (NOT the type of the tiddler)
	hasMetaFile: true if the file also has a companion .meta file
*/
exports.saveTiddlerToFile = function(tiddler,fileInfo,callback) {
	$tw.utils.createDirectory(path.dirname(fileInfo.filepath));
	if(fileInfo.hasMetaFile) {
		// Save the tiddler as a separate body and meta file
		var typeInfo = $tw.config.contentTypeInfo[tiddler.fields.type || "text/plain"] || {encoding: "utf8"};
		fs.writeFile(fileInfo.filepath,tiddler.fields.text,typeInfo.encoding,function(err) {
			if(err) {
				return callback(err);
			}
			fs.writeFile(fileInfo.filepath + ".meta",tiddler.getFieldStringBlock({exclude: ["text","bag"]}),"utf8",callback);
		});
	} else {
		// Save the tiddler as a self contained templated file
		if(fileInfo.type === "application/x-tiddler") {
			fs.writeFile(fileInfo.filepath,tiddler.getFieldStringBlock({exclude: ["text","bag"]}) + (!!tiddler.fields.text ? "\n\n" + tiddler.fields.text : ""),"utf8",callback);
		} else {
			fs.writeFile(fileInfo.filepath,JSON.stringify([tiddler.getFieldStrings({exclude: ["bag"]})],null,$tw.config.preferences.jsonSpaces),"utf8",callback);
		}
	}
};

/*
Save a tiddler to a file described by the fileInfo:
	filepath: the absolute path to the file containing the tiddler
	type: the type of the tiddler file (NOT the type of the tiddler)
	hasMetaFile: true if the file also has a companion .meta file
*/
exports.saveTiddlerToFileSync = function(tiddler,fileInfo) {
	$tw.utils.createDirectory(path.dirname(fileInfo.filepath));
	if(fileInfo.hasMetaFile) {
		// Save the tiddler as a separate body and meta file
		var typeInfo = $tw.config.contentTypeInfo[tiddler.fields.type || "text/plain"] || {encoding: "utf8"};
		fs.writeFileSync(fileInfo.filepath,tiddler.fields.text,typeInfo.encoding);
		fs.writeFileSync(fileInfo.filepath + ".meta",tiddler.getFieldStringBlock({exclude: ["text","bag"]}),"utf8");
	} else {
		// Save the tiddler as a self contained templated file
		if(fileInfo.type === "application/x-tiddler") {
			fs.writeFileSync(fileInfo.filepath,tiddler.getFieldStringBlock({exclude: ["text","bag"]}) + (!!tiddler.fields.text ? "\n\n" + tiddler.fields.text : ""),"utf8");
		} else {
			fs.writeFileSync(fileInfo.filepath,JSON.stringify([tiddler.getFieldStrings({exclude: ["bag"]})],null,$tw.config.preferences.jsonSpaces),"utf8");
		}
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/logger.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/logger.js
type: application/javascript
module-type: utils

A basic logging implementation

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ALERT_TAG = "$:/tags/Alert";

/*
Make a new logger
*/
function Logger(componentName,options) {
	options = options || {};
	this.componentName = componentName || "";
	this.colour = options.colour || "white";
	this.enable = "enable" in options ? options.enable : true;
}

/*
Log a message
*/
Logger.prototype.log = function(/* args */) {
	if(this.enable && console !== undefined && console.log !== undefined) {
		return Function.apply.call(console.log, console, [$tw.utils.terminalColour(this.colour),this.componentName + ":"].concat(Array.prototype.slice.call(arguments,0)).concat($tw.utils.terminalColour()));
	}
};

/*
Log a structure as a table
*/
Logger.prototype.table = function(value) {
	(console.table || console.log)(value);
};

/*
Alert a message
*/
Logger.prototype.alert = function(/* args */) {
	if(this.enable) {
		// Prepare the text of the alert
		var text = Array.prototype.join.call(arguments," ");
		// Create alert tiddlers in the browser
		if($tw.browser) {
			// Check if there is an existing alert with the same text and the same component
			var existingAlerts = $tw.wiki.getTiddlersWithTag(ALERT_TAG),
				alertFields,
				existingCount,
				self = this;
			$tw.utils.each(existingAlerts,function(title) {
				var tiddler = $tw.wiki.getTiddler(title);
				if(tiddler.fields.text === text && tiddler.fields.component === self.componentName && tiddler.fields.modified && (!alertFields || tiddler.fields.modified < alertFields.modified)) {
						alertFields = $tw.utils.extend({},tiddler.fields);
				}
			});
			if(alertFields) {
				existingCount = alertFields.count || 1;
			} else {
				alertFields = {
					title: $tw.wiki.generateNewTitle("$:/temp/alerts/alert",{prefix: ""}),
					text: text,
					tags: [ALERT_TAG],
					component: this.componentName
				};
				existingCount = 0;
			}
			alertFields.modified = new Date();
			if(++existingCount > 1) {
				alertFields.count = existingCount;
			} else {
				alertFields.count = undefined;
			}
			$tw.wiki.addTiddler(new $tw.Tiddler(alertFields));
			// Log the alert as well
			this.log.apply(this,Array.prototype.slice.call(arguments,0));
		} else {
			// Print an orange message to the console if not in the browser
			console.error("\x1b[1;33m" + text + "\x1b[0m");
		}		
	}
};

exports.Logger = Logger;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/parsetree.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/parsetree.js
type: application/javascript
module-type: utils

Parse tree utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.addAttributeToParseTreeNode = function(node,name,value) {
	node.attributes = node.attributes || {};
	node.attributes[name] = {type: "string", value: value};
};

exports.getAttributeValueFromParseTreeNode = function(node,name,defaultValue) {
	if(node.attributes && node.attributes[name] && node.attributes[name].value !== undefined) {
		return node.attributes[name].value;
	}
	return defaultValue;
};

exports.addClassToParseTreeNode = function(node,classString) {
	var classes = [];
	node.attributes = node.attributes || {};
	node.attributes["class"] = node.attributes["class"] || {type: "string", value: ""};
	if(node.attributes["class"].type === "string") {
		if(node.attributes["class"].value !== "") {
			classes = node.attributes["class"].value.split(" ");
		}
		if(classString !== "") {
			$tw.utils.pushTop(classes,classString.split(" "));
		}
		node.attributes["class"].value = classes.join(" ");
	}
};

exports.addStyleToParseTreeNode = function(node,name,value) {
		node.attributes = node.attributes || {};
		node.attributes.style = node.attributes.style || {type: "string", value: ""};
		if(node.attributes.style.type === "string") {
			node.attributes.style.value += name + ":" + value + ";";
		}
};

exports.findParseTreeNode = function(nodeArray,search) {
	for(var t=0; t<nodeArray.length; t++) {
		if(nodeArray[t].type === search.type && nodeArray[t].tag === search.tag) {
			return nodeArray[t];
		}
	}
	return undefined;
};

/*
Helper to get the text of a parse tree node or array of nodes
*/
exports.getParseTreeText = function getParseTreeText(tree) {
	var output = [];
	if($tw.utils.isArray(tree)) {
		$tw.utils.each(tree,function(node) {
			output.push(getParseTreeText(node));
		});
	} else {
		if(tree.type === "text") {
			output.push(tree.text);
		}
		if(tree.children) {
			return getParseTreeText(tree.children);
		}
	}
	return output.join("");
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/performance.js","global",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/performance.js
type: application/javascript
module-type: global

Performance measurement.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

function Performance(enabled) {
	this.enabled = !!enabled;
	this.measures = {}; // Hashmap by measurement name of {time:, invocations:}
	this.logger = new $tw.utils.Logger("performance");
	this.showGreeting();
}

Performance.prototype.showGreeting = function() {
	if($tw.browser) {
		this.logger.log("Execute $tw.perf.log(); to see filter execution timings");		
	}
};

/*
Wrap performance reporting around a top level function
*/
Performance.prototype.report = function(name,fn) {
	var self = this;
	if(this.enabled) {
		return function() {
			var startTime = $tw.utils.timer(),
				result = fn.apply(this,arguments);
			self.logger.log(name + ": " + $tw.utils.timer(startTime).toFixed(2) + "ms");
			return result;
		};
	} else {
		return fn;
	}
};

Performance.prototype.log = function() {
	var self = this,
		totalTime = 0,
		orderedMeasures = Object.keys(this.measures).sort(function(a,b) {
			if(self.measures[a].time > self.measures[b].time) {
				return -1;
			} else if (self.measures[a].time < self.measures[b].time) {
				return + 1;
			} else {
				return 0;
			}
		});
	$tw.utils.each(orderedMeasures,function(name) {
		totalTime += self.measures[name].time;
	});
	var results = []
	$tw.utils.each(orderedMeasures,function(name) {
		var measure = self.measures[name];
		results.push({name: name,invocations: measure.invocations, avgTime: measure.time / measure.invocations, totalTime: measure.time, percentTime: (measure.time / totalTime) * 100})
	});
	self.logger.table(results);
};

/*
Wrap performance measurements around a subfunction
*/
Performance.prototype.measure = function(name,fn) {
	var self = this;
	if(this.enabled) {
		return function() {
			var startTime = $tw.utils.timer(),
				result = fn.apply(this,arguments);
			if(!(name in self.measures)) {
				self.measures[name] = {time: 0, invocations: 0};
			}
			self.measures[name].time += $tw.utils.timer(startTime);
			self.measures[name].invocations++;
			return result;
		};
	} else {
		return fn;
	}
};

exports.Performance = Performance;

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/pluginmaker.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/pluginmaker.js
type: application/javascript
module-type: utils

A quick and dirty way to pack up plugins within the browser.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Repack a plugin, and then delete any non-shadow payload tiddlers
*/
exports.repackPlugin = function(title,additionalTiddlers,excludeTiddlers) {
	additionalTiddlers = additionalTiddlers || [];
	excludeTiddlers = excludeTiddlers || [];
	// Get the plugin tiddler
	var pluginTiddler = $tw.wiki.getTiddler(title);
	if(!pluginTiddler) {
		throw "No such tiddler as " + title;
	}
	// Extract the JSON
	var jsonPluginTiddler;
	try {
		jsonPluginTiddler = JSON.parse(pluginTiddler.fields.text);
	} catch(e) {
		throw "Cannot parse plugin tiddler " + title + "\n" + $tw.language.getString("Error/Caption") + ": " + e;
	}
	// Get the list of tiddlers
	var tiddlers = Object.keys(jsonPluginTiddler.tiddlers);
	// Add the additional tiddlers
	$tw.utils.pushTop(tiddlers,additionalTiddlers);
	// Remove any excluded tiddlers
	for(var t=tiddlers.length-1; t>=0; t--) {
		if(excludeTiddlers.indexOf(tiddlers[t]) !== -1) {
			tiddlers.splice(t,1);
		}
	}
	// Pack up the tiddlers into a block of JSON
	var plugins = {};
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = $tw.wiki.getTiddler(title),
			fields = {};
		$tw.utils.each(tiddler.fields,function (value,name) {
			fields[name] = tiddler.getFieldString(name);
		});
		plugins[title] = fields;
	});
	// Retrieve and bump the version number
	var pluginVersion = $tw.utils.parseVersion(pluginTiddler.getFieldString("version") || "0.0.0") || {
			major: "0",
			minor: "0",
			patch: "0"
		};
	pluginVersion.patch++;
	var version = pluginVersion.major + "." + pluginVersion.minor + "." + pluginVersion.patch;
	if(pluginVersion.prerelease) {
		version += "-" + pluginVersion.prerelease;
	}
	if(pluginVersion.build) {
		version += "+" + pluginVersion.build;
	}
	// Save the tiddler
	$tw.wiki.addTiddler(new $tw.Tiddler(pluginTiddler,{text: JSON.stringify({tiddlers: plugins},null,4), version: version}));
	// Delete any non-shadow constituent tiddlers
	$tw.utils.each(tiddlers,function(title) {
		if($tw.wiki.tiddlerExists(title)) {
			$tw.wiki.deleteTiddler(title);
		}
	});
	// Trigger an autosave
	$tw.rootWidget.dispatchEvent({type: "tm-auto-save-wiki"});
	// Return a heartwarming confirmation
	return "Plugin " + title + " successfully saved";
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/transliterate.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/transliterate.js
type: application/javascript
module-type: utils

Transliteration static utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Transliterate string to ASCII

(Some pairs taken from http://semplicewebsites.com/removing-accents-javascript)
*/
exports.transliterationPairs = {
	"Á":"A",
	"Ă":"A",
	"Ắ":"A",
	"Ặ":"A",
	"Ằ":"A",
	"Ẳ":"A",
	"Ẵ":"A",
	"Ǎ":"A",
	"Â":"A",
	"Ấ":"A",
	"Ậ":"A",
	"Ầ":"A",
	"Ẩ":"A",
	"Ẫ":"A",
	"Ä":"A",
	"Ǟ":"A",
	"Ȧ":"A",
	"Ǡ":"A",
	"Ạ":"A",
	"Ȁ":"A",
	"À":"A",
	"Ả":"A",
	"Ȃ":"A",
	"Ā":"A",
	"Ą":"A",
	"Å":"A",
	"Ǻ":"A",
	"Ḁ":"A",
	"Ⱥ":"A",
	"Ã":"A",
	"Ꜳ":"AA",
	"Æ":"AE",
	"Ǽ":"AE",
	"Ǣ":"AE",
	"Ꜵ":"AO",
	"Ꜷ":"AU",
	"Ꜹ":"AV",
	"Ꜻ":"AV",
	"Ꜽ":"AY",
	"Ḃ":"B",
	"Ḅ":"B",
	"Ɓ":"B",
	"Ḇ":"B",
	"Ƀ":"B",
	"Ƃ":"B",
	"Ć":"C",
	"Č":"C",
	"Ç":"C",
	"Ḉ":"C",
	"Ĉ":"C",
	"Ċ":"C",
	"Ƈ":"C",
	"Ȼ":"C",
	"Ď":"D",
	"Ḑ":"D",
	"Ḓ":"D",
	"Ḋ":"D",
	"Ḍ":"D",
	"Ɗ":"D",
	"Ḏ":"D",
	"ǲ":"D",
	"ǅ":"D",
	"Đ":"D",
	"Ƌ":"D",
	"Ǳ":"DZ",
	"Ǆ":"DZ",
	"É":"E",
	"Ĕ":"E",
	"Ě":"E",
	"Ȩ":"E",
	"Ḝ":"E",
	"Ê":"E",
	"Ế":"E",
	"Ệ":"E",
	"Ề":"E",
	"Ể":"E",
	"Ễ":"E",
	"Ḙ":"E",
	"Ë":"E",
	"Ė":"E",
	"Ẹ":"E",
	"Ȅ":"E",
	"È":"E",
	"Ẻ":"E",
	"Ȇ":"E",
	"Ē":"E",
	"Ḗ":"E",
	"Ḕ":"E",
	"Ę":"E",
	"Ɇ":"E",
	"Ẽ":"E",
	"Ḛ":"E",
	"Ꝫ":"ET",
	"Ḟ":"F",
	"Ƒ":"F",
	"Ǵ":"G",
	"Ğ":"G",
	"Ǧ":"G",
	"Ģ":"G",
	"Ĝ":"G",
	"Ġ":"G",
	"Ɠ":"G",
	"Ḡ":"G",
	"Ǥ":"G",
	"Ḫ":"H",
	"Ȟ":"H",
	"Ḩ":"H",
	"Ĥ":"H",
	"Ⱨ":"H",
	"Ḧ":"H",
	"Ḣ":"H",
	"Ḥ":"H",
	"Ħ":"H",
	"Í":"I",
	"Ĭ":"I",
	"Ǐ":"I",
	"Î":"I",
	"Ï":"I",
	"Ḯ":"I",
	"İ":"I",
	"Ị":"I",
	"Ȉ":"I",
	"Ì":"I",
	"Ỉ":"I",
	"Ȋ":"I",
	"Ī":"I",
	"Į":"I",
	"Ɨ":"I",
	"Ĩ":"I",
	"Ḭ":"I",
	"Ꝺ":"D",
	"Ꝼ":"F",
	"Ᵹ":"G",
	"Ꞃ":"R",
	"Ꞅ":"S",
	"Ꞇ":"T",
	"Ꝭ":"IS",
	"Ĵ":"J",
	"Ɉ":"J",
	"Ḱ":"K",
	"Ǩ":"K",
	"Ķ":"K",
	"Ⱪ":"K",
	"Ꝃ":"K",
	"Ḳ":"K",
	"Ƙ":"K",
	"Ḵ":"K",
	"Ꝁ":"K",
	"Ꝅ":"K",
	"Ĺ":"L",
	"Ƚ":"L",
	"Ľ":"L",
	"Ļ":"L",
	"Ḽ":"L",
	"Ḷ":"L",
	"Ḹ":"L",
	"Ⱡ":"L",
	"Ꝉ":"L",
	"Ḻ":"L",
	"Ŀ":"L",
	"Ɫ":"L",
	"ǈ":"L",
	"Ł":"L",
	"Ǉ":"LJ",
	"Ḿ":"M",
	"Ṁ":"M",
	"Ṃ":"M",
	"Ɱ":"M",
	"Ń":"N",
	"Ň":"N",
	"Ņ":"N",
	"Ṋ":"N",
	"Ṅ":"N",
	"Ṇ":"N",
	"Ǹ":"N",
	"Ɲ":"N",
	"Ṉ":"N",
	"Ƞ":"N",
	"ǋ":"N",
	"Ñ":"N",
	"Ǌ":"NJ",
	"Ó":"O",
	"Ŏ":"O",
	"Ǒ":"O",
	"Ô":"O",
	"Ố":"O",
	"Ộ":"O",
	"Ồ":"O",
	"Ổ":"O",
	"Ỗ":"O",
	"Ö":"O",
	"Ȫ":"O",
	"Ȯ":"O",
	"Ȱ":"O",
	"Ọ":"O",
	"Ő":"O",
	"Ȍ":"O",
	"Ò":"O",
	"Ỏ":"O",
	"Ơ":"O",
	"Ớ":"O",
	"Ợ":"O",
	"Ờ":"O",
	"Ở":"O",
	"Ỡ":"O",
	"Ȏ":"O",
	"Ꝋ":"O",
	"Ꝍ":"O",
	"Ō":"O",
	"Ṓ":"O",
	"Ṑ":"O",
	"Ɵ":"O",
	"Ǫ":"O",
	"Ǭ":"O",
	"Ø":"O",
	"Ǿ":"O",
	"Õ":"O",
	"Ṍ":"O",
	"Ṏ":"O",
	"Ȭ":"O",
	"Ƣ":"OI",
	"Ꝏ":"OO",
	"Ɛ":"E",
	"Ɔ":"O",
	"Ȣ":"OU",
	"Ṕ":"P",
	"Ṗ":"P",
	"Ꝓ":"P",
	"Ƥ":"P",
	"Ꝕ":"P",
	"Ᵽ":"P",
	"Ꝑ":"P",
	"Ꝙ":"Q",
	"Ꝗ":"Q",
	"Ŕ":"R",
	"Ř":"R",
	"Ŗ":"R",
	"Ṙ":"R",
	"Ṛ":"R",
	"Ṝ":"R",
	"Ȑ":"R",
	"Ȓ":"R",
	"Ṟ":"R",
	"Ɍ":"R",
	"Ɽ":"R",
	"Ꜿ":"C",
	"Ǝ":"E",
	"Ś":"S",
	"Ṥ":"S",
	"Š":"S",
	"Ṧ":"S",
	"Ş":"S",
	"Ŝ":"S",
	"Ș":"S",
	"Ṡ":"S",
	"Ṣ":"S",
	"Ṩ":"S",
	"Ť":"T",
	"Ţ":"T",
	"Ṱ":"T",
	"Ț":"T",
	"Ⱦ":"T",
	"Ṫ":"T",
	"Ṭ":"T",
	"Ƭ":"T",
	"Ṯ":"T",
	"Ʈ":"T",
	"Ŧ":"T",
	"Ɐ":"A",
	"Ꞁ":"L",
	"Ɯ":"M",
	"Ʌ":"V",
	"Ꜩ":"TZ",
	"Ú":"U",
	"Ŭ":"U",
	"Ǔ":"U",
	"Û":"U",
	"Ṷ":"U",
	"Ü":"U",
	"Ǘ":"U",
	"Ǚ":"U",
	"Ǜ":"U",
	"Ǖ":"U",
	"Ṳ":"U",
	"Ụ":"U",
	"Ű":"U",
	"Ȕ":"U",
	"Ù":"U",
	"Ủ":"U",
	"Ư":"U",
	"Ứ":"U",
	"Ự":"U",
	"Ừ":"U",
	"Ử":"U",
	"Ữ":"U",
	"Ȗ":"U",
	"Ū":"U",
	"Ṻ":"U",
	"Ų":"U",
	"Ů":"U",
	"Ũ":"U",
	"Ṹ":"U",
	"Ṵ":"U",
	"Ꝟ":"V",
	"Ṿ":"V",
	"Ʋ":"V",
	"Ṽ":"V",
	"Ꝡ":"VY",
	"Ẃ":"W",
	"Ŵ":"W",
	"Ẅ":"W",
	"Ẇ":"W",
	"Ẉ":"W",
	"Ẁ":"W",
	"Ⱳ":"W",
	"Ẍ":"X",
	"Ẋ":"X",
	"Ý":"Y",
	"Ŷ":"Y",
	"Ÿ":"Y",
	"Ẏ":"Y",
	"Ỵ":"Y",
	"Ỳ":"Y",
	"Ƴ":"Y",
	"Ỷ":"Y",
	"Ỿ":"Y",
	"Ȳ":"Y",
	"Ɏ":"Y",
	"Ỹ":"Y",
	"Ź":"Z",
	"Ž":"Z",
	"Ẑ":"Z",
	"Ⱬ":"Z",
	"Ż":"Z",
	"Ẓ":"Z",
	"Ȥ":"Z",
	"Ẕ":"Z",
	"Ƶ":"Z",
	"Ĳ":"IJ",
	"Œ":"OE",
	"ᴀ":"A",
	"ᴁ":"AE",
	"ʙ":"B",
	"ᴃ":"B",
	"ᴄ":"C",
	"ᴅ":"D",
	"ᴇ":"E",
	"ꜰ":"F",
	"ɢ":"G",
	"ʛ":"G",
	"ʜ":"H",
	"ɪ":"I",
	"ʁ":"R",
	"ᴊ":"J",
	"ᴋ":"K",
	"ʟ":"L",
	"ᴌ":"L",
	"ᴍ":"M",
	"ɴ":"N",
	"ᴏ":"O",
	"ɶ":"OE",
	"ᴐ":"O",
	"ᴕ":"OU",
	"ᴘ":"P",
	"ʀ":"R",
	"ᴎ":"N",
	"ᴙ":"R",
	"ꜱ":"S",
	"ᴛ":"T",
	"ⱻ":"E",
	"ᴚ":"R",
	"ᴜ":"U",
	"ᴠ":"V",
	"ᴡ":"W",
	"ʏ":"Y",
	"ᴢ":"Z",
	"á":"a",
	"ă":"a",
	"ắ":"a",
	"ặ":"a",
	"ằ":"a",
	"ẳ":"a",
	"ẵ":"a",
	"ǎ":"a",
	"â":"a",
	"ấ":"a",
	"ậ":"a",
	"ầ":"a",
	"ẩ":"a",
	"ẫ":"a",
	"ä":"a",
	"ǟ":"a",
	"ȧ":"a",
	"ǡ":"a",
	"ạ":"a",
	"ȁ":"a",
	"à":"a",
	"ả":"a",
	"ȃ":"a",
	"ā":"a",
	"ą":"a",
	"ᶏ":"a",
	"ẚ":"a",
	"å":"a",
	"ǻ":"a",
	"ḁ":"a",
	"ⱥ":"a",
	"ã":"a",
	"ꜳ":"aa",
	"æ":"ae",
	"ǽ":"ae",
	"ǣ":"ae",
	"ꜵ":"ao",
	"ꜷ":"au",
	"ꜹ":"av",
	"ꜻ":"av",
	"ꜽ":"ay",
	"ḃ":"b",
	"ḅ":"b",
	"ɓ":"b",
	"ḇ":"b",
	"ᵬ":"b",
	"ᶀ":"b",
	"ƀ":"b",
	"ƃ":"b",
	"ɵ":"o",
	"ć":"c",
	"č":"c",
	"ç":"c",
	"ḉ":"c",
	"ĉ":"c",
	"ɕ":"c",
	"ċ":"c",
	"ƈ":"c",
	"ȼ":"c",
	"ď":"d",
	"ḑ":"d",
	"ḓ":"d",
	"ȡ":"d",
	"ḋ":"d",
	"ḍ":"d",
	"ɗ":"d",
	"ᶑ":"d",
	"ḏ":"d",
	"ᵭ":"d",
	"ᶁ":"d",
	"đ":"d",
	"ɖ":"d",
	"ƌ":"d",
	"ı":"i",
	"ȷ":"j",
	"ɟ":"j",
	"ʄ":"j",
	"ǳ":"dz",
	"ǆ":"dz",
	"é":"e",
	"ĕ":"e",
	"ě":"e",
	"ȩ":"e",
	"ḝ":"e",
	"ê":"e",
	"ế":"e",
	"ệ":"e",
	"ề":"e",
	"ể":"e",
	"ễ":"e",
	"ḙ":"e",
	"ë":"e",
	"ė":"e",
	"ẹ":"e",
	"ȅ":"e",
	"è":"e",
	"ẻ":"e",
	"ȇ":"e",
	"ē":"e",
	"ḗ":"e",
	"ḕ":"e",
	"ⱸ":"e",
	"ę":"e",
	"ᶒ":"e",
	"ɇ":"e",
	"ẽ":"e",
	"ḛ":"e",
	"ꝫ":"et",
	"ḟ":"f",
	"ƒ":"f",
	"ᵮ":"f",
	"ᶂ":"f",
	"ǵ":"g",
	"ğ":"g",
	"ǧ":"g",
	"ģ":"g",
	"ĝ":"g",
	"ġ":"g",
	"ɠ":"g",
	"ḡ":"g",
	"ᶃ":"g",
	"ǥ":"g",
	"ḫ":"h",
	"ȟ":"h",
	"ḩ":"h",
	"ĥ":"h",
	"ⱨ":"h",
	"ḧ":"h",
	"ḣ":"h",
	"ḥ":"h",
	"ɦ":"h",
	"ẖ":"h",
	"ħ":"h",
	"ƕ":"hv",
	"í":"i",
	"ĭ":"i",
	"ǐ":"i",
	"î":"i",
	"ï":"i",
	"ḯ":"i",
	"ị":"i",
	"ȉ":"i",
	"ì":"i",
	"ỉ":"i",
	"ȋ":"i",
	"ī":"i",
	"į":"i",
	"ᶖ":"i",
	"ɨ":"i",
	"ĩ":"i",
	"ḭ":"i",
	"ꝺ":"d",
	"ꝼ":"f",
	"ᵹ":"g",
	"ꞃ":"r",
	"ꞅ":"s",
	"ꞇ":"t",
	"ꝭ":"is",
	"ǰ":"j",
	"ĵ":"j",
	"ʝ":"j",
	"ɉ":"j",
	"ḱ":"k",
	"ǩ":"k",
	"ķ":"k",
	"ⱪ":"k",
	"ꝃ":"k",
	"ḳ":"k",
	"ƙ":"k",
	"ḵ":"k",
	"ᶄ":"k",
	"ꝁ":"k",
	"ꝅ":"k",
	"ĺ":"l",
	"ƚ":"l",
	"ɬ":"l",
	"ľ":"l",
	"ļ":"l",
	"ḽ":"l",
	"ȴ":"l",
	"ḷ":"l",
	"ḹ":"l",
	"ⱡ":"l",
	"ꝉ":"l",
	"ḻ":"l",
	"ŀ":"l",
	"ɫ":"l",
	"ᶅ":"l",
	"ɭ":"l",
	"ł":"l",
	"ǉ":"lj",
	"ſ":"s",
	"ẜ":"s",
	"ẛ":"s",
	"ẝ":"s",
	"ḿ":"m",
	"ṁ":"m",
	"ṃ":"m",
	"ɱ":"m",
	"ᵯ":"m",
	"ᶆ":"m",
	"ń":"n",
	"ň":"n",
	"ņ":"n",
	"ṋ":"n",
	"ȵ":"n",
	"ṅ":"n",
	"ṇ":"n",
	"ǹ":"n",
	"ɲ":"n",
	"ṉ":"n",
	"ƞ":"n",
	"ᵰ":"n",
	"ᶇ":"n",
	"ɳ":"n",
	"ñ":"n",
	"ǌ":"nj",
	"ó":"o",
	"ŏ":"o",
	"ǒ":"o",
	"ô":"o",
	"ố":"o",
	"ộ":"o",
	"ồ":"o",
	"ổ":"o",
	"ỗ":"o",
	"ö":"o",
	"ȫ":"o",
	"ȯ":"o",
	"ȱ":"o",
	"ọ":"o",
	"ő":"o",
	"ȍ":"o",
	"ò":"o",
	"ỏ":"o",
	"ơ":"o",
	"ớ":"o",
	"ợ":"o",
	"ờ":"o",
	"ở":"o",
	"ỡ":"o",
	"ȏ":"o",
	"ꝋ":"o",
	"ꝍ":"o",
	"ⱺ":"o",
	"ō":"o",
	"ṓ":"o",
	"ṑ":"o",
	"ǫ":"o",
	"ǭ":"o",
	"ø":"o",
	"ǿ":"o",
	"õ":"o",
	"ṍ":"o",
	"ṏ":"o",
	"ȭ":"o",
	"ƣ":"oi",
	"ꝏ":"oo",
	"ɛ":"e",
	"ᶓ":"e",
	"ɔ":"o",
	"ᶗ":"o",
	"ȣ":"ou",
	"ṕ":"p",
	"ṗ":"p",
	"ꝓ":"p",
	"ƥ":"p",
	"ᵱ":"p",
	"ᶈ":"p",
	"ꝕ":"p",
	"ᵽ":"p",
	"ꝑ":"p",
	"ꝙ":"q",
	"ʠ":"q",
	"ɋ":"q",
	"ꝗ":"q",
	"ŕ":"r",
	"ř":"r",
	"ŗ":"r",
	"ṙ":"r",
	"ṛ":"r",
	"ṝ":"r",
	"ȑ":"r",
	"ɾ":"r",
	"ᵳ":"r",
	"ȓ":"r",
	"ṟ":"r",
	"ɼ":"r",
	"ᵲ":"r",
	"ᶉ":"r",
	"ɍ":"r",
	"ɽ":"r",
	"ↄ":"c",
	"ꜿ":"c",
	"ɘ":"e",
	"ɿ":"r",
	"ś":"s",
	"ṥ":"s",
	"š":"s",
	"ṧ":"s",
	"ş":"s",
	"ŝ":"s",
	"ș":"s",
	"ṡ":"s",
	"ṣ":"s",
	"ṩ":"s",
	"ʂ":"s",
	"ᵴ":"s",
	"ᶊ":"s",
	"ȿ":"s",
	"ɡ":"g",
	"ᴑ":"o",
	"ᴓ":"o",
	"ᴝ":"u",
	"ť":"t",
	"ţ":"t",
	"ṱ":"t",
	"ț":"t",
	"ȶ":"t",
	"ẗ":"t",
	"ⱦ":"t",
	"ṫ":"t",
	"ṭ":"t",
	"ƭ":"t",
	"ṯ":"t",
	"ᵵ":"t",
	"ƫ":"t",
	"ʈ":"t",
	"ŧ":"t",
	"ᵺ":"th",
	"ɐ":"a",
	"ᴂ":"ae",
	"ǝ":"e",
	"ᵷ":"g",
	"ɥ":"h",
	"ʮ":"h",
	"ʯ":"h",
	"ᴉ":"i",
	"ʞ":"k",
	"ꞁ":"l",
	"ɯ":"m",
	"ɰ":"m",
	"ᴔ":"oe",
	"ɹ":"r",
	"ɻ":"r",
	"ɺ":"r",
	"ⱹ":"r",
	"ʇ":"t",
	"ʌ":"v",
	"ʍ":"w",
	"ʎ":"y",
	"ꜩ":"tz",
	"ú":"u",
	"ŭ":"u",
	"ǔ":"u",
	"û":"u",
	"ṷ":"u",
	"ü":"u",
	"ǘ":"u",
	"ǚ":"u",
	"ǜ":"u",
	"ǖ":"u",
	"ṳ":"u",
	"ụ":"u",
	"ű":"u",
	"ȕ":"u",
	"ù":"u",
	"ủ":"u",
	"ư":"u",
	"ứ":"u",
	"ự":"u",
	"ừ":"u",
	"ử":"u",
	"ữ":"u",
	"ȗ":"u",
	"ū":"u",
	"ṻ":"u",
	"ų":"u",
	"ᶙ":"u",
	"ů":"u",
	"ũ":"u",
	"ṹ":"u",
	"ṵ":"u",
	"ᵫ":"ue",
	"ꝸ":"um",
	"ⱴ":"v",
	"ꝟ":"v",
	"ṿ":"v",
	"ʋ":"v",
	"ᶌ":"v",
	"ⱱ":"v",
	"ṽ":"v",
	"ꝡ":"vy",
	"ẃ":"w",
	"ŵ":"w",
	"ẅ":"w",
	"ẇ":"w",
	"ẉ":"w",
	"ẁ":"w",
	"ⱳ":"w",
	"ẘ":"w",
	"ẍ":"x",
	"ẋ":"x",
	"ᶍ":"x",
	"ý":"y",
	"ŷ":"y",
	"ÿ":"y",
	"ẏ":"y",
	"ỵ":"y",
	"ỳ":"y",
	"ƴ":"y",
	"ỷ":"y",
	"ỿ":"y",
	"ȳ":"y",
	"ẙ":"y",
	"ɏ":"y",
	"ỹ":"y",
	"ź":"z",
	"ž":"z",
	"ẑ":"z",
	"ʑ":"z",
	"ⱬ":"z",
	"ż":"z",
	"ẓ":"z",
	"ȥ":"z",
	"ẕ":"z",
	"ᵶ":"z",
	"ᶎ":"z",
	"ʐ":"z",
	"ƶ":"z",
	"ɀ":"z",
	"ﬀ":"ff",
	"ﬃ":"ffi",
	"ﬄ":"ffl",
	"ﬁ":"fi",
	"ﬂ":"fl",
	"ĳ":"ij",
	"œ":"oe",
	"ﬆ":"st",
	"ₐ":"a",
	"ₑ":"e",
	"ᵢ":"i",
	"ⱼ":"j",
	"ₒ":"o",
	"ᵣ":"r",
	"ᵤ":"u",
	"ᵥ":"v",
	"ₓ":"x",
	"Ё":"YO",
	"Й":"I",
	"Ц":"TS",
	"У":"U",
	"К":"K",
	"Е":"E",
	"Н":"N",
	"Г":"G",
	"Ш":"SH",
	"Щ":"SCH",
	"З":"Z",
	"Х":"H",
	"Ъ":"'",
	"ё":"yo",
	"й":"i",
	"ц":"ts",
	"у":"u",
	"к":"k",
	"е":"e",
	"н":"n",
	"г":"g",
	"ш":"sh",
	"щ":"sch",
	"з":"z",
	"х":"h",
	"ъ":"'",
	"Ф":"F",
	"Ы":"I",
	"В":"V",
	"А":"a",
	"П":"P",
	"Р":"R",
	"О":"O",
	"Л":"L",
	"Д":"D",
	"Ж":"ZH",
	"Э":"E",
	"ф":"f",
	"ы":"i",
	"в":"v",
	"а":"a",
	"п":"p",
	"р":"r",
	"о":"o",
	"л":"l",
	"д":"d",
	"ж":"zh",
	"э":"e",
	"Я":"Ya",
	"Ч":"CH",
	"С":"S",
	"М":"M",
	"И":"I",
	"Т":"T",
	"Ь":"'",
	"Б":"B",
	"Ю":"YU",
	"я":"ya",
	"ч":"ch",
	"с":"s",
	"м":"m",
	"и":"i",
	"т":"t",
	"ь":"'",
	"б":"b",
	"ю":"yu"
};

exports.transliterate = function(str) {
	return str.replace(/[^A-Za-z0-9\[\] ]/g,function(ch) {
		return exports.transliterationPairs[ch] || ch
	});
};

exports.transliterateToSafeASCII = function(str) {
	return str.replace(/[^\x00-\x7F]/g,function(ch) {
		return exports.transliterationPairs[ch] || ""
	});
};

})();

;})();
return exports;
}));
_define("$:/core/modules/utils/utils.js","utils",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/utils/utils.js
type: application/javascript
module-type: utils

Various static utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var base64utf8 = require("$:/core/modules/utils/base64-utf8/base64-utf8.module.js");

/*
Display a message, in colour if we're on a terminal
*/
exports.log = function(text,colour) {
	console.log($tw.node ? exports.terminalColour(colour) + text + exports.terminalColour() : text);
};

exports.terminalColour = function(colour) {
	if(!$tw.browser && $tw.node && process.stdout.isTTY) {
		if(colour) {
			var code = exports.terminalColourLookup[colour];
			if(code) {
				return "\x1b[" + code + "m";
			}
		} else {
			return "\x1b[0m"; // Cancel colour
		}
	}
	return "";
};

exports.terminalColourLookup = {
	"black": "0;30",
	"red": "0;31",
	"green": "0;32",
	"brown/orange": "0;33",
	"blue": "0;34",
	"purple": "0;35",
	"cyan": "0;36",
	"light gray": "0;37"
};

/*
Display a warning, in colour if we're on a terminal
*/
exports.warning = function(text) {
	exports.log(text,"brown/orange");
};

/*
Return the integer represented by the str (string).
Return the dflt (default) parameter if str is not a base-10 number.
*/
exports.getInt = function(str,deflt) {
	var i = parseInt(str,10);
	return isNaN(i) ? deflt : i;
}

/*
Repeatedly replaces a substring within a string. Like String.prototype.replace, but without any of the default special handling of $ sequences in the replace string
*/
exports.replaceString = function(text,search,replace) {
	return text.replace(search,function() {
		return replace;
	});
};

/*
Repeats a string
*/
exports.repeat = function(str,count) {
	var result = "";
	for(var t=0;t<count;t++) {
		result += str;
	}
	return result;
};

/*
Trim whitespace from the start and end of a string
Thanks to Steven Levithan, http://blog.stevenlevithan.com/archives/faster-trim-javascript
*/
exports.trim = function(str) {
	if(typeof str === "string") {
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	} else {
		return str;
	}
};

/*
Convert a string to sentence case (ie capitalise first letter)
*/
exports.toSentenceCase = function(str) {
	return (str || "").replace(/^\S/, function(c) {return c.toUpperCase();});
}

/*
Convert a string to title case (ie capitalise each initial letter)
*/
exports.toTitleCase = function(str) {
	return (str || "").replace(/(^|\s)\S/g, function(c) {return c.toUpperCase();});
}
	
/*
Find the line break preceding a given position in a string
Returns position immediately after that line break, or the start of the string
*/
exports.findPrecedingLineBreak = function(text,pos) {
	var result = text.lastIndexOf("\n",pos - 1);
	if(result === -1) {
		result = 0;
	} else {
		result++;
		if(text.charAt(result) === "\r") {
			result++;
		}
	}
	return result;
};

/*
Find the line break following a given position in a string
*/
exports.findFollowingLineBreak = function(text,pos) {
	// Cut to just past the following line break, or to the end of the text
	var result = text.indexOf("\n",pos);
	if(result === -1) {
		result = text.length;
	} else {
		if(text.charAt(result) === "\r") {
			result++;
		}
	}
	return result;
};

/*
Return the number of keys in an object
*/
exports.count = function(object) {
	return Object.keys(object || {}).length;
};

/*
Determine whether an array-item is an object-property
*/
exports.hopArray = function(object,array) {
	for(var i=0; i<array.length; i++) {
		if($tw.utils.hop(object,array[i])) {
			return true;
		}
	}
	return false;
};

/*
Remove entries from an array
	array: array to modify
	value: a single value to remove, or an array of values to remove
*/
exports.removeArrayEntries = function(array,value) {
	var t,p;
	if($tw.utils.isArray(value)) {
		for(t=0; t<value.length; t++) {
			p = array.indexOf(value[t]);
			if(p !== -1) {
				array.splice(p,1);
			}
		}
	} else {
		p = array.indexOf(value);
		if(p !== -1) {
			array.splice(p,1);
		}
	}
};

/*
Check whether any members of a hashmap are present in another hashmap
*/
exports.checkDependencies = function(dependencies,changes) {
	var hit = false;
	$tw.utils.each(changes,function(change,title) {
		if($tw.utils.hop(dependencies,title)) {
			hit = true;
		}
	});
	return hit;
};

exports.extend = function(object /* [, src] */) {
	$tw.utils.each(Array.prototype.slice.call(arguments, 1), function(source) {
		if(source) {
			for(var property in source) {
				object[property] = source[property];
			}
		}
	});
	return object;
};

exports.deepCopy = function(object) {
	var result,t;
	if($tw.utils.isArray(object)) {
		// Copy arrays
		result = object.slice(0);
	} else if(typeof object === "object") {
		result = {};
		for(t in object) {
			if(object[t] !== undefined) {
				result[t] = $tw.utils.deepCopy(object[t]);
			}
		}
	} else {
		result = object;
	}
	return result;
};

exports.extendDeepCopy = function(object,extendedProperties) {
	var result = $tw.utils.deepCopy(object),t;
	for(t in extendedProperties) {
		if(extendedProperties[t] !== undefined) {
			result[t] = $tw.utils.deepCopy(extendedProperties[t]);
		}
	}
	return result;
};

exports.deepFreeze = function deepFreeze(object) {
	var property, key;
	if(object) {
		Object.freeze(object);
		for(key in object) {
			property = object[key];
			if($tw.utils.hop(object,key) && (typeof property === "object") && !Object.isFrozen(property)) {
				deepFreeze(property);
			}
		}
	}
};

exports.slowInSlowOut = function(t) {
	return (1 - ((Math.cos(t * Math.PI) + 1) / 2));
};

exports.formatDateString = function(date,template) {
	var result = "",
		t = template,
		matches = [
			[/^0hh12/, function() {
				return $tw.utils.pad($tw.utils.getHours12(date));
			}],
			[/^wYYYY/, function() {
				return $tw.utils.getYearForWeekNo(date);
			}],
			[/^hh12/, function() {
				return $tw.utils.getHours12(date);
			}],
			[/^DDth/, function() {
				return date.getDate() + $tw.utils.getDaySuffix(date);
			}],
			[/^YYYY/, function() {
				return date.getFullYear();
			}],
			[/^0hh/, function() {
				return $tw.utils.pad(date.getHours());
			}],
			[/^0mm/, function() {
				return $tw.utils.pad(date.getMinutes());
			}],
			[/^0ss/, function() {
				return $tw.utils.pad(date.getSeconds());
			}],
			[/^0XXX/, function() {
				return $tw.utils.pad(date.getMilliseconds());
			}],
			[/^0DD/, function() {
				return $tw.utils.pad(date.getDate());
			}],
			[/^0MM/, function() {
				return $tw.utils.pad(date.getMonth()+1);
			}],
			[/^0WW/, function() {
				return $tw.utils.pad($tw.utils.getWeek(date));
			}],
			[/^ddd/, function() {
				return $tw.language.getString("Date/Short/Day/" + date.getDay());
			}],
			[/^mmm/, function() {
				return $tw.language.getString("Date/Short/Month/" + (date.getMonth() + 1));
			}],
			[/^DDD/, function() {
				return $tw.language.getString("Date/Long/Day/" + date.getDay());
			}],
			[/^MMM/, function() {
				return $tw.language.getString("Date/Long/Month/" + (date.getMonth() + 1));
			}],
			[/^TZD/, function() {
				var tz = date.getTimezoneOffset(),
				atz = Math.abs(tz);
				return (tz < 0 ? '+' : '-') + $tw.utils.pad(Math.floor(atz / 60)) + ':' + $tw.utils.pad(atz % 60);
			}],
			[/^wYY/, function() {
				return $tw.utils.pad($tw.utils.getYearForWeekNo(date) - 2000);
			}],
			[/^[ap]m/, function() {
				return $tw.utils.getAmPm(date).toLowerCase();
			}],
			[/^hh/, function() {
				return date.getHours();
			}],
			[/^mm/, function() {
				return date.getMinutes();
			}],
			[/^ss/, function() {
				return date.getSeconds();
			}],
			[/^XXX/, function() {
				return date.getMilliseconds();
			}],
			[/^[AP]M/, function() {
				return $tw.utils.getAmPm(date).toUpperCase();
			}],
			[/^DD/, function() {
				return date.getDate();
			}],
			[/^MM/, function() {
				return date.getMonth() + 1;
			}],
			[/^WW/, function() {
				return $tw.utils.getWeek(date);
			}],
			[/^YY/, function() {
				return $tw.utils.pad(date.getFullYear() - 2000);
			}]
		];
	// If the user wants everything in UTC, shift the datestamp
	// Optimize for format string that essentially means
	// 'return raw UTC (tiddlywiki style) date string.'
	if(t.indexOf("[UTC]") == 0 ) {
		if(t == "[UTC]YYYY0MM0DD0hh0mm0ssXXX")
			return $tw.utils.stringifyDate(new Date());
		var offset = date.getTimezoneOffset() ; // in minutes
		date = new Date(date.getTime()+offset*60*1000) ;
		t = t.substr(5) ;
	}
	while(t.length){
		var matchString = "";
		$tw.utils.each(matches, function(m) {
			var match = m[0].exec(t);
			if(match) {
				matchString = m[1].call();
				t = t.substr(match[0].length);
				return false;
			}
		});
		if(matchString) {
			result += matchString;
		} else {
			result += t.charAt(0);
			t = t.substr(1);
		}
	}
	result = result.replace(/\\(.)/g,"$1");
	return result;
};

exports.getAmPm = function(date) {
	return $tw.language.getString("Date/Period/" + (date.getHours() >= 12 ? "pm" : "am"));
};

exports.getDaySuffix = function(date) {
	return $tw.language.getString("Date/DaySuffix/" + date.getDate());
};

exports.getWeek = function(date) {
	var dt = new Date(date.getTime());
	var d = dt.getDay();
	if(d === 0) {
		d = 7; // JavaScript Sun=0, ISO Sun=7
	}
	dt.setTime(dt.getTime() + (4 - d) * 86400000);// shift day to Thurs of same week to calculate weekNo
	var x = new Date(dt.getFullYear(),0,1);
	var n = Math.floor((dt.getTime() - x.getTime()) / 86400000);
	return Math.floor(n / 7) + 1;
};

exports.getYearForWeekNo = function(date) {
	var dt = new Date(date.getTime());
	var d = dt.getDay();
	if(d === 0) {
		d = 7; // JavaScript Sun=0, ISO Sun=7
	}
	dt.setTime(dt.getTime() + (4 - d) * 86400000);// shift day to Thurs of same week
	return dt.getFullYear();
};

exports.getHours12 = function(date) {
	var h = date.getHours();
	return h > 12 ? h-12 : ( h > 0 ? h : 12 );
};

/*
Convert a date delta in milliseconds into a string representation of "23 seconds ago", "27 minutes ago" etc.
	delta: delta in milliseconds
Returns an object with these members:
	description: string describing the delta period
	updatePeriod: time in millisecond until the string will be inaccurate
*/
exports.getRelativeDate = function(delta) {
	var futurep = false;
	if(delta < 0) {
		delta = -1 * delta;
		futurep = true;
	}
	var units = [
		{name: "Years",   duration:      365 * 24 * 60 * 60 * 1000},
		{name: "Months",  duration: (365/12) * 24 * 60 * 60 * 1000},
		{name: "Days",    duration:            24 * 60 * 60 * 1000},
		{name: "Hours",   duration:                 60 * 60 * 1000},
		{name: "Minutes", duration:                      60 * 1000},
		{name: "Seconds", duration:                           1000}
	];
	for(var t=0; t<units.length; t++) {
		var result = Math.floor(delta / units[t].duration);
		if(result >= 2) {
			return {
				delta: delta,
				description: $tw.language.getString(
					"RelativeDate/" + (futurep ? "Future" : "Past") + "/" + units[t].name,
					{variables:
						{period: result.toString()}
					}
				),
				updatePeriod: units[t].duration
			};
		}
	}
	return {
		delta: delta,
		description: $tw.language.getString(
			"RelativeDate/" + (futurep ? "Future" : "Past") + "/Second",
			{variables:
				{period: "1"}
			}
		),
		updatePeriod: 1000
	};
};

// Convert & to "&amp;", < to "&lt;", > to "&gt;", " to "&quot;"
exports.htmlEncode = function(s) {
	if(s) {
		return s.toString().replace(/&/mg,"&amp;").replace(/</mg,"&lt;").replace(/>/mg,"&gt;").replace(/\"/mg,"&quot;");
	} else {
		return "";
	}
};

// Converts all HTML entities to their character equivalents
exports.entityDecode = function(s) {
	var converter = String.fromCodePoint || String.fromCharCode,
		e = s.substr(1,s.length-2), // Strip the & and the ;
		c;
	if(e.charAt(0) === "#") {
		if(e.charAt(1) === "x" || e.charAt(1) === "X") {
			c = parseInt(e.substr(2),16);
		} else {
			c = parseInt(e.substr(1),10);
		}
		if(isNaN(c)) {
			return s;
		} else {
			return converter(c);
		}
	} else {
		c = $tw.config.htmlEntities[e];
		if(c) {
			return converter(c);
		} else {
			return s; // Couldn't convert it as an entity, just return it raw
		}
	}
};

exports.unescapeLineBreaks = function(s) {
	return s.replace(/\\n/mg,"\n").replace(/\\b/mg," ").replace(/\\s/mg,"\\").replace(/\r/mg,"");
};

/*
 * Returns an escape sequence for given character. Uses \x for characters <=
 * 0xFF to save space, \u for the rest.
 *
 * The code needs to be in sync with th code template in the compilation
 * function for "action" nodes.
 */
// Copied from peg.js, thanks to David Majda
exports.escape = function(ch) {
	var charCode = ch.charCodeAt(0);
	if(charCode <= 0xFF) {
		return '\\x' + $tw.utils.pad(charCode.toString(16).toUpperCase());
	} else {
		return '\\u' + $tw.utils.pad(charCode.toString(16).toUpperCase(),4);
	}
};

// Turns a string into a legal JavaScript string
// Copied from peg.js, thanks to David Majda
exports.stringify = function(s) {
	/*
	* ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
	* literal except for the closing quote character, backslash, carriage return,
	* line separator, paragraph separator, and line feed. Any character may
	* appear in the form of an escape sequence.
	*
	* For portability, we also escape all non-ASCII characters.
	*/
	return (s || "")
		.replace(/\\/g, '\\\\')            // backslash
		.replace(/"/g, '\\"')              // double quote character
		.replace(/'/g, "\\'")              // single quote character
		.replace(/\r/g, '\\r')             // carriage return
		.replace(/\n/g, '\\n')             // line feed
		.replace(/[\x00-\x1f\x80-\uFFFF]/g, exports.escape); // non-ASCII characters
};

// Turns a string into a legal JSON string
// Derived from peg.js, thanks to David Majda
exports.jsonStringify = function(s) {
	// See http://www.json.org/
	return (s || "")
		.replace(/\\/g, '\\\\')            // backslash
		.replace(/"/g, '\\"')              // double quote character
		.replace(/\r/g, '\\r')             // carriage return
		.replace(/\n/g, '\\n')             // line feed
		.replace(/\x08/g, '\\b')           // backspace
		.replace(/\x0c/g, '\\f')           // formfeed
		.replace(/\t/g, '\\t')             // tab
		.replace(/[\x00-\x1f\x80-\uFFFF]/g,function(s) {
			return '\\u' + $tw.utils.pad(s.charCodeAt(0).toString(16).toUpperCase(),4);
		}); // non-ASCII characters
};

/*
Escape the RegExp special characters with a preceding backslash
*/
exports.escapeRegExp = function(s) {
    return s.replace(/[\-\/\\\^\$\*\+\?\.\(\)\|\[\]\{\}]/g, '\\$&');
};

// Checks whether a link target is external, i.e. not a tiddler title
exports.isLinkExternal = function(to) {
	var externalRegExp = /^(?:file|http|https|mailto|ftp|irc|news|data|skype):[^\s<>{}\[\]`|"\\^]+(?:\/|\b)/i;
	return externalRegExp.test(to);
};

exports.nextTick = function(fn) {
/*global window: false */
	if(typeof process === "undefined") {
		// Apparently it would be faster to use postMessage - http://dbaron.org/log/20100309-faster-timeouts
		window.setTimeout(fn,4);
	} else {
		process.nextTick(fn);
	}
};

/*
Convert a hyphenated CSS property name into a camel case one
*/
exports.unHyphenateCss = function(propName) {
	return propName.replace(/-([a-z])/gi, function(match0,match1) {
		return match1.toUpperCase();
	});
};

/*
Convert a camelcase CSS property name into a dashed one ("backgroundColor" --> "background-color")
*/
exports.hyphenateCss = function(propName) {
	return propName.replace(/([A-Z])/g, function(match0,match1) {
		return "-" + match1.toLowerCase();
	});
};

/*
Parse a text reference of one of these forms:
* title
* !!field
* title!!field
* title##index
* etc
Returns an object with the following fields, all optional:
* title: tiddler title
* field: tiddler field name
* index: JSON property index
*/
exports.parseTextReference = function(textRef) {
	// Separate out the title, field name and/or JSON indices
	var reTextRef = /(?:(.*?)!!(.+))|(?:(.*?)##(.+))|(.*)/mg,
		match = reTextRef.exec(textRef),
		result = {};
	if(match && reTextRef.lastIndex === textRef.length) {
		// Return the parts
		if(match[1]) {
			result.title = match[1];
		}
		if(match[2]) {
			result.field = match[2];
		}
		if(match[3]) {
			result.title = match[3];
		}
		if(match[4]) {
			result.index = match[4];
		}
		if(match[5]) {
			result.title = match[5];
		}
	} else {
		// If we couldn't parse it
		result.title = textRef
	}
	return result;
};

/*
Checks whether a string is a valid fieldname
*/
exports.isValidFieldName = function(name) {
	if(!name || typeof name !== "string") {
		return false;
	}
	name = name.toLowerCase().trim();
	var fieldValidatorRegEx = /^[a-z0-9\-\._]+$/mg;
	return fieldValidatorRegEx.test(name);
};

/*
Extract the version number from the meta tag or from the boot file
*/

// Browser version
exports.extractVersionInfo = function() {
	if($tw.packageInfo) {
		return $tw.packageInfo.version;
	} else {
		var metatags = document.getElementsByTagName("meta");
		for(var t=0; t<metatags.length; t++) {
			var m = metatags[t];
			if(m.name === "tiddlywiki-version") {
				return m.content;
			}
		}
	}
	return null;
};

/*
Get the animation duration in ms
*/
exports.getAnimationDuration = function() {
	return parseInt($tw.wiki.getTiddlerText("$:/config/AnimationDuration","400"),10) || 0;
};

/*
Hash a string to a number
Derived from http://stackoverflow.com/a/15710692
*/
exports.hashString = function(str) {
	return str.split("").reduce(function(a,b) {
		a = ((a << 5) - a) + b.charCodeAt(0);
		return a & a;
	},0);
};

/*
Decode a base64 string
*/
exports.base64Decode = function(string64) {
	return base64utf8.base64.decode.call(base64utf8,string64);
};

/*
Encode a string to base64
*/
exports.base64Encode = function(string64) {
	return base64utf8.base64.encode.call(base64utf8,string64);
};

/*
Convert a hashmap into a tiddler dictionary format sequence of name:value pairs
*/
exports.makeTiddlerDictionary = function(data) {
	var output = [];
	for(var name in data) {
		output.push(name + ": " + data[name]);
	}
	return output.join("\n");
};

/*
High resolution microsecond timer for profiling
*/
exports.timer = function(base) {
	var m;
	if($tw.node) {
		var r = process.hrtime();
		m =  r[0] * 1e3 + (r[1] / 1e6);
	} else if(window.performance) {
		m = performance.now();
	} else {
		m = Date.now();
	}
	if(typeof base !== "undefined") {
		m = m - base;
	}
	return m;
};

/*
Convert text and content type to a data URI
*/
exports.makeDataUri = function(text,type) {
	type = type || "text/vnd.tiddlywiki";
	var typeInfo = $tw.config.contentTypeInfo[type] || $tw.config.contentTypeInfo["text/plain"],
		isBase64 = typeInfo.encoding === "base64",
		parts = [];
	parts.push("data:");
	parts.push(type);
	parts.push(isBase64 ? ";base64" : "");
	parts.push(",");
	parts.push(isBase64 ? text : encodeURIComponent(text));
	return parts.join("");
};

/*
Useful for finding out the fully escaped CSS selector equivalent to a given tag. For example:

$tw.utils.tagToCssSelector("$:/tags/Stylesheet") --> tc-tagged-\%24\%3A\%2Ftags\%2FStylesheet
*/
exports.tagToCssSelector = function(tagName) {
	return "tc-tagged-" + encodeURIComponent(tagName).replace(/[!"#$%&'()*+,\-./:;<=>?@[\\\]^`{\|}~,]/mg,function(c) {
		return "\\" + c;
	});
};

/*
IE does not have sign function
*/
exports.sign = Math.sign || function(x) {
	x = +x; // convert to a number
	if (x === 0 || isNaN(x)) {
		return x;
	}
	return x > 0 ? 1 : -1;
};

/*
IE does not have an endsWith function
*/
exports.strEndsWith = function(str,ending,position) {
	if(str.endsWith) {
		return str.endsWith(ending,position);
	} else {
		if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > str.length) {
			position = str.length;
		}
		position -= ending.length;
		var lastIndex = str.indexOf(ending, position);
		return lastIndex !== -1 && lastIndex === position;
	}
};

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-createtiddler.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-createtiddler.js
type: application/javascript
module-type: widget

Action widget to create a new tiddler with a unique name and specified fields.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var CreateTiddlerWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
CreateTiddlerWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
CreateTiddlerWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
CreateTiddlerWidget.prototype.execute = function() {
	this.actionBaseTitle = this.getAttribute("$basetitle");
	this.actionSaveTitle = this.getAttribute("$savetitle");
	this.actionSaveDraftTitle = this.getAttribute("$savedrafttitle");
	this.actionTimestamp = this.getAttribute("$timestamp","yes") === "yes";
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
CreateTiddlerWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if($tw.utils.count(changedAttributes) > 0) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
CreateTiddlerWidget.prototype.invokeAction = function(triggeringWidget,event) {
	var title = this.wiki.generateNewTitle(this.actionBaseTitle),
		fields = {},
		creationFields,
		modificationFields;
	$tw.utils.each(this.attributes,function(attribute,name) {
		if(name.charAt(0) !== "$") {
			fields[name] = attribute;
		}
	});
	if(this.actionTimestamp) {
		creationFields = this.wiki.getCreationFields();
		modificationFields = this.wiki.getModificationFields();
	}
	var tiddler = this.wiki.addTiddler(new $tw.Tiddler(creationFields,fields,modificationFields,{title: title}));
	if(this.actionSaveTitle) {
		this.wiki.setTextReference(this.actionSaveTitle,title,this.getVariable("currentTiddler"));
	}
	if(this.actionSaveDraftTitle) {
		this.wiki.setTextReference(this.actionSaveDraftTitle,this.wiki.generateDraftTitle(title),this.getVariable("currentTiddler"));
	}
	return true; // Action was invoked
};

exports["action-createtiddler"] = CreateTiddlerWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-deletefield.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-deletefield.js
type: application/javascript
module-type: widget

Action widget to delete fields of a tiddler.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var DeleteFieldWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DeleteFieldWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
DeleteFieldWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
DeleteFieldWidget.prototype.execute = function() {
	this.actionTiddler = this.getAttribute("$tiddler",this.getVariable("currentTiddler"));
	this.actionField = this.getAttribute("$field");
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
DeleteFieldWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["$tiddler"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
DeleteFieldWidget.prototype.invokeAction = function(triggeringWidget,event) {
	var self = this,
		tiddler = this.wiki.getTiddler(self.actionTiddler),
		removeFields = {},
		hasChanged = false;
	if(this.actionField) {
		removeFields[this.actionField] = undefined;
		if(this.actionField in tiddler.fields) {
			hasChanged = true;
		}
	}
	if(tiddler) {
		$tw.utils.each(this.attributes,function(attribute,name) {
			if(name.charAt(0) !== "$" && name !== "title") {
				removeFields[name] = undefined;
				hasChanged = true;
			}
		});
		if(hasChanged) {
			this.wiki.addTiddler(new $tw.Tiddler(this.wiki.getCreationFields(),tiddler,removeFields,this.wiki.getModificationFields()));			
		}
	}
	return true; // Action was invoked
};

exports["action-deletefield"] = DeleteFieldWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-deletetiddler.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-deletetiddler.js
type: application/javascript
module-type: widget

Action widget to delete a tiddler.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var DeleteTiddlerWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DeleteTiddlerWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
DeleteTiddlerWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
DeleteTiddlerWidget.prototype.execute = function() {
	this.actionFilter = this.getAttribute("$filter");
	this.actionTiddler = this.getAttribute("$tiddler");
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
DeleteTiddlerWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["$filter"] || changedAttributes["$tiddler"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
DeleteTiddlerWidget.prototype.invokeAction = function(triggeringWidget,event) {
	var tiddlers = [];
	if(this.actionFilter) {
		tiddlers = this.wiki.filterTiddlers(this.actionFilter,this);
	}
	if(this.actionTiddler) {
		tiddlers.push(this.actionTiddler);
	}
	for(var t=0; t<tiddlers.length; t++) {
		this.wiki.deleteTiddler(tiddlers[t]);
	}
	return true; // Action was invoked
};

exports["action-deletetiddler"] = DeleteTiddlerWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-listops.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-listops.js
type: application/javascript
module-type: widget

Action widget to apply list operations to any tiddler field (defaults to the 'list' field of the current tiddler)

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";
var Widget = require("$:/core/modules/widgets/widget.js").widget;
var ActionListopsWidget = function(parseTreeNode, options) {
	this.initialise(parseTreeNode, options);
};
/**
 * Inherit from the base widget class
 */
ActionListopsWidget.prototype = new Widget();
/**
 * Render this widget into the DOM
 */
ActionListopsWidget.prototype.render = function(parent, nextSibling) {
	this.computeAttributes();
	this.execute();
};
/**
 * Compute the internal state of the widget
 */
ActionListopsWidget.prototype.execute = function() {
	// Get our parameters
	this.target = this.getAttribute("$tiddler", this.getVariable(
		"currentTiddler"));
	this.filter = this.getAttribute("$filter");
	this.subfilter = this.getAttribute("$subfilter");
	this.listField = this.getAttribute("$field", "list");
	this.listIndex = this.getAttribute("$index");
	this.filtertags = this.getAttribute("$tags");
};
/**
 * 	Refresh the widget by ensuring our attributes are up to date
 */
ActionListopsWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.$tiddler || changedAttributes.$filter ||
		changedAttributes.$subfilter || changedAttributes.$field ||
		changedAttributes.$index || changedAttributes.$tags) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};
/**
 * 	Invoke the action associated with this widget
 */
ActionListopsWidget.prototype.invokeAction = function(triggeringWidget,
	event) {
	//Apply the specified filters to the lists
	var field = this.listField,
		index,
		type = "!!",
		list = this.listField;
	if(this.listIndex) {
		field = undefined;
		index = this.listIndex;
		type = "##";
		list = this.listIndex;
	}
	if(this.filter) {
		this.wiki.setText(this.target, field, index, $tw.utils.stringifyList(
			this.wiki
			.filterTiddlers(this.filter, this)));
	}
	if(this.subfilter) {
		var subfilter = "[list[" + this.target + type + list + "]] " + this.subfilter;
		this.wiki.setText(this.target, field, index, $tw.utils.stringifyList(
			this.wiki
			.filterTiddlers(subfilter, this)));
	}
	if(this.filtertags) {
		var tiddler = this.wiki.getTiddler(this.target),
			oldtags = tiddler ? (tiddler.fields.tags || []).slice(0) : [],
			tagfilter = "[list[" + this.target + "!!tags]] " + this.filtertags,
			newtags = this.wiki.filterTiddlers(tagfilter,this);
		if($tw.utils.stringifyList(oldtags.sort()) !== $tw.utils.stringifyList(newtags.sort())) {
			this.wiki.setText(this.target,"tags",undefined,$tw.utils.stringifyList(newtags));			
		}
	}
	return true; // Action was invoked
};

exports["action-listops"] = ActionListopsWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-navigate.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-navigate.js
type: application/javascript
module-type: widget

Action widget to navigate to a tiddler

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var NavigateWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
NavigateWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
NavigateWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
NavigateWidget.prototype.execute = function() {
	this.actionTo = this.getAttribute("$to");
	this.actionScroll = this.getAttribute("$scroll");
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
NavigateWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["$to"] || changedAttributes["$scroll"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
NavigateWidget.prototype.invokeAction = function(triggeringWidget,event) {
	event = event || {};
	var bounds = triggeringWidget && triggeringWidget.getBoundingClientRect && triggeringWidget.getBoundingClientRect(),
		suppressNavigation = event.metaKey || event.ctrlKey || (event.button === 1);
	if(this.actionScroll === "yes") {
		suppressNavigation = false;
	} else if(this.actionScroll === "no") {
		suppressNavigation = true;
	}
	this.dispatchEvent({
		type: "tm-navigate",
		navigateTo: this.actionTo === undefined ? this.getVariable("currentTiddler") : this.actionTo,
		navigateFromTitle: this.getVariable("storyTiddler"),
		navigateFromNode: triggeringWidget,
		navigateFromClientRect: bounds && { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height
		},
		navigateSuppressNavigation: suppressNavigation
	});
	return true; // Action was invoked
};

exports["action-navigate"] = NavigateWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-sendmessage.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-sendmessage.js
type: application/javascript
module-type: widget

Action widget to send a message

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var SendMessageWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
SendMessageWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
SendMessageWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
SendMessageWidget.prototype.execute = function() {
	this.actionMessage = this.getAttribute("$message");
	this.actionParam = this.getAttribute("$param");
	this.actionName = this.getAttribute("$name");
	this.actionValue = this.getAttribute("$value","");
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
SendMessageWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(Object.keys(changedAttributes).length) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
SendMessageWidget.prototype.invokeAction = function(triggeringWidget,event) {
	// Get the string parameter
	var param = this.actionParam;
	// Assemble the attributes as a hashmap
	var paramObject = Object.create(null);
	var count = 0;
	$tw.utils.each(this.attributes,function(attribute,name) {
		if(name.charAt(0) !== "$") {
			paramObject[name] = attribute;
			count++;
		}
	});
	// Add name/value pair if present
	if(this.actionName) {
		paramObject[this.actionName] = this.actionValue;
	}
	// Dispatch the message
	this.dispatchEvent({
		type: this.actionMessage,
		param: param,
		paramObject: paramObject,
		tiddlerTitle: this.getVariable("currentTiddler"),
		navigateFromTitle: this.getVariable("storyTiddler"),
		event: event
	});
	return true; // Action was invoked
};

exports["action-sendmessage"] = SendMessageWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/action-setfield.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/action-setfield.js
type: application/javascript
module-type: widget

Action widget to set a single field or index on a tiddler.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var SetFieldWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
SetFieldWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
SetFieldWidget.prototype.render = function(parent,nextSibling) {
	this.computeAttributes();
	this.execute();
};

/*
Compute the internal state of the widget
*/
SetFieldWidget.prototype.execute = function() {
	this.actionTiddler = this.getAttribute("$tiddler",this.getVariable("currentTiddler"));
	this.actionField = this.getAttribute("$field");
	this.actionIndex = this.getAttribute("$index");
	this.actionValue = this.getAttribute("$value");
	this.actionTimestamp = this.getAttribute("$timestamp","yes") === "yes";
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
SetFieldWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["$tiddler"] || changedAttributes["$field"] || changedAttributes["$index"] || changedAttributes["$value"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

/*
Invoke the action associated with this widget
*/
SetFieldWidget.prototype.invokeAction = function(triggeringWidget,event) {
	var self = this,
		options = {};
	options.suppressTimestamp = !this.actionTimestamp;
	if((typeof this.actionField == "string") || (typeof this.actionIndex == "string")  || (typeof this.actionValue == "string")) {
		this.wiki.setText(this.actionTiddler,this.actionField,this.actionIndex,this.actionValue,options);
	}
	$tw.utils.each(this.attributes,function(attribute,name) {
		if(name.charAt(0) !== "$") {
			self.wiki.setText(self.actionTiddler,name,undefined,attribute,options);
		}
	});
	return true; // Action was invoked
};

exports["action-setfield"] = SetFieldWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/browse.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/browse.js
type: application/javascript
module-type: widget

Browse widget for browsing for files to import

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var BrowseWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
BrowseWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
BrowseWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	// Create element
	var domNode = this.document.createElement("input");
	domNode.setAttribute("type","file");
	if(this.browseMultiple) {
		domNode.setAttribute("multiple","multiple");
	}
	if(this.tooltip) {
		domNode.setAttribute("title",this.tooltip);
	}
	// Nw.js supports "nwsaveas" to force a "save as" dialogue that allows a new or existing file to be selected
	if(this.nwsaveas) {
		domNode.setAttribute("nwsaveas",this.nwsaveas);
	}
	// Nw.js supports "webkitdirectory" and "nwdirectory" to allow a directory to be selected
	if(this.webkitdirectory) {
		domNode.setAttribute("webkitdirectory",this.webkitdirectory);
	}
	if(this.nwdirectory) {
		domNode.setAttribute("nwdirectory",this.nwdirectory);
	}
	// Add a click event handler
	domNode.addEventListener("change",function (event) {
		if(self.message) {
			self.dispatchEvent({type: self.message, param: self.param, files: event.target.files});
		} else {
			self.wiki.readFiles(event.target.files,{
				callback: function(tiddlerFieldsArray) {
					self.dispatchEvent({type: "tm-import-tiddlers", param: JSON.stringify(tiddlerFieldsArray)});
				},
				deserializer: self.deserializer
			});
		}
		return false;
	},false);
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

/*
Compute the internal state of the widget
*/
BrowseWidget.prototype.execute = function() {
	this.browseMultiple = this.getAttribute("multiple");
	this.deserializer = this.getAttribute("deserializer");
	this.message = this.getAttribute("message");
	this.param = this.getAttribute("param");
	this.tooltip = this.getAttribute("tooltip");
	this.nwsaveas = this.getAttribute("nwsaveas");
	this.webkitdirectory = this.getAttribute("webkitdirectory");
	this.nwdirectory = this.getAttribute("nwdirectory");
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
BrowseWidget.prototype.refresh = function(changedTiddlers) {
	return false;
};

exports.browse = BrowseWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/button.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/button.js
type: application/javascript
module-type: widget

Button widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ButtonWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ButtonWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ButtonWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	// Create element
	var tag = "button";
	if(this.buttonTag && $tw.config.htmlUnsafeElements.indexOf(this.buttonTag) === -1) {
		tag = this.buttonTag;
	}
	var domNode = this.document.createElement(tag);
	// Assign classes
	var classes = this["class"].split(" ") || [],
		isPoppedUp = (this.popup || this.popupTitle) && this.isPoppedUp();
	if(this.selectedClass) {
		if((this.set || this.setTitle) && this.setTo && this.isSelected()) {
			$tw.utils.pushTop(classes,this.selectedClass.split(" "));
		}
		if(isPoppedUp) {
			$tw.utils.pushTop(classes,this.selectedClass.split(" "));
		}
	}
	if(isPoppedUp) {
		$tw.utils.pushTop(classes,"tc-popup-handle");
	}
	domNode.className = classes.join(" ");
	// Assign other attributes
	if(this.style) {
		domNode.setAttribute("style",this.style);
	}
	if(this.tooltip) {
		domNode.setAttribute("title",this.tooltip);
	}
	if(this["aria-label"]) {
		domNode.setAttribute("aria-label",this["aria-label"]);
	}
	// Add a click event handler
	domNode.addEventListener("click",function (event) {
		var handled = false;
		if(self.invokeActions(self,event)) {
			handled = true;
		}
		if(self.to) {
			self.navigateTo(event);
			handled = true;
		}
		if(self.message) {
			self.dispatchMessage(event);
			handled = true;
		}
		if(self.popup || self.popupTitle) {
			self.triggerPopup(event);
			handled = true;
		}
		if(self.set || self.setTitle) {
			self.setTiddler();
			handled = true;
		}
		if(self.actions) {
			self.invokeActionString(self.actions,self,event);
		}
		if(handled) {
			event.preventDefault();
			event.stopPropagation();
		}
		return handled;
	},false);
	// Make it draggable if required
	if(this.dragTiddler || this.dragFilter) {
		$tw.utils.makeDraggable({
			domNode: domNode,
			dragTiddlerFn: function() {return self.dragTiddler;},
			dragFilterFn: function() {return self.dragFilter;},
			widget: this
		});
	}
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

/*
We don't allow actions to propagate because we trigger actions ourselves
*/
ButtonWidget.prototype.allowActionPropagation = function() {
	return false;
};

ButtonWidget.prototype.getBoundingClientRect = function() {
	return this.domNodes[0].getBoundingClientRect();
};

ButtonWidget.prototype.isSelected = function() {
    return this.setTitle ? (this.setField ? this.wiki.getTiddler(this.setTitle).getFieldString(this.setField) === this.setTo :
		(this.setIndex ? this.wiki.extractTiddlerDataItem(this.setTitle,this.setIndex) === this.setTo :
			this.wiki.getTiddlerText(this.setTitle))) || this.defaultSetValue || this.getVariable("currentTiddler") :
		this.wiki.getTextReference(this.set,this.defaultSetValue,this.getVariable("currentTiddler")) === this.setTo;
};

ButtonWidget.prototype.isPoppedUp = function() {
	var tiddler = this.popupTitle ? this.wiki.getTiddler(this.popupTitle) : this.wiki.getTiddler(this.popup);
	var result = tiddler && tiddler.fields.text ? $tw.popup.readPopupState(tiddler.fields.text) : false;
	return result;
};

ButtonWidget.prototype.navigateTo = function(event) {
	var bounds = this.getBoundingClientRect();
	this.dispatchEvent({
		type: "tm-navigate",
		navigateTo: this.to,
		navigateFromTitle: this.getVariable("storyTiddler"),
		navigateFromNode: this,
		navigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height
		},
		navigateSuppressNavigation: event.metaKey || event.ctrlKey || (event.button === 1),
		event: event
	});
};

ButtonWidget.prototype.dispatchMessage = function(event) {
	this.dispatchEvent({type: this.message, param: this.param, tiddlerTitle: this.getVariable("currentTiddler"), event: event});
};

ButtonWidget.prototype.triggerPopup = function(event) {
	if(this.popupTitle) {
		$tw.popup.triggerPopup({
			domNode: this.domNodes[0],
			title: this.popupTitle,
			wiki: this.wiki,
			noStateReference: true
		});
	} else {
		$tw.popup.triggerPopup({
			domNode: this.domNodes[0],
			title: this.popup,
			wiki: this.wiki
		});
	}
};

ButtonWidget.prototype.setTiddler = function() {
	if(this.setTitle) {
		this.setField ? this.wiki.setText(this.setTitle,this.setField,undefined,this.setTo) :
				(this.setIndex ? this.wiki.setText(this.setTitle,undefined,this.setIndex,this.setTo) :
				this.wiki.setText(this.setTitle,"text",undefined,this.setTo));
	} else {
		this.wiki.setTextReference(this.set,this.setTo,this.getVariable("currentTiddler"));
	}
};

/*
Compute the internal state of the widget
*/
ButtonWidget.prototype.execute = function() {
	// Get attributes
	this.actions = this.getAttribute("actions");
	this.to = this.getAttribute("to");
	this.message = this.getAttribute("message");
	this.param = this.getAttribute("param");
	this.set = this.getAttribute("set");
	this.setTo = this.getAttribute("setTo");
	this.popup = this.getAttribute("popup");
	this.hover = this.getAttribute("hover");
	this["class"] = this.getAttribute("class","");
	this["aria-label"] = this.getAttribute("aria-label");
	this.tooltip = this.getAttribute("tooltip");
	this.style = this.getAttribute("style");
	this.selectedClass = this.getAttribute("selectedClass");
	this.defaultSetValue = this.getAttribute("default","");
	this.buttonTag = this.getAttribute("tag");
	this.dragTiddler = this.getAttribute("dragTiddler");
	this.dragFilter = this.getAttribute("dragFilter");
	this.setTitle = this.getAttribute("setTitle");
	this.setField = this.getAttribute("setField");
	this.setIndex = this.getAttribute("setIndex");
	this.popupTitle = this.getAttribute("popupTitle");
	// Make child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ButtonWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.to || changedAttributes.message || changedAttributes.param || changedAttributes.set || changedAttributes.setTo || changedAttributes.popup || changedAttributes.hover || changedAttributes["class"] || changedAttributes.selectedClass || changedAttributes.style || changedAttributes.dragFilter || changedAttributes.dragTiddler || (this.set && changedTiddlers[this.set]) || (this.popup && changedTiddlers[this.popup]) || (this.popupTitle && changedTiddlers[this.popupTitle]) || changedAttributes.setTitle || changedAttributes.setField || changedAttributes.setIndex || changedAttributes.popupTitle) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports.button = ButtonWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/checkbox.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/checkbox.js
type: application/javascript
module-type: widget

Checkbox widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var CheckboxWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
CheckboxWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
CheckboxWidget.prototype.render = function(parent,nextSibling) {
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Create our elements
	this.labelDomNode = this.document.createElement("label");
	this.labelDomNode.setAttribute("class",this.checkboxClass);
	this.inputDomNode = this.document.createElement("input");
	this.inputDomNode.setAttribute("type","checkbox");
	if(this.getValue()) {
		this.inputDomNode.setAttribute("checked","true");
	}
	this.labelDomNode.appendChild(this.inputDomNode);
	this.spanDomNode = this.document.createElement("span");
	this.labelDomNode.appendChild(this.spanDomNode);
	// Add a click event handler
	$tw.utils.addEventListeners(this.inputDomNode,[
		{name: "change", handlerObject: this, handlerMethod: "handleChangeEvent"}
	]);
	// Insert the label into the DOM and render any children
	parent.insertBefore(this.labelDomNode,nextSibling);
	this.renderChildren(this.spanDomNode,null);
	this.domNodes.push(this.labelDomNode);
};

CheckboxWidget.prototype.getValue = function() {
	var tiddler = this.wiki.getTiddler(this.checkboxTitle);
	if(tiddler) {
		if(this.checkboxTag) {
			if(this.checkboxInvertTag) {
				return !tiddler.hasTag(this.checkboxTag);
			} else {
				return tiddler.hasTag(this.checkboxTag);
			}
		}
		if(this.checkboxField) {
			var value;
			if($tw.utils.hop(tiddler.fields,this.checkboxField)) {
				value = tiddler.fields[this.checkboxField] || "";
			} else {
				value = this.checkboxDefault || "";
			}
			if(value === this.checkboxChecked) {
				return true;
			}
			if(value === this.checkboxUnchecked) {
				return false;
			}
		}
		if(this.checkboxIndex) {
			var value = this.wiki.extractTiddlerDataItem(tiddler,this.checkboxIndex,this.checkboxDefault || "");
			if(value === this.checkboxChecked) {
				return true;
			}
			if(value === this.checkboxUnchecked) {
				return false;
			}
		}
	} else {
		if(this.checkboxTag) {
			return false;
		}
		if(this.checkboxField) {
			if(this.checkboxDefault === this.checkboxChecked) {
				return true;
			}
			if(this.checkboxDefault === this.checkboxUnchecked) {
				return false;
			}
		}
	}
	return false;
};

CheckboxWidget.prototype.handleChangeEvent = function(event) {
	var checked = this.inputDomNode.checked,
		tiddler = this.wiki.getTiddler(this.checkboxTitle),
		fallbackFields = {text: ""},
		newFields = {title: this.checkboxTitle},
		hasChanged = false,
		tagCheck = false,
		hasTag = tiddler && tiddler.hasTag(this.checkboxTag),
		value = checked ? this.checkboxChecked : this.checkboxUnchecked;
	if(this.checkboxTag && this.checkboxInvertTag === "yes") {
		tagCheck = hasTag === checked;
	} else {
		tagCheck = hasTag !== checked;
	}
	// Set the tag if specified
	if(this.checkboxTag && (!tiddler || tagCheck)) {
		newFields.tags = tiddler ? (tiddler.fields.tags || []).slice(0) : [];
		var pos = newFields.tags.indexOf(this.checkboxTag);
		if(pos !== -1) {
			newFields.tags.splice(pos,1);
		}
		if(this.checkboxInvertTag === "yes" && !checked) {
			newFields.tags.push(this.checkboxTag);
		} else if(this.checkboxInvertTag !== "yes" && checked) {
			newFields.tags.push(this.checkboxTag);
		}
		hasChanged = true;
	}
	// Set the field if specified
	if(this.checkboxField) {
		if(!tiddler || tiddler.fields[this.checkboxField] !== value) {
			newFields[this.checkboxField] = value;
			hasChanged = true;
		}
	}
	// Set the index if specified
	if(this.checkboxIndex) {
		var indexValue = this.wiki.extractTiddlerDataItem(this.checkboxTitle,this.checkboxIndex);
		if(!tiddler || indexValue !== value) {
			hasChanged = true;
		}
	}
	if(hasChanged) {
		if(this.checkboxIndex) {
			this.wiki.setText(this.checkboxTitle,"",this.checkboxIndex,value);
		} else {
			this.wiki.addTiddler(new $tw.Tiddler(this.wiki.getCreationFields(),fallbackFields,tiddler,newFields,this.wiki.getModificationFields()));
		}
	}
	// Trigger actions
	if(this.checkboxActions) {
		this.invokeActionString(this.checkboxActions,this,event);
	}
	if(this.checkboxCheckActions && checked) {
		this.invokeActionString(this.checkboxCheckActions,this,event);
	}
	if(this.checkboxUncheckActions && !checked) {
		this.invokeActionString(this.checkboxUncheckActions,this,event);
	}
};

/*
Compute the internal state of the widget
*/
CheckboxWidget.prototype.execute = function() {
	// Get the parameters from the attributes
	this.checkboxActions = this.getAttribute("actions");
	this.checkboxCheckActions = this.getAttribute("checkactions");
	this.checkboxUncheckActions = this.getAttribute("uncheckactions");
	this.checkboxTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.checkboxTag = this.getAttribute("tag");
	this.checkboxField = this.getAttribute("field");
	this.checkboxIndex = this.getAttribute("index");
	this.checkboxChecked = this.getAttribute("checked");
	this.checkboxUnchecked = this.getAttribute("unchecked");
	this.checkboxDefault = this.getAttribute("default");
	this.checkboxClass = this.getAttribute("class","");
	this.checkboxInvertTag = this.getAttribute("invertTag","");
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
CheckboxWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.tag || changedAttributes.invertTag || changedAttributes.field || changedAttributes.index || changedAttributes.checked || changedAttributes.unchecked || changedAttributes["default"] || changedAttributes["class"]) {
		this.refreshSelf();
		return true;
	} else {
		var refreshed = false;
		if(changedTiddlers[this.checkboxTitle]) {
			this.inputDomNode.checked = this.getValue();
			refreshed = true;
		}
		return this.refreshChildren(changedTiddlers) || refreshed;
	}
};

exports.checkbox = CheckboxWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/codeblock.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/codeblock.js
type: application/javascript
module-type: widget

Code block node widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var CodeBlockWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
CodeBlockWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
CodeBlockWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var codeNode = this.document.createElement("code"),
		domNode = this.document.createElement("pre");
	codeNode.appendChild(this.document.createTextNode(this.getAttribute("code")));
	domNode.appendChild(codeNode);
	parent.insertBefore(domNode,nextSibling);
	this.domNodes.push(domNode);
	if(this.postRender) {
		this.postRender();
	}
};

/*
Compute the internal state of the widget
*/
CodeBlockWidget.prototype.execute = function() {
	this.language = this.getAttribute("language");
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
CodeBlockWidget.prototype.refresh = function(changedTiddlers) {
	return false;
};

exports.codeblock = CodeBlockWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/count.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/count.js
type: application/javascript
module-type: widget

Count widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var CountWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
CountWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
CountWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var textNode = this.document.createTextNode(this.currentCount);
	parent.insertBefore(textNode,nextSibling);
	this.domNodes.push(textNode);
};

/*
Compute the internal state of the widget
*/
CountWidget.prototype.execute = function() {
	// Get parameters from our attributes
	this.filter = this.getAttribute("filter");
	// Execute the filter
	if(this.filter) {
		this.currentCount = this.wiki.filterTiddlers(this.filter,this).length;
	} else {
		this.currentCount = undefined;
	}
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
CountWidget.prototype.refresh = function(changedTiddlers) {
	// Re-execute the filter to get the count
	this.computeAttributes();
	var oldCount = this.currentCount;
	this.execute();
	if(this.currentCount !== oldCount) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.refreshSelf();
		return true;
	} else {
		return false;
	}

};

exports.count = CountWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/diff-text.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/diff-text.js
type: application/javascript
module-type: widget

Widget to display a diff between two texts

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget,
	dmp = require("$:/core/modules/utils/diff-match-patch/diff_match_patch.js");

var DiffTextWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DiffTextWidget.prototype = new Widget();

DiffTextWidget.prototype.invisibleCharacters = {
	"\n": "↩︎\n",
	"\r": "⇠",
	"\t": "⇥\t"
};

/*
Render this widget into the DOM
*/
DiffTextWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	// Create the diff
	var dmpObject = new dmp.diff_match_patch(),
		diffs = dmpObject.diff_main(this.getAttribute("source"),this.getAttribute("dest"));
	// Apply required cleanup
	switch(this.getAttribute("cleanup","semantic")) {
		case "none":
			// No cleanup
			break;
		case "efficiency":
			dmpObject.diff_cleanupEfficiency(diffs);
			break;
		default: // case "semantic"
			dmpObject.diff_cleanupSemantic(diffs);
			break;
	}
	// Create the elements
	var domContainer = this.document.createElement("div"), 
		domDiff = this.createDiffDom(diffs);
	parent.insertBefore(domContainer,nextSibling);
	// Set variables
	this.setVariable("diff-count",diffs.reduce(function(acc,diff) {
		if(diff[0] !== dmp.DIFF_EQUAL) {
			acc++;
		}
		return acc;
	},0).toString());
	// Render child widgets
	this.renderChildren(domContainer,null);
	// Render the diff
	domContainer.appendChild(domDiff);
	// Save our container
	this.domNodes.push(domContainer);
};

/*
Create DOM elements representing a list of diffs
*/
DiffTextWidget.prototype.createDiffDom = function(diffs) {
	var self = this;
	// Create the element and assign the attributes
	var domPre = this.document.createElement("pre"),
		domCode = this.document.createElement("code");
	$tw.utils.each(diffs,function(diff) {
		var tag = diff[0] === dmp.DIFF_INSERT ? "ins" : (diff[0] === dmp.DIFF_DELETE ? "del" : "span"),
			className = diff[0] === dmp.DIFF_INSERT ? "tc-diff-insert" : (diff[0] === dmp.DIFF_DELETE ? "tc-diff-delete" : "tc-diff-equal"),
			dom = self.document.createElement(tag),
			text = diff[1],
			currPos = 0,
			re = /([\x00-\x1F])/mg,
			match = re.exec(text),
			span,
			printable;
		dom.className = className;
		while(match) {
			if(currPos < match.index) {
				dom.appendChild(self.document.createTextNode(text.slice(currPos,match.index)));
			}
			span = self.document.createElement("span");
			span.className = "tc-diff-invisible";
			printable = self.invisibleCharacters[match[0]] || ("[0x" + match[0].charCodeAt(0).toString(16) + "]");
			span.appendChild(self.document.createTextNode(printable));
			dom.appendChild(span);
			currPos = match.index + match[0].length;
			match = re.exec(text);
		}
		if(currPos < text.length) {
			dom.appendChild(self.document.createTextNode(text.slice(currPos)));
		}
		domCode.appendChild(dom);
	});
	domPre.appendChild(domCode);
	return domPre;
};

/*
Compute the internal state of the widget
*/
DiffTextWidget.prototype.execute = function() {
	// Make child widgets
	var parseTreeNodes;
	if(this.parseTreeNode && this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {
		parseTreeNodes = this.parseTreeNode.children;
	} else {
		parseTreeNodes = [{
			type: "transclude",
			attributes: {
				tiddler: {type: "string", value: "$:/language/Diffs/CountMessage"}
			}
		}];
	}
	this.makeChildWidgets(parseTreeNodes);
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
DiffTextWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.source || changedAttributes.dest || changedAttributes.cleanup) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports["diff-text"] = DiffTextWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/draggable.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/draggable.js
type: application/javascript
module-type: widget

Draggable widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var DraggableWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DraggableWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
DraggableWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Sanitise the specified tag
	var tag = this.draggableTag;
	if($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {
		tag = "div";
	}
	// Create our element
	var domNode = this.document.createElement(tag);
	// Assign classes
	var classes = ["tc-draggable"];
	if(this.draggableClasses) {
		classes.push(this.draggableClasses);
	}
	domNode.setAttribute("class",classes.join(" "));
	// Add event handlers
	$tw.utils.makeDraggable({
		domNode: domNode,
		dragTiddlerFn: function() {return self.getAttribute("tiddler");},
		dragFilterFn: function() {return self.getAttribute("filter");},
		startActions: self.startActions,
		endActions: self.endActions,
		widget: this
	});
	// Insert the link into the DOM and render any children
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

/*
Compute the internal state of the widget
*/
DraggableWidget.prototype.execute = function() {
	// Pick up our attributes
	this.draggableTag = this.getAttribute("tag","div");
	this.draggableClasses = this.getAttribute("class");
	this.startActions = this.getAttribute("startactions");
	this.endActions = this.getAttribute("endactions");
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
DraggableWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedTiddlers.tag || changedTiddlers["class"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports.draggable = DraggableWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/droppable.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/droppable.js
type: application/javascript
module-type: widget

Droppable widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var DroppableWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DroppableWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
DroppableWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	var tag = this.parseTreeNode.isBlock ? "div" : "span";
	if(this.droppableTag && $tw.config.htmlUnsafeElements.indexOf(this.droppableTag) === -1) {
		tag = this.droppableTag;
	}
	// Create element and assign classes
	var domNode = this.document.createElement(tag),
		classes = (this["class"] || "").split(" ");
	classes.push("tc-droppable");
	domNode.className = classes.join(" ");
	// Add event handlers
	$tw.utils.addEventListeners(domNode,[
		{name: "dragenter", handlerObject: this, handlerMethod: "handleDragEnterEvent"},
		{name: "dragover", handlerObject: this, handlerMethod: "handleDragOverEvent"},
		{name: "dragleave", handlerObject: this, handlerMethod: "handleDragLeaveEvent"},
		{name: "drop", handlerObject: this, handlerMethod: "handleDropEvent"}
	]);
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
	// Stack of outstanding enter/leave events
	this.currentlyEntered = [];
};

DroppableWidget.prototype.enterDrag = function(event) {
	if(this.currentlyEntered.indexOf(event.target) === -1) {
		this.currentlyEntered.push(event.target);
	}
	// If we're entering for the first time we need to apply highlighting
	$tw.utils.addClass(this.domNodes[0],"tc-dragover");
};

DroppableWidget.prototype.leaveDrag = function(event) {
	var pos = this.currentlyEntered.indexOf(event.target);
	if(pos !== -1) {
		this.currentlyEntered.splice(pos,1);
	}
	// Remove highlighting if we're leaving externally. The hacky second condition is to resolve a problem with Firefox whereby there is an erroneous dragenter event if the node being dragged is within the dropzone
	if(this.currentlyEntered.length === 0 || (this.currentlyEntered.length === 1 && this.currentlyEntered[0] === $tw.dragInProgress)) {
		this.currentlyEntered = [];
		$tw.utils.removeClass(this.domNodes[0],"tc-dragover");
	}
};

DroppableWidget.prototype.handleDragEnterEvent  = function(event) {
	this.enterDrag(event);
	// Tell the browser that we're ready to handle the drop
	event.preventDefault();
	// Tell the browser not to ripple the drag up to any parent drop handlers
	event.stopPropagation();
	return false;
};

DroppableWidget.prototype.handleDragOverEvent  = function(event) {
	// Check for being over a TEXTAREA or INPUT
	if(["TEXTAREA","INPUT"].indexOf(event.target.tagName) !== -1) {
		return false;
	}
	// Tell the browser that we're still interested in the drop
	event.preventDefault();
	// Set the drop effect
	event.dataTransfer.dropEffect = this.droppableEffect;
	return false;
};

DroppableWidget.prototype.handleDragLeaveEvent  = function(event) {
	this.leaveDrag(event);
	return false;
};

DroppableWidget.prototype.handleDropEvent  = function(event) {
	var self = this;
	this.leaveDrag(event);
	// Check for being over a TEXTAREA or INPUT
	if(["TEXTAREA","INPUT"].indexOf(event.target.tagName) !== -1) {
		return false;
	}
	var dataTransfer = event.dataTransfer;
	// Remove highlighting
	$tw.utils.removeClass(this.domNodes[0],"tc-dragover");
	// Try to import the various data types we understand
	$tw.utils.importDataTransfer(dataTransfer,null,function(fieldsArray) {
		fieldsArray.forEach(function(fields) {
			self.performActions(fields.title || fields.text,event);
		});
	});
	// Tell the browser that we handled the drop
	event.preventDefault();
	// Stop the drop ripple up to any parent handlers
	event.stopPropagation();
	return false;
};

DroppableWidget.prototype.performActions = function(title,event) {
	if(this.droppableActions) {
		var modifierKey = event.ctrlKey && ! event.shiftKey ? "ctrl" : event.shiftKey && !event.ctrlKey ? "shift" : 
				event.ctrlKey && event.shiftKey ? "ctrl-shift" : "normal" ;
		this.invokeActionString(this.droppableActions,this,event,{actionTiddler: title, modifier: modifierKey});
	}
};

/*
Compute the internal state of the widget
*/
DroppableWidget.prototype.execute = function() {
	this.droppableActions = this.getAttribute("actions");
	this.droppableEffect = this.getAttribute("effect","copy");
	this.droppableTag = this.getAttribute("tag");
	this.droppableClass = this.getAttribute("class");
	// Make child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
DroppableWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["class"] || changedAttributes.tag) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports.droppable = DroppableWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/dropzone.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/dropzone.js
type: application/javascript
module-type: widget

Dropzone widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var DropZoneWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
DropZoneWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
DropZoneWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	// Create element
	var domNode = this.document.createElement("div");
	domNode.className = "tc-dropzone";
	// Add event handlers
	$tw.utils.addEventListeners(domNode,[
		{name: "dragenter", handlerObject: this, handlerMethod: "handleDragEnterEvent"},
		{name: "dragover", handlerObject: this, handlerMethod: "handleDragOverEvent"},
		{name: "dragleave", handlerObject: this, handlerMethod: "handleDragLeaveEvent"},
		{name: "drop", handlerObject: this, handlerMethod: "handleDropEvent"},
		{name: "paste", handlerObject: this, handlerMethod: "handlePasteEvent"},
		{name: "dragend", handlerObject: this, handlerMethod: "handleDragEndEvent"}
	]);
	domNode.addEventListener("click",function (event) {
	},false);
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
	// Stack of outstanding enter/leave events
	this.currentlyEntered = [];
};

DropZoneWidget.prototype.enterDrag = function(event) {
	if(this.currentlyEntered.indexOf(event.target) === -1) {
		this.currentlyEntered.push(event.target);
	}
	// If we're entering for the first time we need to apply highlighting
	$tw.utils.addClass(this.domNodes[0],"tc-dragover");
};

DropZoneWidget.prototype.leaveDrag = function(event) {
	var pos = this.currentlyEntered.indexOf(event.target);
	if(pos !== -1) {
		this.currentlyEntered.splice(pos,1);
	}
	// Remove highlighting if we're leaving externally
	if(this.currentlyEntered.length === 0) {
		$tw.utils.removeClass(this.domNodes[0],"tc-dragover");
	}
};

DropZoneWidget.prototype.handleDragEnterEvent  = function(event) {
	// Check for this window being the source of the drag
	if($tw.dragInProgress) {
		return false;
	}
	this.enterDrag(event);
	// Tell the browser that we're ready to handle the drop
	event.preventDefault();
	// Tell the browser not to ripple the drag up to any parent drop handlers
	event.stopPropagation();
};

DropZoneWidget.prototype.handleDragOverEvent  = function(event) {
	// Check for being over a TEXTAREA or INPUT
	if(["TEXTAREA","INPUT"].indexOf(event.target.tagName) !== -1) {
		return false;
	}
	// Check for this window being the source of the drag
	if($tw.dragInProgress) {
		return false;
	}
	// Tell the browser that we're still interested in the drop
	event.preventDefault();
	event.dataTransfer.dropEffect = "copy"; // Explicitly show this is a copy
};

DropZoneWidget.prototype.handleDragLeaveEvent  = function(event) {
	this.leaveDrag(event);
};

DropZoneWidget.prototype.handleDragEndEvent = function(event) {
	$tw.utils.removeClass(this.domNodes[0],"tc-dragover");
};

DropZoneWidget.prototype.handleDropEvent  = function(event) {
	var self = this,
		readFileCallback = function(tiddlerFieldsArray) {
			self.dispatchEvent({type: "tm-import-tiddlers", param: JSON.stringify(tiddlerFieldsArray)});
		};
	this.leaveDrag(event);
	// Check for being over a TEXTAREA or INPUT
	if(["TEXTAREA","INPUT"].indexOf(event.target.tagName) !== -1) {
		return false;
	}
	// Check for this window being the source of the drag
	if($tw.dragInProgress) {
		return false;
	}
	var self = this,
		dataTransfer = event.dataTransfer;
	// Remove highlighting
	$tw.utils.removeClass(this.domNodes[0],"tc-dragover");
	// Import any files in the drop
	var numFiles = 0;
	if(dataTransfer.files) {
		numFiles = this.wiki.readFiles(dataTransfer.files,{
			callback: readFileCallback,
			deserializer: this.dropzoneDeserializer
		});
	}
	// Try to import the various data types we understand
	if(numFiles === 0) {
		$tw.utils.importDataTransfer(dataTransfer,this.wiki.generateNewTitle("Untitled"),readFileCallback);
	}
	// Tell the browser that we handled the drop
	event.preventDefault();
	// Stop the drop ripple up to any parent handlers
	event.stopPropagation();
};

DropZoneWidget.prototype.handlePasteEvent  = function(event) {
	var self = this,
		readFileCallback = function(tiddlerFieldsArray) {
			self.dispatchEvent({type: "tm-import-tiddlers", param: JSON.stringify(tiddlerFieldsArray)});
		};
	// Let the browser handle it if we're in a textarea or input box
	if(["TEXTAREA","INPUT"].indexOf(event.target.tagName) == -1 && !event.target.isContentEditable) {
		var self = this,
			items = event.clipboardData.items;
		// Enumerate the clipboard items
		for(var t = 0; t<items.length; t++) {
			var item = items[t];
			if(item.kind === "file") {
				// Import any files
				this.wiki.readFile(item.getAsFile(),{
					callback: readFileCallback,
					deserializer: this.dropzoneDeserializer
				});
			} else if(item.kind === "string") {
				// Create tiddlers from string items
				var type = item.type;
				item.getAsString(function(str) {
					var tiddlerFields = {
						title: self.wiki.generateNewTitle("Untitled"),
						text: str,
						type: type
					};
					if($tw.log.IMPORT) {
						console.log("Importing string '" + str + "', type: '" + type + "'");
					}
					self.dispatchEvent({type: "tm-import-tiddlers", param: JSON.stringify([tiddlerFields])});
				});
			}
		}
		// Tell the browser that we've handled the paste
		event.stopPropagation();
		event.preventDefault();
	}
};

/*
Compute the internal state of the widget
*/
DropZoneWidget.prototype.execute = function() {
	this.dropzoneDeserializer = this.getAttribute("deserializer");
	// Make child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
DropZoneWidget.prototype.refresh = function(changedTiddlers) {
	return this.refreshChildren(changedTiddlers);
};

exports.dropzone = DropZoneWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/edit-binary.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/edit-binary.js
type: application/javascript
module-type: widget

Edit-binary widget; placeholder for editing binary tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var BINARY_WARNING_MESSAGE = "$:/core/ui/BinaryWarning";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EditBinaryWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EditBinaryWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EditBinaryWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
EditBinaryWidget.prototype.execute = function() {
	// Construct the child widgets
	this.makeChildWidgets([{
		type: "transclude",
		attributes: {
			tiddler: {type: "string", value: BINARY_WARNING_MESSAGE}
		}
	}]);
};

/*
Refresh by refreshing our child widget
*/
EditBinaryWidget.prototype.refresh = function(changedTiddlers) {
	return this.refreshChildren(changedTiddlers);
};

exports["edit-binary"] = EditBinaryWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/edit-bitmap.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/edit-bitmap.js
type: application/javascript
module-type: widget

Edit-bitmap widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Default image sizes
var DEFAULT_IMAGE_WIDTH = 600,
	DEFAULT_IMAGE_HEIGHT = 370;

// Configuration tiddlers
var LINE_WIDTH_TITLE = "$:/config/BitmapEditor/LineWidth",
	LINE_COLOUR_TITLE = "$:/config/BitmapEditor/Colour",
	LINE_OPACITY_TITLE = "$:/config/BitmapEditor/Opacity";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EditBitmapWidget = function(parseTreeNode,options) {
	// Initialise the editor operations if they've not been done already
	if(!this.editorOperations) {
		EditBitmapWidget.prototype.editorOperations = {};
		$tw.modules.applyMethods("bitmapeditoroperation",this.editorOperations);
	}
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EditBitmapWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EditBitmapWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Create the wrapper for the toolbar and render its content
	this.toolbarNode = this.document.createElement("div");
	this.toolbarNode.className = "tc-editor-toolbar";
	parent.insertBefore(this.toolbarNode,nextSibling);
	this.domNodes.push(this.toolbarNode);
	// Create the on-screen canvas
	this.canvasDomNode = $tw.utils.domMaker("canvas",{
		document: this.document,
		"class":"tc-edit-bitmapeditor",
		eventListeners: [{
			name: "touchstart", handlerObject: this, handlerMethod: "handleTouchStartEvent"
		},{
			name: "touchmove", handlerObject: this, handlerMethod: "handleTouchMoveEvent"
		},{
			name: "touchend", handlerObject: this, handlerMethod: "handleTouchEndEvent"
		},{
			name: "mousedown", handlerObject: this, handlerMethod: "handleMouseDownEvent"
		},{
			name: "mousemove", handlerObject: this, handlerMethod: "handleMouseMoveEvent"
		},{
			name: "mouseup", handlerObject: this, handlerMethod: "handleMouseUpEvent"
		}]
	});
	// Set the width and height variables
	this.setVariable("tv-bitmap-editor-width",this.canvasDomNode.width + "px");
	this.setVariable("tv-bitmap-editor-height",this.canvasDomNode.height + "px");
	// Render toolbar child widgets
	this.renderChildren(this.toolbarNode,null);
	// // Insert the elements into the DOM
	parent.insertBefore(this.canvasDomNode,nextSibling);
	this.domNodes.push(this.canvasDomNode);
	// Load the image into the canvas
	if($tw.browser) {
		this.loadCanvas();
	}
	// Add widget message listeners
	this.addEventListeners([
		{type: "tm-edit-bitmap-operation", handler: "handleEditBitmapOperationMessage"}
	]);
};

/*
Handle an edit bitmap operation message from the toolbar
*/
EditBitmapWidget.prototype.handleEditBitmapOperationMessage = function(event) {
	// Invoke the handler
	var handler = this.editorOperations[event.param];
	if(handler) {
		handler.call(this,event);
	}
};

/*
Compute the internal state of the widget
*/
EditBitmapWidget.prototype.execute = function() {
	// Get our parameters
	this.editTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Just refresh the toolbar
*/
EditBitmapWidget.prototype.refresh = function(changedTiddlers) {
	return this.refreshChildren(changedTiddlers);
};

/*
Set the bitmap size variables and refresh the toolbar
*/
EditBitmapWidget.prototype.refreshToolbar = function() {
	// Set the width and height variables
	this.setVariable("tv-bitmap-editor-width",this.canvasDomNode.width + "px");
	this.setVariable("tv-bitmap-editor-height",this.canvasDomNode.height + "px");
	// Refresh each of our child widgets
	$tw.utils.each(this.children,function(childWidget) {
		childWidget.refreshSelf();
	});
};

EditBitmapWidget.prototype.loadCanvas = function() {
	var tiddler = this.wiki.getTiddler(this.editTitle),
		currImage = new Image();
	// Set up event handlers for loading the image
	var self = this;
	currImage.onload = function() {
		// Copy the image to the on-screen canvas
		self.initCanvas(self.canvasDomNode,currImage.width,currImage.height,currImage);
		// And also copy the current bitmap to the off-screen canvas
		self.currCanvas = self.document.createElement("canvas");
		self.initCanvas(self.currCanvas,currImage.width,currImage.height,currImage);
		// Set the width and height input boxes
		self.refreshToolbar();
	};
	currImage.onerror = function() {
		// Set the on-screen canvas size and clear it
		self.initCanvas(self.canvasDomNode,DEFAULT_IMAGE_WIDTH,DEFAULT_IMAGE_HEIGHT);
		// Set the off-screen canvas size and clear it
		self.currCanvas = self.document.createElement("canvas");
		self.initCanvas(self.currCanvas,DEFAULT_IMAGE_WIDTH,DEFAULT_IMAGE_HEIGHT);
		// Set the width and height input boxes
		self.refreshToolbar();
	};
	// Get the current bitmap into an image object
	currImage.src = "data:" + tiddler.fields.type + ";base64," + tiddler.fields.text;
};

EditBitmapWidget.prototype.initCanvas = function(canvas,width,height,image) {
	canvas.width = width;
	canvas.height = height;
	var ctx = canvas.getContext("2d");
	if(image) {
		ctx.drawImage(image,0,0);
	} else {
		ctx.fillStyle = "#fff";
		ctx.fillRect(0,0,canvas.width,canvas.height);
	}
};

/*
** Change the size of the canvas, preserving the current image
*/
EditBitmapWidget.prototype.changeCanvasSize = function(newWidth,newHeight) {
	// Create and size a new canvas
	var newCanvas = this.document.createElement("canvas");
	this.initCanvas(newCanvas,newWidth,newHeight);
	// Copy the old image
	var ctx = newCanvas.getContext("2d");
	ctx.drawImage(this.currCanvas,0,0);
	// Set the new canvas as the current one
	this.currCanvas = newCanvas;
	// Set the size of the onscreen canvas
	this.canvasDomNode.width = newWidth;
	this.canvasDomNode.height = newHeight;
	// Paint the onscreen canvas with the offscreen canvas
	ctx = this.canvasDomNode.getContext("2d");
	ctx.drawImage(this.currCanvas,0,0);
};

/*
** Rotate the canvas left by 90 degrees
*/
EditBitmapWidget.prototype.rotateCanvasLeft = function() {
	// Get the current size of the image
	var origWidth = this.currCanvas.width,
		origHeight = this.currCanvas.height;
	// Create and size a new canvas
	var newCanvas = this.document.createElement("canvas"),
		newWidth = origHeight,
		newHeight = origWidth;
	this.initCanvas(newCanvas,newWidth,newHeight);
	// Copy the old image
	var ctx = newCanvas.getContext("2d");
	ctx.save();
	ctx.translate(newWidth / 2,newHeight / 2);
	ctx.rotate(-Math.PI / 2);
	ctx.drawImage(this.currCanvas,-origWidth / 2,-origHeight / 2);
	ctx.restore();
	// Set the new canvas as the current one
	this.currCanvas = newCanvas;
	// Set the size of the onscreen canvas
	this.canvasDomNode.width = newWidth;
	this.canvasDomNode.height = newHeight;
	// Paint the onscreen canvas with the offscreen canvas
	ctx = this.canvasDomNode.getContext("2d");
	ctx.drawImage(this.currCanvas,0,0);
};

EditBitmapWidget.prototype.handleTouchStartEvent = function(event) {
	this.brushDown = true;
	this.strokeStart(event.touches[0].clientX,event.touches[0].clientY);
	event.preventDefault();
	event.stopPropagation();
	return false;
};

EditBitmapWidget.prototype.handleTouchMoveEvent = function(event) {
	if(this.brushDown) {
		this.strokeMove(event.touches[0].clientX,event.touches[0].clientY);
	}
	event.preventDefault();
	event.stopPropagation();
	return false;
};

EditBitmapWidget.prototype.handleTouchEndEvent = function(event) {
	if(this.brushDown) {
		this.brushDown = false;
		this.strokeEnd();
	}
	event.preventDefault();
	event.stopPropagation();
	return false;
};

EditBitmapWidget.prototype.handleMouseDownEvent = function(event) {
	this.strokeStart(event.clientX,event.clientY);
	this.brushDown = true;
	event.preventDefault();
	event.stopPropagation();
	return false;
};

EditBitmapWidget.prototype.handleMouseMoveEvent = function(event) {
	if(this.brushDown) {
		this.strokeMove(event.clientX,event.clientY);
		event.preventDefault();
		event.stopPropagation();
		return false;
	}
	return true;
};

EditBitmapWidget.prototype.handleMouseUpEvent = function(event) {
	if(this.brushDown) {
		this.brushDown = false;
		this.strokeEnd();
		event.preventDefault();
		event.stopPropagation();
		return false;
	}
	return true;
};

EditBitmapWidget.prototype.adjustCoordinates = function(x,y) {
	var canvasRect = this.canvasDomNode.getBoundingClientRect(),
		scale = this.canvasDomNode.width/canvasRect.width;
	return {x: (x - canvasRect.left) * scale, y: (y - canvasRect.top) * scale};
};

EditBitmapWidget.prototype.strokeStart = function(x,y) {
	// Start off a new stroke
	this.stroke = [this.adjustCoordinates(x,y)];
};

EditBitmapWidget.prototype.strokeMove = function(x,y) {
	var ctx = this.canvasDomNode.getContext("2d"),
		t;
	// Add the new position to the end of the stroke
	this.stroke.push(this.adjustCoordinates(x,y));
	// Redraw the previous image
	ctx.drawImage(this.currCanvas,0,0);
	// Render the stroke
	ctx.globalAlpha = parseFloat(this.wiki.getTiddlerText(LINE_OPACITY_TITLE,"1.0"));
	ctx.strokeStyle = this.wiki.getTiddlerText(LINE_COLOUR_TITLE,"#ff0");
	ctx.lineWidth = parseFloat(this.wiki.getTiddlerText(LINE_WIDTH_TITLE,"3"));
	ctx.lineCap = "round";
	ctx.lineJoin = "round";
	ctx.beginPath();
	ctx.moveTo(this.stroke[0].x,this.stroke[0].y);
	for(t=1; t<this.stroke.length-1; t++) {
		var s1 = this.stroke[t],
			s2 = this.stroke[t-1],
			tx = (s1.x + s2.x)/2,
			ty = (s1.y + s2.y)/2;
		ctx.quadraticCurveTo(s2.x,s2.y,tx,ty);
	}
	ctx.stroke();
};

EditBitmapWidget.prototype.strokeEnd = function() {
	// Copy the bitmap to the off-screen canvas
	var ctx = this.currCanvas.getContext("2d");
	ctx.drawImage(this.canvasDomNode,0,0);
	// Save the image into the tiddler
	this.saveChanges();
};

EditBitmapWidget.prototype.saveChanges = function() {
	var tiddler = this.wiki.getTiddler(this.editTitle);
	if(tiddler) {
		// data URIs look like "data:<type>;base64,<text>"
		var dataURL = this.canvasDomNode.toDataURL(tiddler.fields.type),
			posColon = dataURL.indexOf(":"),
			posSemiColon = dataURL.indexOf(";"),
			posComma = dataURL.indexOf(","),
			type = dataURL.substring(posColon+1,posSemiColon),
			text = dataURL.substring(posComma+1);
		var update = {type: type, text: text};
		this.wiki.addTiddler(new $tw.Tiddler(this.wiki.getModificationFields(),tiddler,update,this.wiki.getCreationFields()));
	}
};

exports["edit-bitmap"] = EditBitmapWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/edit-shortcut.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/edit-shortcut.js
type: application/javascript
module-type: widget

Widget to display an editable keyboard shortcut

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EditShortcutWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EditShortcutWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EditShortcutWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.inputNode = this.document.createElement("input");
	// Assign classes
	if(this.shortcutClass) {
		this.inputNode.className = this.shortcutClass;		
	}
	// Assign other attributes
	if(this.shortcutStyle) {
		this.inputNode.setAttribute("style",this.shortcutStyle);
	}
	if(this.shortcutTooltip) {
		this.inputNode.setAttribute("title",this.shortcutTooltip);
	}
	if(this.shortcutPlaceholder) {
		this.inputNode.setAttribute("placeholder",this.shortcutPlaceholder);
	}
	if(this.shortcutAriaLabel) {
		this.inputNode.setAttribute("aria-label",this.shortcutAriaLabel);
	}
	// Assign the current shortcut
	this.updateInputNode();
	// Add event handlers
	$tw.utils.addEventListeners(this.inputNode,[
		{name: "keydown", handlerObject: this, handlerMethod: "handleKeydownEvent"}
	]);
	// Link into the DOM
	parent.insertBefore(this.inputNode,nextSibling);
	this.domNodes.push(this.inputNode);
	// Focus the input Node if focus === "yes" or focus === "true"
	if(this.shortcutFocus === "yes" || this.shortcutFocus === "true") {
		this.focus();
	}
};

/*
Compute the internal state of the widget
*/
EditShortcutWidget.prototype.execute = function() {
	this.shortcutTiddler = this.getAttribute("tiddler");
	this.shortcutField = this.getAttribute("field");
	this.shortcutIndex = this.getAttribute("index");
	this.shortcutPlaceholder = this.getAttribute("placeholder");
	this.shortcutDefault = this.getAttribute("default","");
	this.shortcutClass = this.getAttribute("class");
	this.shortcutStyle = this.getAttribute("style");
	this.shortcutTooltip = this.getAttribute("tooltip");
	this.shortcutAriaLabel = this.getAttribute("aria-label");
	this.shortcutFocus = this.getAttribute("focus");
};

/*
Update the value of the input node
*/
EditShortcutWidget.prototype.updateInputNode = function() {
	if(this.shortcutField) {
		var tiddler = this.wiki.getTiddler(this.shortcutTiddler);
		if(tiddler && $tw.utils.hop(tiddler.fields,this.shortcutField)) {
			this.inputNode.value = tiddler.getFieldString(this.shortcutField);
		} else {
			this.inputNode.value = this.shortcutDefault;
		}
	} else if(this.shortcutIndex) {
		this.inputNode.value = this.wiki.extractTiddlerDataItem(this.shortcutTiddler,this.shortcutIndex,this.shortcutDefault);
	} else {
		this.inputNode.value = this.wiki.getTiddlerText(this.shortcutTiddler,this.shortcutDefault);
	}
};

/*
Handle a dom "keydown" event
*/
EditShortcutWidget.prototype.handleKeydownEvent = function(event) {
	// Ignore shift, ctrl, meta, alt
	if(event.keyCode && $tw.keyboardManager.getModifierKeys().indexOf(event.keyCode) === -1) {
		// Get the shortcut text representation
		var value = $tw.keyboardManager.getPrintableShortcuts([{
			ctrlKey: event.ctrlKey,
			shiftKey: event.shiftKey,
			altKey: event.altKey,
			metaKey: event.metaKey,
			keyCode: event.keyCode
		}]);
		if(value.length > 0) {
			this.wiki.setText(this.shortcutTiddler,this.shortcutField,this.shortcutIndex,value[0]);
		}
		// Ignore the keydown if it was already handled
		event.preventDefault();
		event.stopPropagation();
		return true;		
	} else {
		return false;
	}
};

/*
focus the input node
*/
EditShortcutWidget.prototype.focus = function() {
	if(this.inputNode.focus && this.inputNode.select) {
		this.inputNode.focus();
		this.inputNode.select();
	}
};

/*
Selectively refreshes the widget if needed. Returns true if the widget needed re-rendering
*/
EditShortcutWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes.placeholder || changedAttributes["default"] || changedAttributes["class"] || changedAttributes.style || changedAttributes.tooltip || changedAttributes["aria-label"] || changedAttributes.focus) {
		this.refreshSelf();
		return true;
	} else if(changedTiddlers[this.shortcutTiddler]) {
		this.updateInputNode();
		return true;
	} else {
		return false;	
	}
};

exports["edit-shortcut"] = EditShortcutWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/edit-text.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/edit-text.js
type: application/javascript
module-type: widget

Edit-text widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var editTextWidgetFactory = require("$:/core/modules/editor/factory.js").editTextWidgetFactory,
	FramedEngine = require("$:/core/modules/editor/engines/framed.js").FramedEngine,
	SimpleEngine = require("$:/core/modules/editor/engines/simple.js").SimpleEngine;

exports["edit-text"] = editTextWidgetFactory(FramedEngine,SimpleEngine);

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/edit.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/edit.js
type: application/javascript
module-type: widget

Edit widget is a meta-widget chooses the appropriate actual editting widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EditWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EditWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EditWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

// Mappings from content type to editor type are stored in tiddlers with this prefix
var EDITOR_MAPPING_PREFIX = "$:/config/EditorTypeMappings/";

/*
Compute the internal state of the widget
*/
EditWidget.prototype.execute = function() {
	// Get our parameters
	this.editTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.editField = this.getAttribute("field","text");
	this.editIndex = this.getAttribute("index");
	this.editClass = this.getAttribute("class");
	this.editPlaceholder = this.getAttribute("placeholder");
	this.editTabIndex = this.getAttribute("tabindex");
	// Choose the appropriate edit widget
	this.editorType = this.getEditorType();
	// Make the child widgets
	this.makeChildWidgets([{
		type: "edit-" + this.editorType,
		attributes: {
			tiddler: {type: "string", value: this.editTitle},
			field: {type: "string", value: this.editField},
			index: {type: "string", value: this.editIndex},
			"class": {type: "string", value: this.editClass},
			"placeholder": {type: "string", value: this.editPlaceholder},
			"tabindex": {type: "string", value: this.editTabIndex}
		},
		children: this.parseTreeNode.children
	}]);
};

EditWidget.prototype.getEditorType = function() {
	// Get the content type of the thing we're editing
	var type;
	if(this.editField === "text") {
		var tiddler = this.wiki.getTiddler(this.editTitle);
		if(tiddler) {
			type = tiddler.fields.type;
		}
	}
	type = type || "text/vnd.tiddlywiki";
	var editorType = this.wiki.getTiddlerText(EDITOR_MAPPING_PREFIX + type);
	if(!editorType) {
		var typeInfo = $tw.config.contentTypeInfo[type];
		if(typeInfo && typeInfo.encoding === "base64") {
			editorType = "binary";
		} else {
			editorType = "text";
		}
	}
	return editorType;
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
EditWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	// Refresh if an attribute has changed, or the type associated with the target tiddler has changed
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes.tabindex || (changedTiddlers[this.editTitle] && this.getEditorType() !== this.editorType)) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports.edit = EditWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/element.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/element.js
type: application/javascript
module-type: widget

Element widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ElementWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ElementWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ElementWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	// Neuter blacklisted elements
	var tag = this.parseTreeNode.tag;
	if($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {
		tag = "safe-" + tag;
	}
	// Adjust headings by the current base level
	var headingLevel = ["h1","h2","h3","h4","h5","h6"].indexOf(tag);
	if(headingLevel !== -1) {
		var baseLevel = parseInt(this.getVariable("tv-adjust-heading-level","0"),10) || 0;
		headingLevel = Math.min(Math.max(headingLevel + 1 + baseLevel,1),6);
		tag = "h" + headingLevel;
	}
	// Create the DOM node
	var domNode = this.document.createElementNS(this.namespace,tag);
	this.assignAttributes(domNode,{excludeEventAttributes: true});
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

/*
Compute the internal state of the widget
*/
ElementWidget.prototype.execute = function() {
	// Select the namespace for the tag
	var tagNamespaces = {
			svg: "http://www.w3.org/2000/svg",
			math: "http://www.w3.org/1998/Math/MathML",
			body: "http://www.w3.org/1999/xhtml"
		};
	this.namespace = tagNamespaces[this.parseTreeNode.tag];
	if(this.namespace) {
		this.setVariable("namespace",this.namespace);
	} else {
		this.namespace = this.getVariable("namespace",{defaultValue: "http://www.w3.org/1999/xhtml"});
	}
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ElementWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes(),
		hasChangedAttributes = $tw.utils.count(changedAttributes) > 0;
	if(hasChangedAttributes) {
		// Update our attributes
		this.assignAttributes(this.domNodes[0],{excludeEventAttributes: true});
	}
	return this.refreshChildren(changedTiddlers) || hasChangedAttributes;
};

exports.element = ElementWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/encrypt.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/encrypt.js
type: application/javascript
module-type: widget

Encrypt widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EncryptWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EncryptWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EncryptWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var textNode = this.document.createTextNode(this.encryptedText);
	parent.insertBefore(textNode,nextSibling);
	this.domNodes.push(textNode);
};

/*
Compute the internal state of the widget
*/
EncryptWidget.prototype.execute = function() {
	// Get parameters from our attributes
	this.filter = this.getAttribute("filter","[!is[system]]");
	// Encrypt the filtered tiddlers
	var tiddlers = this.wiki.filterTiddlers(this.filter),
		json = {},
		self = this;
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = self.wiki.getTiddler(title),
			jsonTiddler = {};
		for(var f in tiddler.fields) {
			jsonTiddler[f] = tiddler.getFieldString(f);
		}
		json[title] = jsonTiddler;
	});
	this.encryptedText = $tw.utils.htmlEncode($tw.crypto.encrypt(JSON.stringify(json)));
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
EncryptWidget.prototype.refresh = function(changedTiddlers) {
	// We don't need to worry about refreshing because the encrypt widget isn't for interactive use
	return false;
};

exports.encrypt = EncryptWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/entity.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/entity.js
type: application/javascript
module-type: widget

HTML entity widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var EntityWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
EntityWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
EntityWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.execute();
	var entityString = this.getAttribute("entity",this.parseTreeNode.entity || ""),
		textNode = this.document.createTextNode($tw.utils.entityDecode(entityString));
	parent.insertBefore(textNode,nextSibling);
	this.domNodes.push(textNode);
};

/*
Compute the internal state of the widget
*/
EntityWidget.prototype.execute = function() {
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
EntityWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.entity) {
		this.refreshSelf();
		return true;
	} else {
		return false;	
	}
};

exports.entity = EntityWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/fieldmangler.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/fieldmangler.js
type: application/javascript
module-type: widget

Field mangler widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var FieldManglerWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
	this.addEventListeners([
		{type: "tm-remove-field", handler: "handleRemoveFieldEvent"},
		{type: "tm-add-field", handler: "handleAddFieldEvent"},
		{type: "tm-remove-tag", handler: "handleRemoveTagEvent"},
		{type: "tm-add-tag", handler: "handleAddTagEvent"}
	]);
};

/*
Inherit from the base widget class
*/
FieldManglerWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
FieldManglerWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
FieldManglerWidget.prototype.execute = function() {
	// Get our parameters
	this.mangleTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
FieldManglerWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);		
	}
};

FieldManglerWidget.prototype.handleRemoveFieldEvent = function(event) {
	var tiddler = this.wiki.getTiddler(this.mangleTitle),
		deletion = {};
	deletion[event.param] = undefined;
	this.wiki.addTiddler(new $tw.Tiddler(tiddler,deletion));
	return true;
};

FieldManglerWidget.prototype.handleAddFieldEvent = function(event) {
	var tiddler = this.wiki.getTiddler(this.mangleTitle),
		addition = this.wiki.getModificationFields(),
		hadInvalidFieldName = false,
		addField = function(name,value) {
			var trimmedName = name.toLowerCase().trim();
			if(!$tw.utils.isValidFieldName(trimmedName)) {
				if(!hadInvalidFieldName) {
					alert($tw.language.getString(
						"InvalidFieldName",
						{variables:
							{fieldName: trimmedName}
						}
					));
					hadInvalidFieldName = true;
					return;
				}
			} else {
				if(!value && tiddler) {
					value = tiddler.fields[trimmedName];
				}
				addition[trimmedName] = value || "";
			}
			return;
		};
	addition.title = this.mangleTitle;
	if(typeof event.param === "string") {
		addField(event.param,"");
	}
	if(typeof event.paramObject === "object") {
		for(var name in event.paramObject) {
			addField(name,event.paramObject[name]);
		}
	}
	this.wiki.addTiddler(new $tw.Tiddler(tiddler,addition));
	return true;
};

FieldManglerWidget.prototype.handleRemoveTagEvent = function(event) {
	var tiddler = this.wiki.getTiddler(this.mangleTitle),
		modification = this.wiki.getModificationFields();
	if(tiddler && tiddler.fields.tags) {
		var p = tiddler.fields.tags.indexOf(event.param);
		if(p !== -1) {
			modification.tags = (tiddler.fields.tags || []).slice(0);
			modification.tags.splice(p,1);
			if(modification.tags.length === 0) {
				modification.tags = undefined;
			}
			this.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));
		}
	}
	return true;
};

FieldManglerWidget.prototype.handleAddTagEvent = function(event) {
	var tiddler = this.wiki.getTiddler(this.mangleTitle),
		modification = this.wiki.getModificationFields();
	if(tiddler && typeof event.param === "string") {
		var tag = event.param.trim();
		if(tag !== "") {
			modification.tags = (tiddler.fields.tags || []).slice(0);
			$tw.utils.pushTop(modification.tags,tag);
			this.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));			
		}
	} else if(typeof event.param === "string" && event.param.trim() !== "" && this.mangleTitle.trim() !== "") {
		var tag = [];
		tag.push(event.param.trim());
		this.wiki.addTiddler(new $tw.Tiddler({title: this.mangleTitle, tags: tag},modification));
	}
	return true;
};

exports.fieldmangler = FieldManglerWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/fields.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/fields.js
type: application/javascript
module-type: widget

Fields widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var FieldsWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
FieldsWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
FieldsWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var textNode = this.document.createTextNode(this.text);
	parent.insertBefore(textNode,nextSibling);
	this.domNodes.push(textNode);
};

/*
Compute the internal state of the widget
*/
FieldsWidget.prototype.execute = function() {
	// Get parameters from our attributes
	this.tiddlerTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.template = this.getAttribute("template");
	this.exclude = this.getAttribute("exclude");
	this.stripTitlePrefix = this.getAttribute("stripTitlePrefix","no") === "yes";
	// Get the value to display
	var tiddler = this.wiki.getTiddler(this.tiddlerTitle);
	// Get the exclusion list
	var exclude;
	if(this.exclude) {
		exclude = this.exclude.split(" ");
	} else {
		exclude = ["text"]; 
	}
	// Compose the template
	var text = [];
	if(this.template && tiddler) {
		var fields = [];
		for(var fieldName in tiddler.fields) {
			if(exclude.indexOf(fieldName) === -1) {
				fields.push(fieldName);
			}
		}
		fields.sort();
		for(var f=0; f<fields.length; f++) {
			fieldName = fields[f];
			if(exclude.indexOf(fieldName) === -1) {
				var row = this.template,
					value = tiddler.getFieldString(fieldName);
				if(this.stripTitlePrefix && fieldName === "title") {
					var reStrip = /^\{[^\}]+\}(.+)/mg,
						reMatch = reStrip.exec(value);
					if(reMatch) {
						value = reMatch[1];
					}
				}
				row = $tw.utils.replaceString(row,"$name$",fieldName);
				row = $tw.utils.replaceString(row,"$value$",value);
				row = $tw.utils.replaceString(row,"$encoded_value$",$tw.utils.htmlEncode(value));
				text.push(row);
			}
		}
	}
	this.text = text.join("");
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
FieldsWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.template || changedAttributes.exclude || changedAttributes.stripTitlePrefix || changedTiddlers[this.tiddlerTitle]) {
		this.refreshSelf();
		return true;
	} else {
		return false;	
	}
};

exports.fields = FieldsWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/image.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/image.js
type: application/javascript
module-type: widget

The image widget displays an image referenced with an external URI or with a local tiddler title.

```
<$image src="TiddlerTitle" width="320" height="400" class="classnames">
```

The image source can be the title of an existing tiddler or the URL of an external image.

External images always generate an HTML `<img>` tag.

Tiddlers that have a _canonical_uri field generate an HTML `<img>` tag with the src attribute containing the URI.

Tiddlers that contain image data generate an HTML `<img>` tag with the src attribute containing a base64 representation of the image.

Tiddlers that contain wikitext could be rendered to a DIV of the usual size of a tiddler, and then transformed to the size requested.

The width and height attributes are interpreted as a number of pixels, and do not need to include the "px" suffix.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ImageWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ImageWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ImageWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	// Create element
	// Determine what type of image it is
	var tag = "img", src = "",
		tiddler = this.wiki.getTiddler(this.imageSource);
	if(!tiddler) {
		// The source isn't the title of a tiddler, so we'll assume it's a URL
		src = this.getVariable("tv-get-export-image-link",{params: [{name: "src",value: this.imageSource}],defaultValue: this.imageSource});
	} else {
		// Check if it is an image tiddler
		if(this.wiki.isImageTiddler(this.imageSource)) {
			var type = tiddler.fields.type,
				text = tiddler.fields.text,
				_canonical_uri = tiddler.fields._canonical_uri;
			// If the tiddler has body text then it doesn't need to be lazily loaded
			if(text) {
				// Render the appropriate element for the image type
				switch(type) {
					case "application/pdf":
						tag = "embed";
						src = "data:application/pdf;base64," + text;
						break;
					case "image/svg+xml":
						src = "data:image/svg+xml," + encodeURIComponent(text);
						break;
					default:
						src = "data:" + type + ";base64," + text;
						break;
				}
			} else if(_canonical_uri) {
				switch(type) {
					case "application/pdf":
						tag = "embed";
						src = _canonical_uri;
						break;
					case "image/svg+xml":
						src = _canonical_uri;
						break;
					default:
						src = _canonical_uri;
						break;
				}	
			} else {
				// Just trigger loading of the tiddler
				this.wiki.getTiddlerText(this.imageSource);
			}
		}
	}
	// Create the element and assign the attributes
	var domNode = this.document.createElement(tag);
	domNode.setAttribute("src",src);
	if(this.imageClass) {
		domNode.setAttribute("class",this.imageClass);		
	}
	if(this.imageWidth) {
		domNode.setAttribute("width",this.imageWidth);
	}
	if(this.imageHeight) {
		domNode.setAttribute("height",this.imageHeight);
	}
	if(this.imageTooltip) {
		domNode.setAttribute("title",this.imageTooltip);		
	}
	if(this.imageAlt) {
		domNode.setAttribute("alt",this.imageAlt);		
	}
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.domNodes.push(domNode);
};

/*
Compute the internal state of the widget
*/
ImageWidget.prototype.execute = function() {
	// Get our parameters
	this.imageSource = this.getAttribute("source");
	this.imageWidth = this.getAttribute("width");
	this.imageHeight = this.getAttribute("height");
	this.imageClass = this.getAttribute("class");
	this.imageTooltip = this.getAttribute("tooltip");
	this.imageAlt = this.getAttribute("alt");
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ImageWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.source || changedAttributes.width || changedAttributes.height || changedAttributes["class"] || changedAttributes.tooltip || changedTiddlers[this.imageSource]) {
		this.refreshSelf();
		return true;
	} else {
		return false;		
	}
};

exports.image = ImageWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/importvariables.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/importvariables.js
type: application/javascript
module-type: widget

Import variable definitions from other tiddlers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ImportVariablesWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ImportVariablesWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ImportVariablesWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
ImportVariablesWidget.prototype.execute = function(tiddlerList) {
	var self = this;
	// Get our parameters
	this.filter = this.getAttribute("filter");
	// Compute the filter
	this.tiddlerList = tiddlerList || this.wiki.filterTiddlers(this.filter,this);
	// Accumulate the <$set> widgets from each tiddler
	var widgetStackStart,widgetStackEnd;
	function addWidgetNode(widgetNode) {
		if(widgetNode) {
			if(!widgetStackStart && !widgetStackEnd) {
				widgetStackStart = widgetNode;
				widgetStackEnd = widgetNode;
			} else {
				widgetStackEnd.children = [widgetNode];
				widgetStackEnd = widgetNode;
			}
		}
	}
	$tw.utils.each(this.tiddlerList,function(title) {
		var parser = self.wiki.parseTiddler(title);
		if(parser) {
			var parseTreeNode = parser.tree[0];
			while(parseTreeNode && parseTreeNode.type === "set") {
				addWidgetNode({
					type: "set",
					attributes: parseTreeNode.attributes,
					params: parseTreeNode.params,
					isMacroDefinition: parseTreeNode.isMacroDefinition
				});
				parseTreeNode = parseTreeNode.children[0];
			}
		} 
	});
	// Add our own children to the end of the pile
	var parseTreeNodes;
	if(widgetStackStart && widgetStackEnd) {
		parseTreeNodes = [widgetStackStart];
		widgetStackEnd.children = this.parseTreeNode.children;
	} else {
		parseTreeNodes = this.parseTreeNode.children;
	}
	// Construct the child widgets
	this.makeChildWidgets(parseTreeNodes);
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ImportVariablesWidget.prototype.refresh = function(changedTiddlers) {
	// Recompute our attributes and the filter list
	var changedAttributes = this.computeAttributes(),
		tiddlerList = this.wiki.filterTiddlers(this.getAttribute("filter"),this);
	// Refresh if the filter has changed, or the list of tiddlers has changed, or any of the tiddlers in the list has changed
	function haveListedTiddlersChanged() {
		var changed = false;
		tiddlerList.forEach(function(title) {
			if(changedTiddlers[title]) {
				changed = true;
			}
		});
		return changed;
	}
	if(changedAttributes.filter || !$tw.utils.isArrayEqual(this.tiddlerList,tiddlerList) || haveListedTiddlersChanged()) {
		// Compute the filter
		this.removeChildDomNodes();
		this.execute(tiddlerList);
		this.renderChildren(this.parentDomNode,this.findNextSiblingDomNode());
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);		
	}
};

exports.importvariables = ImportVariablesWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/keyboard.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/keyboard.js
type: application/javascript
module-type: widget

Keyboard shortcut widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var KeyboardWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
KeyboardWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
KeyboardWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	var tag = this.parseTreeNode.isBlock ? "div" : "span";
	if(this.tag && $tw.config.htmlUnsafeElements.indexOf(this.tag) === -1) {
		tag = this.tag;
	}
	// Create element
	var domNode = this.document.createElement(tag);
	// Assign classes
	var classes = (this["class"] || "").split(" ");
	classes.push("tc-keyboard");
	domNode.className = classes.join(" ");
	// Add a keyboard event handler
	domNode.addEventListener("keydown",function (event) {
		if($tw.keyboardManager.checkKeyDescriptors(event,self.keyInfoArray)) {
			self.invokeActions(self,event);
			if(self.actions) {
				self.invokeActionString(self.actions,self,event);
			}
			self.dispatchMessage(event);
			event.preventDefault();
			event.stopPropagation();
			return true;
		}
		return false;
	},false);
	// Insert element
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

KeyboardWidget.prototype.dispatchMessage = function(event) {
	this.dispatchEvent({type: this.message, param: this.param, tiddlerTitle: this.getVariable("currentTiddler")});
};

/*
Compute the internal state of the widget
*/
KeyboardWidget.prototype.execute = function() {
	var self = this;
	// Get attributes
	this.actions = this.getAttribute("actions");
	this.message = this.getAttribute("message");
	this.param = this.getAttribute("param");
	this.key = this.getAttribute("key");
	this.tag = this.getAttribute("tag");
	this.keyInfoArray = $tw.keyboardManager.parseKeyDescriptors(this.key);
	this["class"] = this.getAttribute("class");
	if(this.key.substr(0,2) === "((" && this.key.substr(-2,2) === "))") {
		this.shortcutTiddlers = [];
		var name = this.key.substring(2,this.key.length -2);
		$tw.utils.each($tw.keyboardManager.lookupNames,function(platformDescriptor) {
			self.shortcutTiddlers.push("$:/config/" + platformDescriptor + "/" + name);
		});
	}
	// Make child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
KeyboardWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.message || changedAttributes.param || changedAttributes.key || changedAttributes["class"] || changedAttributes.tag) {
		this.refreshSelf();
		return true;
	}
	// Update the keyInfoArray if one of its shortcut-config-tiddlers has changed
	if(this.shortcutTiddlers && $tw.utils.hopArray(changedTiddlers,this.shortcutTiddlers)) {
		this.keyInfoArray = $tw.keyboardManager.parseKeyDescriptors(this.key);
	}
	return this.refreshChildren(changedTiddlers);
};

exports.keyboard = KeyboardWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/link.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/link.js
type: application/javascript
module-type: widget

Link widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var LinkWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
LinkWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
LinkWidget.prototype.render = function(parent,nextSibling) {
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Get the value of the tv-wikilinks configuration macro
	var wikiLinksMacro = this.getVariable("tv-wikilinks"),
		useWikiLinks = wikiLinksMacro ? (wikiLinksMacro.trim() !== "no") : true,
		missingLinksEnabled = !(this.hideMissingLinks && this.isMissing && !this.isShadow);
	// Render the link if required
	if(useWikiLinks && missingLinksEnabled) {
		this.renderLink(parent,nextSibling);
	} else {
		// Just insert the link text
		var domNode = this.document.createElement("span");
		parent.insertBefore(domNode,nextSibling);
		this.renderChildren(domNode,null);
		this.domNodes.push(domNode);
	}
};

/*
Render this widget into the DOM
*/
LinkWidget.prototype.renderLink = function(parent,nextSibling) {
	var self = this;
	// Sanitise the specified tag
	var tag = this.linkTag;
	if($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {
		tag = "a";
	}
	// Create our element
	var domNode = this.document.createElement(tag);
	// Assign classes
	var classes = [];
	if(this.overrideClasses === undefined) {
		classes.push("tc-tiddlylink");
		if(this.isShadow) {
			classes.push("tc-tiddlylink-shadow");
		}
		if(this.isMissing && !this.isShadow) {
			classes.push("tc-tiddlylink-missing");
		} else {
			if(!this.isMissing) {
				classes.push("tc-tiddlylink-resolves");
			}
		}
		if(this.linkClasses) {
			classes.push(this.linkClasses);			
		}
	} else if(this.overrideClasses !== "") {
		classes.push(this.overrideClasses)
	}
	if(classes.length > 0) {
		domNode.setAttribute("class",classes.join(" "));
	}
	// Set an href
	var wikilinkTransformFilter = this.getVariable("tv-filter-export-link"),
		wikiLinkText;
	if(wikilinkTransformFilter) {
		// Use the filter to construct the href
		wikiLinkText = this.wiki.filterTiddlers(wikilinkTransformFilter,this,function(iterator) {
			iterator(self.wiki.getTiddler(self.to),self.to)
		})[0];
	} else {
		// Expand the tv-wikilink-template variable to construct the href
		var wikiLinkTemplateMacro = this.getVariable("tv-wikilink-template"),
			wikiLinkTemplate = wikiLinkTemplateMacro ? wikiLinkTemplateMacro.trim() : "#$uri_encoded$";
		wikiLinkText = $tw.utils.replaceString(wikiLinkTemplate,"$uri_encoded$",encodeURIComponent(this.to));
		wikiLinkText = $tw.utils.replaceString(wikiLinkText,"$uri_doubleencoded$",encodeURIComponent(encodeURIComponent(this.to)));
	}
	// Override with the value of tv-get-export-link if defined
	wikiLinkText = this.getVariable("tv-get-export-link",{params: [{name: "to",value: this.to}],defaultValue: wikiLinkText});
	if(tag === "a") {
		domNode.setAttribute("href",wikiLinkText);
	}
	// Set the tabindex
	if(this.tabIndex) {
		domNode.setAttribute("tabindex",this.tabIndex);
	}
	// Set the tooltip
	// HACK: Performance issues with re-parsing the tooltip prevent us defaulting the tooltip to "<$transclude field='tooltip'><$transclude field='title'/></$transclude>"
	var tooltipWikiText = this.tooltip || this.getVariable("tv-wikilink-tooltip");
	if(tooltipWikiText) {
		var tooltipText = this.wiki.renderText("text/plain","text/vnd.tiddlywiki",tooltipWikiText,{
				parseAsInline: true,
				variables: {
					currentTiddler: this.to
				},
				parentWidget: this
			});
		domNode.setAttribute("title",tooltipText);
	}
	if(this["aria-label"]) {
		domNode.setAttribute("aria-label",this["aria-label"]);
	}
	// Add a click event handler
	$tw.utils.addEventListeners(domNode,[
		{name: "click", handlerObject: this, handlerMethod: "handleClickEvent"},
	]);
	// Make the link draggable if required
	if(this.draggable === "yes") {
		$tw.utils.makeDraggable({
			domNode: domNode,
			dragTiddlerFn: function() {return self.to;},
			widget: this
		});
	}
	// Insert the link into the DOM and render any children
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

LinkWidget.prototype.handleClickEvent = function(event) {
	// Send the click on its way as a navigate event
	var bounds = this.domNodes[0].getBoundingClientRect();
	this.dispatchEvent({
		type: "tm-navigate",
		navigateTo: this.to,
		navigateFromTitle: this.getVariable("storyTiddler"),
		navigateFromNode: this,
		navigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height
		},
		navigateSuppressNavigation: event.metaKey || event.ctrlKey || (event.button === 1),
		metaKey: event.metaKey,
		ctrlKey: event.ctrlKey,
		altKey: event.altKey,
		shiftKey: event.shiftKey
	});
	if(this.domNodes[0].hasAttribute("href")) {
		event.preventDefault();
	}
	event.stopPropagation();
	return false;
};

/*
Compute the internal state of the widget
*/
LinkWidget.prototype.execute = function() {
	// Pick up our attributes
	this.to = this.getAttribute("to",this.getVariable("currentTiddler"));
	this.tooltip = this.getAttribute("tooltip");
	this["aria-label"] = this.getAttribute("aria-label");
	this.linkClasses = this.getAttribute("class");
	this.overrideClasses = this.getAttribute("overrideClass");
	this.tabIndex = this.getAttribute("tabindex");
	this.draggable = this.getAttribute("draggable","yes");
	this.linkTag = this.getAttribute("tag","a");
	// Determine the link characteristics
	this.isMissing = !this.wiki.tiddlerExists(this.to);
	this.isShadow = this.wiki.isShadowTiddler(this.to);
	this.hideMissingLinks = (this.getVariable("tv-show-missing-links") || "yes") === "no";
	// Make the child widgets
	var templateTree;
	if(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {
		templateTree = this.parseTreeNode.children;
	} else {
		// Default template is a link to the title
		templateTree = [{type: "text", text: this.to}];
	}
	this.makeChildWidgets(templateTree);
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
LinkWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.to || changedTiddlers[this.to] || changedAttributes["aria-label"] || changedAttributes.tooltip) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports.link = LinkWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/linkcatcher.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/linkcatcher.js
type: application/javascript
module-type: widget

Linkcatcher widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var LinkCatcherWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
	this.addEventListeners([
		{type: "tm-navigate", handler: "handleNavigateEvent"}
	]);
};

/*
Inherit from the base widget class
*/
LinkCatcherWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
LinkCatcherWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
LinkCatcherWidget.prototype.execute = function() {
	// Get our parameters
	this.catchTo = this.getAttribute("to");
	this.catchMessage = this.getAttribute("message");
	this.catchSet = this.getAttribute("set");
	this.catchSetTo = this.getAttribute("setTo");
	this.catchActions = this.getAttribute("actions");
	// Construct the child widgets
	this.makeChildWidgets();
	// When executing actions we avoid trapping navigate events, so that we don't trigger ourselves recursively
	this.executingActions = false;
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
LinkCatcherWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.to || changedAttributes.message || changedAttributes.set || changedAttributes.setTo) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);		
	}
};

/*
Handle a tm-navigate event
*/
LinkCatcherWidget.prototype.handleNavigateEvent = function(event) {
	if(!this.executingActions) {
		// Execute the actions
		if(this.catchTo) {
			this.wiki.setTextReference(this.catchTo,event.navigateTo,this.getVariable("currentTiddler"));
		}
		if(this.catchMessage && this.parentWidget) {
			this.parentWidget.dispatchEvent({
				type: this.catchMessage,
				param: event.navigateTo,
				navigateTo: event.navigateTo
			});
		}
		if(this.catchSet) {
			var tiddler = this.wiki.getTiddler(this.catchSet);
			this.wiki.addTiddler(new $tw.Tiddler(tiddler,{title: this.catchSet, text: this.catchSetTo}));
		}
		if(this.catchActions) {
			this.executingActions = true;
			this.invokeActionString(this.catchActions,this,event,{navigateTo: event.navigateTo});
			this.executingActions = false;
		}
	} else {
		// This is a navigate event generated by the actions of this linkcatcher, so we don't trap it again, but just pass it to the parent
		this.parentWidget.dispatchEvent({
			type: "tm-navigate",
			param: event.navigateTo,
			navigateTo: event.navigateTo
		});
	}
	return false;
};

exports.linkcatcher = LinkCatcherWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/list.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/list.js
type: application/javascript
module-type: widget

List and list item widgets

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

/*
The list widget creates list element sub-widgets that reach back into the list widget for their configuration
*/

var ListWidget = function(parseTreeNode,options) {
	// Initialise the storyviews if they've not been done already
	if(!this.storyViews) {
		ListWidget.prototype.storyViews = {};
		$tw.modules.applyMethods("storyview",this.storyViews);
	}
	// Main initialisation inherited from widget.js
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ListWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ListWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
	// Construct the storyview
	var StoryView = this.storyViews[this.storyViewName];
	if(this.storyViewName && !StoryView) {
		StoryView = this.storyViews["classic"];
	}
	if(StoryView && !this.document.isTiddlyWikiFakeDom) {
		this.storyview = new StoryView(this);
	} else {
		this.storyview = null;
	}
};

/*
Compute the internal state of the widget
*/
ListWidget.prototype.execute = function() {
	// Get our attributes
	this.template = this.getAttribute("template");
	this.editTemplate = this.getAttribute("editTemplate");
	this.variableName = this.getAttribute("variable","currentTiddler");
	this.storyViewName = this.getAttribute("storyview");
	this.historyTitle = this.getAttribute("history");
	// Compose the list elements
	this.list = this.getTiddlerList();
	var members = [],
		self = this;
	// Check for an empty list
	if(this.list.length === 0) {
		members = this.getEmptyMessage();
	} else {
		$tw.utils.each(this.list,function(title,index) {
			members.push(self.makeItemTemplate(title));
		});
	}
	// Construct the child widgets
	this.makeChildWidgets(members);
	// Clear the last history
	this.history = [];
};

ListWidget.prototype.getTiddlerList = function() {
	var defaultFilter = "[!is[system]sort[title]]";
	return this.wiki.filterTiddlers(this.getAttribute("filter",defaultFilter),this);
};

ListWidget.prototype.getEmptyMessage = function() {
	var emptyMessage = this.getAttribute("emptyMessage",""),
		parser = this.wiki.parseText("text/vnd.tiddlywiki",emptyMessage,{parseAsInline: true});
	if(parser) {
		return parser.tree;
	} else {
		return [];
	}
};

/*
Compose the template for a list item
*/
ListWidget.prototype.makeItemTemplate = function(title) {
	// Check if the tiddler is a draft
	var tiddler = this.wiki.getTiddler(title),
		isDraft = tiddler && tiddler.hasField("draft.of"),
		template = this.template,
		templateTree;
	if(isDraft && this.editTemplate) {
		template = this.editTemplate;
	}
	// Compose the transclusion of the template
	if(template) {
		templateTree = [{type: "transclude", attributes: {tiddler: {type: "string", value: template}}}];
	} else {
		if(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {
			templateTree = this.parseTreeNode.children;
		} else {
			// Default template is a link to the title
			templateTree = [{type: "element", tag: this.parseTreeNode.isBlock ? "div" : "span", children: [{type: "link", attributes: {to: {type: "string", value: title}}, children: [
					{type: "text", text: title}
			]}]}];
		}
	}
	// Return the list item
	return {type: "listitem", itemTitle: title, variableName: this.variableName, children: templateTree};
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ListWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes(),
		result;
	// Call the storyview
	if(this.storyview && this.storyview.refreshStart) {
		this.storyview.refreshStart(changedTiddlers,changedAttributes);
	}
	// Completely refresh if any of our attributes have changed
	if(changedAttributes.filter || changedAttributes.template || changedAttributes.editTemplate || changedAttributes.emptyMessage || changedAttributes.storyview || changedAttributes.history) {
		this.refreshSelf();
		result = true;
	} else {
		// Handle any changes to the list
		result = this.handleListChanges(changedTiddlers);
		// Handle any changes to the history stack
		if(this.historyTitle && changedTiddlers[this.historyTitle]) {
			this.handleHistoryChanges();
		}
	}
	// Call the storyview
	if(this.storyview && this.storyview.refreshEnd) {
		this.storyview.refreshEnd(changedTiddlers,changedAttributes);
	}
	return result;
};

/*
Handle any changes to the history list
*/
ListWidget.prototype.handleHistoryChanges = function() {
	// Get the history data
	var newHistory = this.wiki.getTiddlerDataCached(this.historyTitle,[]);
	// Ignore any entries of the history that match the previous history
	var entry = 0;
	while(entry < newHistory.length && entry < this.history.length && newHistory[entry].title === this.history[entry].title) {
		entry++;
	}
	// Navigate forwards to each of the new tiddlers
	while(entry < newHistory.length) {
		if(this.storyview && this.storyview.navigateTo) {
			this.storyview.navigateTo(newHistory[entry]);
		}
		entry++;
	}
	// Update the history
	this.history = newHistory;
};

/*
Process any changes to the list
*/
ListWidget.prototype.handleListChanges = function(changedTiddlers) {
	// Get the new list
	var prevList = this.list;
	this.list = this.getTiddlerList();
	// Check for an empty list
	if(this.list.length === 0) {
		// Check if it was empty before
		if(prevList.length === 0) {
			// If so, just refresh the empty message
			return this.refreshChildren(changedTiddlers);
		} else {
			// Replace the previous content with the empty message
			for(t=this.children.length-1; t>=0; t--) {
				this.removeListItem(t);
			}
			var nextSibling = this.findNextSiblingDomNode();
			this.makeChildWidgets(this.getEmptyMessage());
			this.renderChildren(this.parentDomNode,nextSibling);
			return true;
		}
	} else {
		// If the list was empty then we need to remove the empty message
		if(prevList.length === 0) {
			this.removeChildDomNodes();
			this.children = [];
		}
		// Cycle through the list, inserting and removing list items as needed
		var hasRefreshed = false;
		for(var t=0; t<this.list.length; t++) {
			var index = this.findListItem(t,this.list[t]);
			if(index === undefined) {
				// The list item must be inserted
				this.insertListItem(t,this.list[t]);
				hasRefreshed = true;
			} else {
				// There are intervening list items that must be removed
				for(var n=index-1; n>=t; n--) {
					this.removeListItem(n);
					hasRefreshed = true;
				}
				// Refresh the item we're reusing
				var refreshed = this.children[t].refresh(changedTiddlers);
				hasRefreshed = hasRefreshed || refreshed;
			}
		}
		// Remove any left over items
		for(t=this.children.length-1; t>=this.list.length; t--) {
			this.removeListItem(t);
			hasRefreshed = true;
		}
		return hasRefreshed;
	}
};

/*
Find the list item with a given title, starting from a specified position
*/
ListWidget.prototype.findListItem = function(startIndex,title) {
	while(startIndex < this.children.length) {
		if(this.children[startIndex].parseTreeNode.itemTitle === title) {
			return startIndex;
		}
		startIndex++;
	}
	return undefined;
};

/*
Insert a new list item at the specified index
*/
ListWidget.prototype.insertListItem = function(index,title) {
	// Create, insert and render the new child widgets
	var widget = this.makeChildWidget(this.makeItemTemplate(title));
	widget.parentDomNode = this.parentDomNode; // Hack to enable findNextSiblingDomNode() to work
	this.children.splice(index,0,widget);
	var nextSibling = widget.findNextSiblingDomNode();
	widget.render(this.parentDomNode,nextSibling);
	// Animate the insertion if required
	if(this.storyview && this.storyview.insert) {
		this.storyview.insert(widget);
	}
	return true;
};

/*
Remove the specified list item
*/
ListWidget.prototype.removeListItem = function(index) {
	var widget = this.children[index];
	// Animate the removal if required
	if(this.storyview && this.storyview.remove) {
		this.storyview.remove(widget);
	} else {
		widget.removeChildDomNodes();
	}
	// Remove the child widget
	this.children.splice(index,1);
};

exports.list = ListWidget;

var ListItemWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ListItemWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ListItemWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
ListItemWidget.prototype.execute = function() {
	// Set the current list item title
	this.setVariable(this.parseTreeNode.variableName,this.parseTreeNode.itemTitle);
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ListItemWidget.prototype.refresh = function(changedTiddlers) {
	return this.refreshChildren(changedTiddlers);
};

exports.listitem = ListItemWidget;

})();
;})();
return exports;
}));
_define("$:/core/modules/widgets/macrocall.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/macrocall.js
type: application/javascript
module-type: widget

Macrocall widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var MacroCallWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
MacroCallWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
MacroCallWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
MacroCallWidget.prototype.execute = function() {
	// Get the parse type if specified
	this.parseType = this.getAttribute("$type","text/vnd.tiddlywiki");
	this.renderOutput = this.getAttribute("$output","text/html");
	// Merge together the parameters specified in the parse tree with the specified attributes
	var params = this.parseTreeNode.params ? this.parseTreeNode.params.slice(0) : [];
	$tw.utils.each(this.attributes,function(attribute,name) {
		if(name.charAt(0) !== "$") {
			params.push({name: name, value: attribute});			
		}
	});
	// Get the macro value
	var macroName = this.parseTreeNode.name || this.getAttribute("$name"),
		variableInfo = this.getVariableInfo(macroName,{params: params}),
		text = variableInfo.text,
		parseTreeNodes;
	// Are we rendering to HTML?
	if(this.renderOutput === "text/html") {
		// If so we'll return the parsed macro
		var parser = this.wiki.parseText(this.parseType,text,
							{parseAsInline: !this.parseTreeNode.isBlock});
		parseTreeNodes = parser ? parser.tree : [];
		// Wrap the parse tree in a vars widget assigning the parameters to variables named "__paramname__"
		var attributes = {};
		$tw.utils.each(variableInfo.params,function(param) {
			var name = "__" + param.name + "__";
			attributes[name] = {
				name: name,
				type: "string",
				value: param.value
			};
		});
		parseTreeNodes = [{
			type: "vars",
			attributes: attributes,
			children: parseTreeNodes
		}];
	} else {
		// Otherwise, we'll render the text
		var plainText = this.wiki.renderText("text/plain",this.parseType,text,{parentWidget: this});
		parseTreeNodes = [{type: "text", text: plainText}];
	}
	// Construct the child widgets
	this.makeChildWidgets(parseTreeNodes);
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
MacroCallWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if($tw.utils.count(changedAttributes) > 0) {
		// Rerender ourselves
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports.macrocall = MacroCallWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/navigator.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/navigator.js
type: application/javascript
module-type: widget

Navigator widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var IMPORT_TITLE = "$:/Import";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var NavigatorWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
	this.addEventListeners([
		{type: "tm-navigate", handler: "handleNavigateEvent"},
		{type: "tm-edit-tiddler", handler: "handleEditTiddlerEvent"},
		{type: "tm-delete-tiddler", handler: "handleDeleteTiddlerEvent"},
		{type: "tm-save-tiddler", handler: "handleSaveTiddlerEvent"},
		{type: "tm-cancel-tiddler", handler: "handleCancelTiddlerEvent"},
		{type: "tm-close-tiddler", handler: "handleCloseTiddlerEvent"},
		{type: "tm-close-all-tiddlers", handler: "handleCloseAllTiddlersEvent"},
		{type: "tm-close-other-tiddlers", handler: "handleCloseOtherTiddlersEvent"},
		{type: "tm-new-tiddler", handler: "handleNewTiddlerEvent"},
		{type: "tm-import-tiddlers", handler: "handleImportTiddlersEvent"},
		{type: "tm-perform-import", handler: "handlePerformImportEvent"},
		{type: "tm-fold-tiddler", handler: "handleFoldTiddlerEvent"},
		{type: "tm-fold-other-tiddlers", handler: "handleFoldOtherTiddlersEvent"},
		{type: "tm-fold-all-tiddlers", handler: "handleFoldAllTiddlersEvent"},
		{type: "tm-unfold-all-tiddlers", handler: "handleUnfoldAllTiddlersEvent"},
		{type: "tm-rename-tiddler", handler: "handleRenameTiddlerEvent"}
	]);
};

/*
Inherit from the base widget class
*/
NavigatorWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
NavigatorWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
NavigatorWidget.prototype.execute = function() {
	// Get our parameters
	this.storyTitle = this.getAttribute("story");
	this.historyTitle = this.getAttribute("history");
	this.setVariable("tv-story-list",this.storyTitle);
	this.setVariable("tv-history-list",this.historyTitle);
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
NavigatorWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.story || changedAttributes.history) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

NavigatorWidget.prototype.getStoryList = function() {
	return this.storyTitle ? this.wiki.getTiddlerList(this.storyTitle) : null;
};

NavigatorWidget.prototype.saveStoryList = function(storyList) {
	var storyTiddler = this.wiki.getTiddler(this.storyTitle);
	this.wiki.addTiddler(new $tw.Tiddler(
		{title: this.storyTitle},
		storyTiddler,
		{list: storyList}
	));
};

NavigatorWidget.prototype.removeTitleFromStory = function(storyList,title) {
	var p = storyList.indexOf(title);
	while(p !== -1) {
		storyList.splice(p,1);
		p = storyList.indexOf(title);
	}
};

NavigatorWidget.prototype.replaceFirstTitleInStory = function(storyList,oldTitle,newTitle) {
	var pos = storyList.indexOf(oldTitle);
	if(pos !== -1) {
		storyList[pos] = newTitle;
		do {
			pos = storyList.indexOf(oldTitle,pos + 1);
			if(pos !== -1) {
				storyList.splice(pos,1);
			}
		} while(pos !== -1);
	} else {
		storyList.splice(0,0,newTitle);
	}
};

NavigatorWidget.prototype.addToStory = function(title,fromTitle) {
	this.wiki.addToStory(title,fromTitle,this.storyTitle,{openLinkFromInsideRiver: this.getAttribute("openLinkFromInsideRiver","top"),openLinkFromOutsideRiver: this.getAttribute("openLinkFromOutsideRiver","top")});
};

/*
Add a new record to the top of the history stack
title: a title string or an array of title strings
fromPageRect: page coordinates of the origin of the navigation
*/
NavigatorWidget.prototype.addToHistory = function(title,fromPageRect) {
	this.wiki.addToHistory(title,fromPageRect,this.historyTitle);
};

/*
Handle a tm-navigate event
*/
NavigatorWidget.prototype.handleNavigateEvent = function(event) {
	event = $tw.hooks.invokeHook("th-navigating",event);
	if(event.navigateTo) {
		this.addToStory(event.navigateTo,event.navigateFromTitle);
		if(!event.navigateSuppressNavigation) {
			this.addToHistory(event.navigateTo,event.navigateFromClientRect);
		}
	}
	return false;
};

// Close a specified tiddler
NavigatorWidget.prototype.handleCloseTiddlerEvent = function(event) {
	var title = event.param || event.tiddlerTitle,
		storyList = this.getStoryList();
	// Look for tiddlers with this title to close
	this.removeTitleFromStory(storyList,title);
	this.saveStoryList(storyList);
	return false;
};

// Close all tiddlers
NavigatorWidget.prototype.handleCloseAllTiddlersEvent = function(event) {
	this.saveStoryList([]);
	return false;
};

// Close other tiddlers
NavigatorWidget.prototype.handleCloseOtherTiddlersEvent = function(event) {
	var title = event.param || event.tiddlerTitle;
	this.saveStoryList([title]);
	return false;
};

// Place a tiddler in edit mode
NavigatorWidget.prototype.handleEditTiddlerEvent = function(event) {
	var editTiddler = $tw.hooks.invokeHook("th-editing-tiddler",event);
	if(!editTiddler) {
		return false;
	}
	var self = this;
	function isUnmodifiedShadow(title) {
		return self.wiki.isShadowTiddler(title) && !self.wiki.tiddlerExists(title);
	}
	function confirmEditShadow(title) {
		return confirm($tw.language.getString(
			"ConfirmEditShadowTiddler",
			{variables:
				{title: title}
			}
		));
	}
	var title = event.param || event.tiddlerTitle;
	if(isUnmodifiedShadow(title) && !confirmEditShadow(title)) {
		return false;
	}
	// Replace the specified tiddler with a draft in edit mode
	var draftTiddler = this.makeDraftTiddler(title);
	// Update the story and history if required
	if(!event.paramObject || event.paramObject.suppressNavigation !== "yes") {
		var draftTitle = draftTiddler.fields.title,
			storyList = this.getStoryList();
		this.removeTitleFromStory(storyList,draftTitle);
		this.replaceFirstTitleInStory(storyList,title,draftTitle);
		this.addToHistory(draftTitle,event.navigateFromClientRect);
		this.saveStoryList(storyList);
		return false;
	}
};

// Delete a tiddler
NavigatorWidget.prototype.handleDeleteTiddlerEvent = function(event) {
	// Get the tiddler we're deleting
	var title = event.param || event.tiddlerTitle,
		tiddler = this.wiki.getTiddler(title),
		storyList = this.getStoryList(),
		originalTitle = tiddler ? tiddler.fields["draft.of"] : "",
		originalTiddler = originalTitle ? this.wiki.getTiddler(originalTitle) : undefined,
		confirmationTitle;
	if(!tiddler) {
		return false;
	}
	// Check if the tiddler we're deleting is in draft mode
	if(originalTitle) {
		// If so, we'll prompt for confirmation referencing the original tiddler
		confirmationTitle = originalTitle;
	} else {
		// If not a draft, then prompt for confirmation referencing the specified tiddler
		confirmationTitle = title;
	}
	// Seek confirmation
	if((this.wiki.getTiddler(originalTitle) || (tiddler.fields.text || "") !== "") && !confirm($tw.language.getString(
				"ConfirmDeleteTiddler",
				{variables:
					{title: confirmationTitle}
				}
			))) {
		return false;
	}
	// Delete the original tiddler
	if(originalTitle) {
		if(originalTiddler) {
			$tw.hooks.invokeHook("th-deleting-tiddler",originalTiddler);
		}
		this.wiki.deleteTiddler(originalTitle);
		this.removeTitleFromStory(storyList,originalTitle);
	}
	// Invoke the hook function and delete this tiddler
	$tw.hooks.invokeHook("th-deleting-tiddler",tiddler);
	this.wiki.deleteTiddler(title);
	// Remove the closed tiddler from the story
	this.removeTitleFromStory(storyList,title);
	this.saveStoryList(storyList);
	// Trigger an autosave
	$tw.rootWidget.dispatchEvent({type: "tm-auto-save-wiki"});
	return false;
};

/*
Create/reuse the draft tiddler for a given title
*/
NavigatorWidget.prototype.makeDraftTiddler = function(targetTitle) {
	// See if there is already a draft tiddler for this tiddler
	var draftTitle = this.wiki.findDraft(targetTitle);
	if(draftTitle) {
		return this.wiki.getTiddler(draftTitle);
	}
	// Get the current value of the tiddler we're editing
	var tiddler = this.wiki.getTiddler(targetTitle);
	// Save the initial value of the draft tiddler
	draftTitle = this.generateDraftTitle(targetTitle);
	var draftTiddler = new $tw.Tiddler(
			tiddler,
			{
				title: draftTitle,
				"draft.title": targetTitle,
				"draft.of": targetTitle
			},
			this.wiki.getModificationFields()
		);
	this.wiki.addTiddler(draftTiddler);
	return draftTiddler;
};

/*
Generate a title for the draft of a given tiddler
*/
NavigatorWidget.prototype.generateDraftTitle = function(title) {
	return this.wiki.generateDraftTitle(title);
};

// Take a tiddler out of edit mode, saving the changes
NavigatorWidget.prototype.handleSaveTiddlerEvent = function(event) {
	var title = event.param || event.tiddlerTitle,
		tiddler = this.wiki.getTiddler(title),
		storyList = this.getStoryList();
	// Replace the original tiddler with the draft
	if(tiddler) {
		var draftTitle = (tiddler.fields["draft.title"] || "").trim(),
			draftOf = (tiddler.fields["draft.of"] || "").trim();
		if(draftTitle) {
			var isRename = draftOf !== draftTitle,
				isConfirmed = true;
			if(isRename && this.wiki.tiddlerExists(draftTitle)) {
				isConfirmed = confirm($tw.language.getString(
					"ConfirmOverwriteTiddler",
					{variables:
						{title: draftTitle}
					}
				));
			}
			if(isConfirmed) {
				// Create the new tiddler and pass it through the th-saving-tiddler hook
				var newTiddler = new $tw.Tiddler(this.wiki.getCreationFields(),tiddler,{
					title: draftTitle,
					"draft.title": undefined,
					"draft.of": undefined
				},this.wiki.getModificationFields());
				newTiddler = $tw.hooks.invokeHook("th-saving-tiddler",newTiddler);
				this.wiki.addTiddler(newTiddler);
				// If enabled, relink references to renamed tiddler
				var shouldRelink = this.getAttribute("relinkOnRename","no").toLowerCase().trim() === "yes";
				if(isRename && shouldRelink && this.wiki.tiddlerExists(draftOf)) {
console.log("Relinking '" + draftOf + "' to '" + draftTitle + "'");
					this.wiki.relinkTiddler(draftOf,draftTitle);
				}
				// Remove the draft tiddler
				this.wiki.deleteTiddler(title);
				// Remove the original tiddler if we're renaming it
				if(isRename) {
					this.wiki.deleteTiddler(draftOf);
				}
				// #2381 always remove new title & old
				this.removeTitleFromStory(storyList,draftTitle);
				this.removeTitleFromStory(storyList,draftOf);
				if(!event.paramObject || event.paramObject.suppressNavigation !== "yes") {
					// Replace the draft in the story with the original
					this.replaceFirstTitleInStory(storyList,title,draftTitle);
					this.addToHistory(draftTitle,event.navigateFromClientRect);
					if(draftTitle !== this.storyTitle) {
						this.saveStoryList(storyList);
					}
				}
				// Trigger an autosave
				$tw.rootWidget.dispatchEvent({type: "tm-auto-save-wiki"});
			}
		}
	}
	return false;
};

// Take a tiddler out of edit mode without saving the changes
NavigatorWidget.prototype.handleCancelTiddlerEvent = function(event) {
	event = $tw.hooks.invokeHook("th-cancelling-tiddler", event);
	// Flip the specified tiddler from draft back to the original
	var draftTitle = event.param || event.tiddlerTitle,
		draftTiddler = this.wiki.getTiddler(draftTitle),
		originalTitle = draftTiddler && draftTiddler.fields["draft.of"];
	if(draftTiddler && originalTitle) {
		// Ask for confirmation if the tiddler text has changed
		var isConfirmed = true,
			originalTiddler = this.wiki.getTiddler(originalTitle),
			storyList = this.getStoryList();
		if(this.wiki.isDraftModified(draftTitle)) {
			isConfirmed = confirm($tw.language.getString(
				"ConfirmCancelTiddler",
				{variables:
					{title: draftTitle}
				}
			));
		}
		// Remove the draft tiddler
		if(isConfirmed) {
			this.wiki.deleteTiddler(draftTitle);
			if(!event.paramObject || event.paramObject.suppressNavigation !== "yes") {
				if(originalTiddler) {
					this.replaceFirstTitleInStory(storyList,draftTitle,originalTitle);
					this.addToHistory(originalTitle,event.navigateFromClientRect);
				} else {
					this.removeTitleFromStory(storyList,draftTitle);
				}
				this.saveStoryList(storyList);
			}
		}
	}
	return false;
};

// Create a new draft tiddler
// event.param can either be the title of a template tiddler, or a hashmap of fields.
//
// The title of the newly created tiddler follows these rules:
// * If a hashmap was used and a title field was specified, use that title
// * If a hashmap was used without a title field, use a default title, if necessary making it unique with a numeric suffix
// * If a template tiddler was used, use the title of the template, if necessary making it unique with a numeric suffix
//
// If a draft of the target tiddler already exists then it is reused
NavigatorWidget.prototype.handleNewTiddlerEvent = function(event) {
	event = $tw.hooks.invokeHook("th-new-tiddler", event);
	// Get the story details
	var storyList = this.getStoryList(),
		templateTiddler, additionalFields, title, draftTitle, existingTiddler;
	// Get the template tiddler (if any)
	if(typeof event.param === "string") {
		// Get the template tiddler
		templateTiddler = this.wiki.getTiddler(event.param);
		// Generate a new title
		title = this.wiki.generateNewTitle(event.param || $tw.language.getString("DefaultNewTiddlerTitle"));
	}
	// Get the specified additional fields
	if(typeof event.paramObject === "object") {
		additionalFields = event.paramObject;
	}
	if(typeof event.param === "object") { // Backwards compatibility with 5.1.3
		additionalFields = event.param;
	}
	if(additionalFields && additionalFields.title) {
		title = additionalFields.title;
	}
	// Make a copy of the additional fields excluding any blank ones
	var filteredAdditionalFields = $tw.utils.extend({},additionalFields);
	Object.keys(filteredAdditionalFields).forEach(function(fieldName) {
		if(filteredAdditionalFields[fieldName] === "") {
			delete filteredAdditionalFields[fieldName];
		}
	});
	// Generate a title if we don't have one
	title = title || this.wiki.generateNewTitle($tw.language.getString("DefaultNewTiddlerTitle"));
	// Find any existing draft for this tiddler
	draftTitle = this.wiki.findDraft(title);
	// Pull in any existing tiddler
	if(draftTitle) {
		existingTiddler = this.wiki.getTiddler(draftTitle);
	} else {
		draftTitle = this.generateDraftTitle(title);
		existingTiddler = this.wiki.getTiddler(title);
	}
	// Merge the tags
	var mergedTags = [];
	if(existingTiddler && existingTiddler.fields.tags) {
		$tw.utils.pushTop(mergedTags,existingTiddler.fields.tags);
	}
	if(additionalFields && additionalFields.tags) {
		// Merge tags
		mergedTags = $tw.utils.pushTop(mergedTags,$tw.utils.parseStringArray(additionalFields.tags));
	}
	if(templateTiddler && templateTiddler.fields.tags) {
		// Merge tags
		mergedTags = $tw.utils.pushTop(mergedTags,templateTiddler.fields.tags);
	}
	// Save the draft tiddler
	var draftTiddler = new $tw.Tiddler({
			text: "",
			"draft.title": title
		},
		templateTiddler,
		additionalFields,
		this.wiki.getCreationFields(),
		existingTiddler,
		filteredAdditionalFields,
		{
			title: draftTitle,
			"draft.of": title,
			tags: mergedTags
		},this.wiki.getModificationFields());
	this.wiki.addTiddler(draftTiddler);
	// Update the story to insert the new draft at the top and remove any existing tiddler
	if(storyList.indexOf(draftTitle) === -1) {
		var slot = storyList.indexOf(event.navigateFromTitle);
		if(slot === -1) {
			slot = this.getAttribute("openLinkFromOutsideRiver","top") === "bottom" ? storyList.length - 1 : slot;
		}
		storyList.splice(slot + 1,0,draftTitle);
	}
	if(storyList.indexOf(title) !== -1) {
		storyList.splice(storyList.indexOf(title),1);
	}
	this.saveStoryList(storyList);
	// Add a new record to the top of the history stack
	this.addToHistory(draftTitle);
	return false;
};

// Import JSON tiddlers into a pending import tiddler
NavigatorWidget.prototype.handleImportTiddlersEvent = function(event) {
	// Get the tiddlers
	var tiddlers = [];
	try {
		tiddlers = JSON.parse(event.param);
	} catch(e) {
	}
	// Get the current $:/Import tiddler
	var importTiddler = this.wiki.getTiddler(IMPORT_TITLE),
		importData = this.wiki.getTiddlerData(IMPORT_TITLE,{}),
		newFields = new Object({
			title: IMPORT_TITLE,
			type: "application/json",
			"plugin-type": "import",
			"status": "pending"
		}),
		incomingTiddlers = [];
	// Process each tiddler
	importData.tiddlers = importData.tiddlers || {};
	$tw.utils.each(tiddlers,function(tiddlerFields) {
		tiddlerFields.title = $tw.utils.trim(tiddlerFields.title);
		var title = tiddlerFields.title;
		if(title) {
			incomingTiddlers.push(title);
			importData.tiddlers[title] = tiddlerFields;
		}
	});
	// Give the active upgrader modules a chance to process the incoming tiddlers
	var messages = this.wiki.invokeUpgraders(incomingTiddlers,importData.tiddlers);
	$tw.utils.each(messages,function(message,title) {
		newFields["message-" + title] = message;
	});
	// Deselect any suppressed tiddlers
	$tw.utils.each(importData.tiddlers,function(tiddler,title) {
		if($tw.utils.count(tiddler) === 0) {
			newFields["selection-" + title] = "unchecked";
		}
	});
	// Save the $:/Import tiddler
	newFields.text = JSON.stringify(importData,null,$tw.config.preferences.jsonSpaces);
	this.wiki.addTiddler(new $tw.Tiddler(importTiddler,newFields));
	// Update the story and history details
	if(this.getVariable("tv-auto-open-on-import") !== "no") {
		var storyList = this.getStoryList(),
			history = [];
		// Add it to the story
		if(storyList.indexOf(IMPORT_TITLE) === -1) {
			storyList.unshift(IMPORT_TITLE);
		}
		// And to history
		history.push(IMPORT_TITLE);
		// Save the updated story and history
		this.saveStoryList(storyList);
		this.addToHistory(history);
	}
	return false;
};

//
NavigatorWidget.prototype.handlePerformImportEvent = function(event) {
	var self = this,
		importTiddler = this.wiki.getTiddler(event.param),
		importData = this.wiki.getTiddlerDataCached(event.param,{tiddlers: {}}),
		importReport = [];
	// Add the tiddlers to the store
	importReport.push($tw.language.getString("Import/Imported/Hint") + "\n");
	$tw.utils.each(importData.tiddlers,function(tiddlerFields) {
		var title = tiddlerFields.title;
		if(title && importTiddler && importTiddler.fields["selection-" + title] !== "unchecked") {
			var tiddler = new $tw.Tiddler(tiddlerFields);
			tiddler = $tw.hooks.invokeHook("th-importing-tiddler",tiddler);
			self.wiki.addTiddler(tiddler);
			importReport.push("# [[" + tiddlerFields.title + "]]");
		}
	});
	// Replace the $:/Import tiddler with an import report
	this.wiki.addTiddler(new $tw.Tiddler({
		title: event.param,
		text: importReport.join("\n"),
		"status": "complete"
	}));
	// Navigate to the $:/Import tiddler
	this.addToHistory([event.param]);
	// Trigger an autosave
	$tw.rootWidget.dispatchEvent({type: "tm-auto-save-wiki"});
};

NavigatorWidget.prototype.handleFoldTiddlerEvent = function(event) {
	var paramObject = event.paramObject || {};
	if(paramObject.foldedState) {
		var foldedState = this.wiki.getTiddlerText(paramObject.foldedState,"show") === "show" ? "hide" : "show";
		this.wiki.setText(paramObject.foldedState,"text",null,foldedState);
	}
};

NavigatorWidget.prototype.handleFoldOtherTiddlersEvent = function(event) {
	var self = this,
		paramObject = event.paramObject || {},
		prefix = paramObject.foldedStatePrefix;
	$tw.utils.each(this.getStoryList(),function(title) {
		self.wiki.setText(prefix + title,"text",null,event.param === title ? "show" : "hide");
	});
};

NavigatorWidget.prototype.handleFoldAllTiddlersEvent = function(event) {
	var self = this,
		paramObject = event.paramObject || {},
		prefix = paramObject.foldedStatePrefix || "$:/state/folded/";
	$tw.utils.each(this.getStoryList(),function(title) {
		self.wiki.setText(prefix + title,"text",null,"hide");
	});
};

NavigatorWidget.prototype.handleUnfoldAllTiddlersEvent = function(event) {
	var self = this,
		paramObject = event.paramObject || {},
		prefix = paramObject.foldedStatePrefix;
	$tw.utils.each(this.getStoryList(),function(title) {
		self.wiki.setText(prefix + title,"text",null,"show");
	});
};

NavigatorWidget.prototype.handleRenameTiddlerEvent = function(event) {
	event = $tw.hooks.invokeHook("th-renaming-tiddler", event);
	var paramObject = event.paramObject || {},
		from = paramObject.from || event.tiddlerTitle,
		to = paramObject.to;
	$tw.wiki.renameTiddler(from,to);
};

exports.navigator = NavigatorWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/password.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/password.js
type: application/javascript
module-type: widget

Password widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var PasswordWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
PasswordWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
PasswordWidget.prototype.render = function(parent,nextSibling) {
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Get the current password
	var password = $tw.browser ? $tw.utils.getPassword(this.passwordName) || "" : "";
	// Create our element
	var domNode = this.document.createElement("input");
	domNode.setAttribute("type","password");
	domNode.setAttribute("value",password);
	// Add a click event handler
	$tw.utils.addEventListeners(domNode,[
		{name: "change", handlerObject: this, handlerMethod: "handleChangeEvent"}
	]);
	// Insert the label into the DOM and render any children
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	this.domNodes.push(domNode);
};

PasswordWidget.prototype.handleChangeEvent = function(event) {
	var password = this.domNodes[0].value;
	return $tw.utils.savePassword(this.passwordName,password);
};

/*
Compute the internal state of the widget
*/
PasswordWidget.prototype.execute = function() {
	// Get the parameters from the attributes
	this.passwordName = this.getAttribute("name","");
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
PasswordWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.name) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports.password = PasswordWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/qualify.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/qualify.js
type: application/javascript
module-type: widget

Qualify text to a variable 

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var QualifyWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
QualifyWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
QualifyWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
QualifyWidget.prototype.execute = function() {
	// Get our parameters
	this.qualifyName = this.getAttribute("name");
	this.qualifyTitle = this.getAttribute("title");
	// Set context variable
	if(this.qualifyName) {
		this.setVariable(this.qualifyName,this.qualifyTitle + "-" + this.getStateQualifier());
	}
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
QualifyWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.name || changedAttributes.title) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports.qualify = QualifyWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/radio.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/radio.js
type: application/javascript
module-type: widget

Set a field or index at a given tiddler via radio buttons

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var RadioWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
RadioWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
RadioWidget.prototype.render = function(parent,nextSibling) {
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	var isChecked = this.getValue() === this.radioValue;
	// Create our elements
	this.labelDomNode = this.document.createElement("label");
	this.labelDomNode.setAttribute("class",
   		"tc-radio " + this.radioClass + (isChecked ? " tc-radio-selected" : "")
  	);
	this.inputDomNode = this.document.createElement("input");
	this.inputDomNode.setAttribute("type","radio");
	if(isChecked) {
		this.inputDomNode.setAttribute("checked","true");
	}
	this.labelDomNode.appendChild(this.inputDomNode);
	this.spanDomNode = this.document.createElement("span");
	this.labelDomNode.appendChild(this.spanDomNode);
	// Add a click event handler
	$tw.utils.addEventListeners(this.inputDomNode,[
		{name: "change", handlerObject: this, handlerMethod: "handleChangeEvent"}
	]);
	// Insert the label into the DOM and render any children
	parent.insertBefore(this.labelDomNode,nextSibling);
	this.renderChildren(this.spanDomNode,null);
	this.domNodes.push(this.labelDomNode);
};

RadioWidget.prototype.getValue = function() {
	var value,
		tiddler = this.wiki.getTiddler(this.radioTitle);
	if (this.radioIndex) {
		value = this.wiki.extractTiddlerDataItem(this.radioTitle,this.radioIndex);
	} else {
		value = tiddler && tiddler.getFieldString(this.radioField);
	}
	return value;
};

RadioWidget.prototype.setValue = function() {
	if(this.radioIndex) {
		this.wiki.setText(this.radioTitle,"",this.radioIndex,this.radioValue);
	} else {
		var tiddler = this.wiki.getTiddler(this.radioTitle),
			addition = {};
		addition[this.radioField] = this.radioValue;
		this.wiki.addTiddler(new $tw.Tiddler(this.wiki.getCreationFields(),{title: this.radioTitle},tiddler,addition,this.wiki.getModificationFields()));
	}
};

RadioWidget.prototype.handleChangeEvent = function(event) {
	if(this.inputDomNode.checked) {
		this.setValue();
	}
};

/*
Compute the internal state of the widget
*/
RadioWidget.prototype.execute = function() {
	// Get the parameters from the attributes
	this.radioTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.radioField = this.getAttribute("field","text");
	this.radioIndex = this.getAttribute("index");
	this.radioValue = this.getAttribute("value");
	this.radioClass = this.getAttribute("class","");
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
RadioWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes.value || changedAttributes["class"]) {
		this.refreshSelf();
		return true;
	} else {
		var refreshed = false;
		if(changedTiddlers[this.radioTitle]) {
			this.inputDomNode.checked = this.getValue() === this.radioValue;
			refreshed = true;
		}
		return this.refreshChildren(changedTiddlers) || refreshed;
	}
};

exports.radio = RadioWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/range.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/range.js
type: application/javascript
module-type: widget

Range widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var RangeWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
RangeWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
RangeWidget.prototype.render = function(parent,nextSibling) {
	// Save the parent dom node
	this.parentDomNode = parent;
	// Compute our attributes
	this.computeAttributes();
	// Execute our logic
	this.execute();
	// Create our elements
	this.inputDomNode = this.document.createElement("input");
	this.inputDomNode.setAttribute("type","range");
	this.inputDomNode.setAttribute("class",this.elementClass);
	if(this.minValue){
		this.inputDomNode.setAttribute("min", this.minValue);
	}
	if(this.maxValue){
		this.inputDomNode.setAttribute("max", this.maxValue);
	}
	if(this.increment){
		this.inputDomNode.setAttribute("step", this.increment);
	}
	this.inputDomNode.value = this.getValue();


	// Add a click event handler
	$tw.utils.addEventListeners(this.inputDomNode,[
		{name: "input", handlerObject: this, handlerMethod: "handleChangeEvent"}
	]);
	// Insert the label into the DOM and render any children
	parent.insertBefore(this.inputDomNode,nextSibling);
	this.domNodes.push(this.inputDomNode);
};

RangeWidget.prototype.getValue = function() {
	var tiddler = this.wiki.getTiddler(this.tiddlerTitle),
		value   = this.defaultValue;
	if(tiddler) {
		if($tw.utils.hop(tiddler.fields,this.tiddlerField)) {
			value = tiddler.fields[this.tiddlerField] || "";
		} else {
			value = this.defaultValue || "";
		}
	}
	return value;
};

RangeWidget.prototype.handleChangeEvent = function(event) {
	this.wiki.setText(this.tiddlerTitle ,this.tiddlerField, null,this.inputDomNode.value);
};

/*
Compute the internal state of the widget
*/
RangeWidget.prototype.execute = function() {
	// Get the parameters from the attributes
	this.tiddlerTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.tiddlerField = this.getAttribute("field");
	this.minValue = this.getAttribute("min");
	this.maxValue = this.getAttribute("max");
	this.increment = this.getAttribute("increment");
	this.defaultValue = this.getAttribute("default");
	this.elementClass = this.getAttribute("class","");
	// Make the child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
RangeWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes['min'] || changedAttributes['max'] || changedAttributes['increment'] || changedAttributes["default"] || changedAttributes["class"]) {
		this.refreshSelf();
		return true;
	} else {
		var refreshed = false;
		if(changedTiddlers[this.tiddlerTitle]) {
			this.inputDomNode.checked = this.getValue();
			refreshed = true;
		}
		return this.refreshChildren(changedTiddlers) || refreshed;
	}
};

exports.range = RangeWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/raw.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/raw.js
type: application/javascript
module-type: widget

Raw widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var RawWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
RawWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
RawWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.execute();
	var div = this.document.createElement("div");
	div.innerHTML=this.parseTreeNode.html;
	parent.insertBefore(div,nextSibling);
	this.domNodes.push(div);	
};

/*
Compute the internal state of the widget
*/
RawWidget.prototype.execute = function() {
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
RawWidget.prototype.refresh = function(changedTiddlers) {
	return false;
};

exports.raw = RawWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/reveal.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/reveal.js
type: application/javascript
module-type: widget

Reveal widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var RevealWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
RevealWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
RevealWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var tag = this.parseTreeNode.isBlock ? "div" : "span";
	if(this.revealTag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {
		tag = this.revealTag;
	}
	var domNode = this.document.createElement(tag);
	var classes = this["class"].split(" ") || [];
	classes.push("tc-reveal");
	domNode.className = classes.join(" ");
	if(this.style) {
		domNode.setAttribute("style",this.style);
	}
	parent.insertBefore(domNode,nextSibling);
	this.renderChildren(domNode,null);
	if(!domNode.isTiddlyWikiFakeDom && this.type === "popup" && this.isOpen) {
		this.positionPopup(domNode);
		$tw.utils.addClass(domNode,"tc-popup"); // Make sure that clicks don't dismiss popups within the revealed content
	}
	if(!this.isOpen) {
		domNode.setAttribute("hidden","true");
	}
	this.domNodes.push(domNode);
};

RevealWidget.prototype.positionPopup = function(domNode) {
	domNode.style.position = "absolute";
	domNode.style.zIndex = "1000";
	var left,top;
	switch(this.position) {
		case "left":
			left = this.popup.left - domNode.offsetWidth;
			top = this.popup.top;
			break;
		case "above":
			left = this.popup.left;
			top = this.popup.top - domNode.offsetHeight;
			break;
		case "aboveright":
			left = this.popup.left + this.popup.width;
			top = this.popup.top + this.popup.height - domNode.offsetHeight;
			break;
		case "right":
			left = this.popup.left + this.popup.width;
			top = this.popup.top;
			break;
		case "belowleft":
			left = this.popup.left + this.popup.width - domNode.offsetWidth;
			top = this.popup.top + this.popup.height;
			break;
		default: // Below
			left = this.popup.left;
			top = this.popup.top + this.popup.height;
			break;
	}
	if(!this.positionAllowNegative) {
		left = Math.max(0,left);
		top = Math.max(0,top);
	}
	domNode.style.left = left + "px";
	domNode.style.top = top + "px";
};

/*
Compute the internal state of the widget
*/
RevealWidget.prototype.execute = function() {
	// Get our parameters
	this.state = this.getAttribute("state");
	this.revealTag = this.getAttribute("tag");
	this.type = this.getAttribute("type");
	this.text = this.getAttribute("text");
	this.position = this.getAttribute("position");
	this.positionAllowNegative = this.getAttribute("positionAllowNegative") === "yes";
	this["class"] = this.getAttribute("class","");
	this.style = this.getAttribute("style","");
	this["default"] = this.getAttribute("default","");
	this.animate = this.getAttribute("animate","no");
	this.retain = this.getAttribute("retain","no");
	this.openAnimation = this.animate === "no" ? undefined : "open";
	this.closeAnimation = this.animate === "no" ? undefined : "close";
	// Compute the title of the state tiddler and read it
	this.stateTiddlerTitle = this.state;
	this.stateTitle = this.getAttribute("stateTitle");
	this.stateField = this.getAttribute("stateField");
	this.stateIndex = this.getAttribute("stateIndex");
	this.readState();
	// Construct the child widgets
	var childNodes = this.isOpen ? this.parseTreeNode.children : [];
	this.hasChildNodes = this.isOpen;
	this.makeChildWidgets(childNodes);
};

/*
Read the state tiddler
*/
RevealWidget.prototype.readState = function() {
	// Read the information from the state tiddler
	var state,
	    defaultState = this["default"];
	if(this.stateTitle) {
		var stateTitleTiddler = this.wiki.getTiddler(this.stateTitle);
		if(this.stateField) {
			state = stateTitleTiddler ? stateTitleTiddler.getFieldString(this.stateField) || defaultState : defaultState;
		} else if(this.stateIndex) {
			state = stateTitleTiddler ? this.wiki.extractTiddlerDataItem(this.stateTitle,this.stateIndex) || defaultState : defaultState;
		} else if(stateTitleTiddler) {
			state = this.wiki.getTiddlerText(this.stateTitle) || defaultState;
		} else {
			state = defaultState;
		}
	} else {
		state = this.stateTiddlerTitle ? this.wiki.getTextReference(this.state,this["default"],this.getVariable("currentTiddler")) : this["default"];
	}
	if(state === null) {
		state = this["default"];
	}
	switch(this.type) {
		case "popup":
			this.readPopupState(state);
			break;
		case "match":
			this.isOpen = this.text === state;
			break;
		case "nomatch":
			this.isOpen = this.text !== state;
			break;
		case "lt":
			this.isOpen = !!(this.compareStateText(state) < 0);
			break;
		case "gt":
			this.isOpen = !!(this.compareStateText(state) > 0);
			break;
		case "lteq":
			this.isOpen = !(this.compareStateText(state) > 0);
			break;
		case "gteq":
			this.isOpen = !(this.compareStateText(state) < 0);
			break;
	}
};

RevealWidget.prototype.compareStateText = function(state) {
	return state.localeCompare(this.text,undefined,{numeric: true,sensitivity: "case"});
};

RevealWidget.prototype.readPopupState = function(state) {
	var popupLocationRegExp = /^\((-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+)\)$/,
		match = popupLocationRegExp.exec(state);
	// Check if the state matches the location regexp
	if(match) {
		// If so, we're open
		this.isOpen = true;
		// Get the location
		this.popup = {
			left: parseFloat(match[1]),
			top: parseFloat(match[2]),
			width: parseFloat(match[3]),
			height: parseFloat(match[4])
		};
	} else {
		// If not, we're closed
		this.isOpen = false;
	}
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
RevealWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.state || changedAttributes.type || changedAttributes.text || changedAttributes.position || changedAttributes.positionAllowNegative || changedAttributes["default"] || changedAttributes.animate || changedAttributes.stateTitle || changedAttributes.stateField || changedAttributes.stateIndex) {
		this.refreshSelf();
		return true;
	} else {
		var currentlyOpen = this.isOpen;
		this.readState();
		if(this.isOpen !== currentlyOpen) {
			if(this.retain === "yes") {
				this.updateState();
			} else {
				this.refreshSelf();
				return true;
			}
		}
		return this.refreshChildren(changedTiddlers);
	}
};

/*
Called by refresh() to dynamically show or hide the content
*/
RevealWidget.prototype.updateState = function() {
	var self = this;
	// Read the current state
	this.readState();
	// Construct the child nodes if needed
	var domNode = this.domNodes[0];
	if(this.isOpen && !this.hasChildNodes) {
		this.hasChildNodes = true;
		this.makeChildWidgets(this.parseTreeNode.children);
		this.renderChildren(domNode,null);
	}
	// Animate our DOM node
	if(!domNode.isTiddlyWikiFakeDom && this.type === "popup" && this.isOpen) {
		this.positionPopup(domNode);
		$tw.utils.addClass(domNode,"tc-popup"); // Make sure that clicks don't dismiss popups within the revealed content

	}
	if(this.isOpen) {
		domNode.removeAttribute("hidden");
        $tw.anim.perform(this.openAnimation,domNode);
	} else {
		$tw.anim.perform(this.closeAnimation,domNode,{callback: function() {
			//make sure that the state hasn't changed during the close animation
			self.readState()
			if(!self.isOpen) {
				domNode.setAttribute("hidden","true");
			}
		}});
	}
};

exports.reveal = RevealWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/scrollable.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/scrollable.js
type: application/javascript
module-type: widget

Scrollable widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ScrollableWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
	this.scaleFactor = 1;
	this.addEventListeners([
		{type: "tm-scroll", handler: "handleScrollEvent"}
	]);
	if($tw.browser) {
		this.requestAnimationFrame = window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 1000/60);
			};
		this.cancelAnimationFrame = window.cancelAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.webkitCancelRequestAnimationFrame ||
			window.mozCancelAnimationFrame ||
			window.mozCancelRequestAnimationFrame ||
			function(id) {
				window.clearTimeout(id);
			};
	}
};

/*
Inherit from the base widget class
*/
ScrollableWidget.prototype = new Widget();

ScrollableWidget.prototype.cancelScroll = function() {
	if(this.idRequestFrame) {
		this.cancelAnimationFrame.call(window,this.idRequestFrame);
		this.idRequestFrame = null;
	}
};

/*
Handle a scroll event
*/
ScrollableWidget.prototype.handleScrollEvent = function(event) {
	// Pass the scroll event through if our offsetsize is larger than our scrollsize
	if(this.outerDomNode.scrollWidth <= this.outerDomNode.offsetWidth && this.outerDomNode.scrollHeight <= this.outerDomNode.offsetHeight && this.fallthrough === "yes") {
		return true;
	}
	this.scrollIntoView(event.target);
	return false; // Handled event
};

/*
Scroll an element into view
*/
ScrollableWidget.prototype.scrollIntoView = function(element) {
	var duration = $tw.utils.getAnimationDuration();
	this.cancelScroll();
	this.startTime = Date.now();
	var scrollPosition = {
		x: this.outerDomNode.scrollLeft,
		y: this.outerDomNode.scrollTop
	};
	// Get the client bounds of the element and adjust by the scroll position
	var scrollableBounds = this.outerDomNode.getBoundingClientRect(),
		clientTargetBounds = element.getBoundingClientRect(),
		bounds = {
			left: clientTargetBounds.left + scrollPosition.x - scrollableBounds.left,
			top: clientTargetBounds.top + scrollPosition.y - scrollableBounds.top,
			width: clientTargetBounds.width,
			height: clientTargetBounds.height
		};
	// We'll consider the horizontal and vertical scroll directions separately via this function
	var getEndPos = function(targetPos,targetSize,currentPos,currentSize) {
			// If the target is already visible then stay where we are
			if(targetPos >= currentPos && (targetPos + targetSize) <= (currentPos + currentSize)) {
				return currentPos;
			// If the target is above/left of the current view, then scroll to its top/left
			} else if(targetPos <= currentPos) {
				return targetPos;
			// If the target is smaller than the window and the scroll position is too far up, then scroll till the target is at the bottom of the window
			} else if(targetSize < currentSize && currentPos < (targetPos + targetSize - currentSize)) {
				return targetPos + targetSize - currentSize;
			// If the target is big, then just scroll to the top
			} else if(currentPos < targetPos) {
				return targetPos;
			// Otherwise, stay where we are
			} else {
				return currentPos;
			}
		},
		endX = getEndPos(bounds.left,bounds.width,scrollPosition.x,this.outerDomNode.offsetWidth),
		endY = getEndPos(bounds.top,bounds.height,scrollPosition.y,this.outerDomNode.offsetHeight);
	// Only scroll if necessary
	if(endX !== scrollPosition.x || endY !== scrollPosition.y) {
		var self = this,
			drawFrame;
		drawFrame = function () {
			var t;
			if(duration <= 0) {
				t = 1;
			} else {
				t = ((Date.now()) - self.startTime) / duration;	
			}
			if(t >= 1) {
				self.cancelScroll();
				t = 1;
			}
			t = $tw.utils.slowInSlowOut(t);
			self.outerDomNode.scrollLeft = scrollPosition.x + (endX - scrollPosition.x) * t;
			self.outerDomNode.scrollTop = scrollPosition.y + (endY - scrollPosition.y) * t;
			if(t < 1) {
				self.idRequestFrame = self.requestAnimationFrame.call(window,drawFrame);
			}
		};
		drawFrame();
	}
};

/*
Render this widget into the DOM
*/
ScrollableWidget.prototype.render = function(parent,nextSibling) {
	var self = this;
	// Remember parent
	this.parentDomNode = parent;
	// Compute attributes and execute state
	this.computeAttributes();
	this.execute();
	// Create elements
	this.outerDomNode = this.document.createElement("div");
	$tw.utils.setStyle(this.outerDomNode,[
		{overflowY: "auto"},
		{overflowX: "auto"},
		{webkitOverflowScrolling: "touch"}
	]);
	this.innerDomNode = this.document.createElement("div");
	this.outerDomNode.appendChild(this.innerDomNode);
	// Assign classes
	this.outerDomNode.className = this["class"] || "";
	// Insert element
	parent.insertBefore(this.outerDomNode,nextSibling);
	this.renderChildren(this.innerDomNode,null);
	this.domNodes.push(this.outerDomNode);
};

/*
Compute the internal state of the widget
*/
ScrollableWidget.prototype.execute = function() {
	// Get attributes
	this.fallthrough = this.getAttribute("fallthrough","yes");
	this["class"] = this.getAttribute("class");
	// Make child widgets
	this.makeChildWidgets();
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ScrollableWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes["class"]) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports.scrollable = ScrollableWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/select.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/select.js
type: application/javascript
module-type: widget

Select widget:

```
<$select tiddler="MyTiddler" field="text">
<$list filter="[tag[chapter]]">
<option value=<<currentTiddler>>>
<$view field="description"/>
</option>
</$list>
</$select>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var SelectWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
SelectWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
SelectWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
	this.setSelectValue();
	$tw.utils.addEventListeners(this.getSelectDomNode(),[
		{name: "change", handlerObject: this, handlerMethod: "handleChangeEvent"}
	]);
};

/*
Handle a change event
*/
SelectWidget.prototype.handleChangeEvent = function(event) {
	// Get the new value and assign it to the tiddler
	if(this.selectMultiple == false) {
		var value = this.getSelectDomNode().value;
	} else {
		var value = this.getSelectValues()
				value = $tw.utils.stringifyList(value);
	}
	this.wiki.setText(this.selectTitle,this.selectField,this.selectIndex,value);
	// Trigger actions
	if(this.selectActions) {
		this.invokeActionString(this.selectActions,this,event);
	}
};

/*
If necessary, set the value of the select element to the current value
*/
SelectWidget.prototype.setSelectValue = function() {
	var value = this.selectDefault;
	// Get the value
	if(this.selectIndex) {
		value = this.wiki.extractTiddlerDataItem(this.selectTitle,this.selectIndex,value);
	} else {
		var tiddler = this.wiki.getTiddler(this.selectTitle);
		if(tiddler) {
			if(this.selectField === "text") {
				// Calling getTiddlerText() triggers lazy loading of skinny tiddlers
				value = this.wiki.getTiddlerText(this.selectTitle);
			} else {
				if($tw.utils.hop(tiddler.fields,this.selectField)) {
					value = tiddler.getFieldString(this.selectField);
				}
			}
		} else {
			if(this.selectField === "title") {
				value = this.selectTitle;
			}
		}
	}
	// Assign it to the select element if it's different than the current value
	if (this.selectMultiple) {
		value = value === undefined ? "" : value;
		var select = this.getSelectDomNode();
		var values = Array.isArray(value) ? value : $tw.utils.parseStringArray(value);
		for(var i=0; i < select.children.length; i++){
			if(values.indexOf(select.children[i].value) != -1) {
				select.children[i].selected = true;
			}
		}
		
	} else {
		var domNode = this.getSelectDomNode();
		if(domNode.value !== value) {
			domNode.value = value;
		}
	}
};

/*
Get the DOM node of the select element
*/
SelectWidget.prototype.getSelectDomNode = function() {
	return this.children[0].domNodes[0];
};

// Return an array of the selected opion values
// select is an HTML select element
SelectWidget.prototype.getSelectValues = function() {
	var select, result, options, opt;
	select = this.getSelectDomNode();
	result = [];
	options = select && select.options;
	for (var i=0; i<options.length; i++) {
		opt = options[i];
		if (opt.selected) {
			result.push(opt.value || opt.text);
		}
	}
	return result;
}

/*
Compute the internal state of the widget
*/
SelectWidget.prototype.execute = function() {
	// Get our parameters
	this.selectActions = this.getAttribute("actions");
	this.selectTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.selectField = this.getAttribute("field","text");
	this.selectIndex = this.getAttribute("index");
	this.selectClass = this.getAttribute("class");
	this.selectDefault = this.getAttribute("default");
	this.selectMultiple = this.getAttribute("multiple", false);
	this.selectSize = this.getAttribute("size");
	this.selectTooltip = this.getAttribute("tooltip");
	// Make the child widgets
	var selectNode = {
		type: "element",
		tag: "select",
		children: this.parseTreeNode.children
	};
	if(this.selectClass) {
		$tw.utils.addAttributeToParseTreeNode(selectNode,"class",this.selectClass);
	}
	if(this.selectMultiple) {
		$tw.utils.addAttributeToParseTreeNode(selectNode,"multiple","multiple");
	}
	if(this.selectSize) {
		$tw.utils.addAttributeToParseTreeNode(selectNode,"size",this.selectSize);
	}
	if(this.selectTooltip) {
		$tw.utils.addAttributeToParseTreeNode(selectNode,"title",this.selectTooltip);
	}
	this.makeChildWidgets([selectNode]);
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
SelectWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	// If we're using a different tiddler/field/index then completely refresh ourselves
	if(changedAttributes.selectTitle || changedAttributes.selectField || changedAttributes.selectIndex || changedAttributes.selectTooltip) {
		this.refreshSelf();
		return true;
	// If the target tiddler value has changed, just update setting and refresh the children
	} else {
		var childrenRefreshed = this.refreshChildren(changedTiddlers);
		if(changedTiddlers[this.selectTitle] || childrenRefreshed) {
			this.setSelectValue();
		} 
		return childrenRefreshed;
	}
};

exports.select = SelectWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/set.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/set.js
type: application/javascript
module-type: widget

Set variable widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var SetWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
SetWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
SetWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
SetWidget.prototype.execute = function() {
	// Get our parameters
	this.setName = this.getAttribute("name","currentTiddler");
	this.setFilter = this.getAttribute("filter");
	this.setSelect = this.getAttribute("select");
	this.setTiddler = this.getAttribute("tiddler");
	this.setSubTiddler = this.getAttribute("subtiddler");
	this.setField = this.getAttribute("field");
	this.setIndex = this.getAttribute("index");
	this.setValue = this.getAttribute("value");
	this.setEmptyValue = this.getAttribute("emptyValue");
	// Set context variable
	this.setVariable(this.setName,this.getValue(),this.parseTreeNode.params,!!this.parseTreeNode.isMacroDefinition);
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Get the value to be assigned
*/
SetWidget.prototype.getValue = function() {
	var value = this.setValue;
	if(this.setTiddler) {
		var tiddler;
		if(this.setSubTiddler) {
			tiddler = this.wiki.getSubTiddler(this.setTiddler,this.setSubTiddler);
		} else {
			tiddler = this.wiki.getTiddler(this.setTiddler);			
		}
		if(!tiddler) {
			value = this.setEmptyValue;
		} else if(this.setField) {
			value = tiddler.getFieldString(this.setField) || this.setEmptyValue;
		} else if(this.setIndex) {
			value = this.wiki.extractTiddlerDataItem(this.setTiddler,this.setIndex,this.setEmptyValue);
		} else {
			value = tiddler.fields.text || this.setEmptyValue ;
		}
	} else if(this.setFilter) {
		var results = this.wiki.filterTiddlers(this.setFilter,this);
		if(this.setValue == null) {
			var select;
			if(this.setSelect) {
				select = parseInt(this.setSelect,10);
			}
			if(select !== undefined) {
				value = results[select] || "";
			} else {
				value = $tw.utils.stringifyList(results);			
			}
		}
		if(results.length === 0 && this.setEmptyValue !== undefined) {
			value = this.setEmptyValue;
		}
	} else if(!value && this.setEmptyValue) {
		value = this.setEmptyValue;
	}
	return value || "";
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
SetWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.name || changedAttributes.filter || changedAttributes.select || changedAttributes.tiddler || (this.setTiddler && changedTiddlers[this.setTiddler]) || changedAttributes.field || changedAttributes.index || changedAttributes.value || changedAttributes.emptyValue ||
	   (this.setFilter && this.getValue() != this.variables[this.setName].value)) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);
	}
};

exports.setvariable = SetWidget;
exports.set = SetWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/text.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/text.js
type: application/javascript
module-type: widget

Text node widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var TextNodeWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
TextNodeWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
TextNodeWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	var text = this.getAttribute("text",this.parseTreeNode.text || "");
	text = text.replace(/\r/mg,"");
	var textNode = this.document.createTextNode(text);
	parent.insertBefore(textNode,nextSibling);
	this.domNodes.push(textNode);
};

/*
Compute the internal state of the widget
*/
TextNodeWidget.prototype.execute = function() {
	// Nothing to do for a text node
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
TextNodeWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.text) {
		this.refreshSelf();
		return true;
	} else {
		return false;	
	}
};

exports.text = TextNodeWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/tiddler.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/tiddler.js
type: application/javascript
module-type: widget

Tiddler widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var TiddlerWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
TiddlerWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
TiddlerWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
TiddlerWidget.prototype.execute = function() {
	this.tiddlerState = this.computeTiddlerState();
	this.setVariable("currentTiddler",this.tiddlerState.currentTiddler);
	this.setVariable("missingTiddlerClass",this.tiddlerState.missingTiddlerClass);
	this.setVariable("shadowTiddlerClass",this.tiddlerState.shadowTiddlerClass);
	this.setVariable("systemTiddlerClass",this.tiddlerState.systemTiddlerClass);
	this.setVariable("tiddlerTagClasses",this.tiddlerState.tiddlerTagClasses);
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Compute the tiddler state flags
*/
TiddlerWidget.prototype.computeTiddlerState = function() {
	// Get our parameters
	this.tiddlerTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	// Compute the state
	var state = {
		currentTiddler: this.tiddlerTitle || "",
		missingTiddlerClass: (this.wiki.tiddlerExists(this.tiddlerTitle) || this.wiki.isShadowTiddler(this.tiddlerTitle)) ? "tc-tiddler-exists" : "tc-tiddler-missing",
		shadowTiddlerClass: this.wiki.isShadowTiddler(this.tiddlerTitle) ? "tc-tiddler-shadow" : "",
		systemTiddlerClass: this.wiki.isSystemTiddler(this.tiddlerTitle) ? "tc-tiddler-system" : "",
		tiddlerTagClasses: this.getTagClasses()
	};
	// Compute a simple hash to make it easier to detect changes
	state.hash = state.currentTiddler + state.missingTiddlerClass + state.shadowTiddlerClass + state.systemTiddlerClass + state.tiddlerTagClasses;
	return state;
};

/*
Create a string of CSS classes derived from the tags of the current tiddler
*/
TiddlerWidget.prototype.getTagClasses = function() {
	var tiddler = this.wiki.getTiddler(this.tiddlerTitle);
	if(tiddler) {
		var tags = [];
		$tw.utils.each(tiddler.fields.tags,function(tag) {
			tags.push("tc-tagged-" + encodeURIComponent(tag));
		});
		return tags.join(" ");
	} else {
		return "";
	}
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
TiddlerWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes(),
		newTiddlerState = this.computeTiddlerState();
	if(changedAttributes.tiddler || newTiddlerState.hash !== this.tiddlerState.hash) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);		
	}
};

exports.tiddler = TiddlerWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/transclude.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/transclude.js
type: application/javascript
module-type: widget

Transclude widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var TranscludeWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
TranscludeWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
TranscludeWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
TranscludeWidget.prototype.execute = function() {
	// Get our parameters
	this.transcludeTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.transcludeSubTiddler = this.getAttribute("subtiddler");
	this.transcludeField = this.getAttribute("field");
	this.transcludeIndex = this.getAttribute("index");
	this.transcludeMode = this.getAttribute("mode");
	// Parse the text reference
	var parseAsInline = !this.parseTreeNode.isBlock;
	if(this.transcludeMode === "inline") {
		parseAsInline = true;
	} else if(this.transcludeMode === "block") {
		parseAsInline = false;
	}
	var parser = this.wiki.parseTextReference(
						this.transcludeTitle,
						this.transcludeField,
						this.transcludeIndex,
						{
							parseAsInline: parseAsInline,
							subTiddler: this.transcludeSubTiddler
						}),
		parseTreeNodes = parser ? parser.tree : this.parseTreeNode.children;
	// Set context variables for recursion detection
	var recursionMarker = this.makeRecursionMarker();
	this.setVariable("transclusion",recursionMarker);
	// Check for recursion
	if(parser) {
		if(this.parentWidget && this.parentWidget.hasVariable("transclusion",recursionMarker)) {
			parseTreeNodes = [{type: "element", tag: "span", attributes: {
				"class": {type: "string", value: "tc-error"}
			}, children: [
				{type: "text", text: $tw.language.getString("Error/RecursiveTransclusion")}
			]}];
		}
	}
	// Construct the child widgets
	this.makeChildWidgets(parseTreeNodes);
};

/*
Compose a string comprising the title, field and/or index to identify this transclusion for recursion detection
*/
TranscludeWidget.prototype.makeRecursionMarker = function() {
	var output = [];
	output.push("{");
	output.push(this.getVariable("currentTiddler",{defaultValue: ""}));
	output.push("|");
	output.push(this.transcludeTitle || "");
	output.push("|");
	output.push(this.transcludeField || "");
	output.push("|");
	output.push(this.transcludeIndex || "");
	output.push("|");
	output.push(this.transcludeSubTiddler || "");
	output.push("}");
	return output.join("");
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
TranscludeWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedTiddlers[this.transcludeTitle]) {
		this.refreshSelf();
		return true;
	} else {
		return this.refreshChildren(changedTiddlers);		
	}
};

exports.transclude = TranscludeWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/vars.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/vars.js
type: application/javascript
module-type: widget

This widget allows multiple variables to be set in one go:

```
\define helloworld() Hello world!
<$vars greeting="Hi" me={{!!title}} sentence=<<helloworld>>>
  <<greeting>>! I am <<me>> and I say: <<sentence>>
</$vars>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var VarsWidget = function(parseTreeNode,options) {
	// Call the constructor
	Widget.call(this);
	// Initialise	
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
VarsWidget.prototype = Object.create(Widget.prototype);

/*
Render this widget into the DOM
*/
VarsWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
VarsWidget.prototype.execute = function() {
	// Parse variables
	var self = this;
	$tw.utils.each(this.attributes,function(val,key) {
		if(key.charAt(0) !== "$") {
			self.setVariable(key,val);
		}
	});
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Refresh the widget by ensuring our attributes are up to date
*/
VarsWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(Object.keys(changedAttributes).length) {
		this.refreshSelf();
		return true;
	}
	return this.refreshChildren(changedTiddlers);
};

exports["vars"] = VarsWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/view.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/view.js
type: application/javascript
module-type: widget

View widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var ViewWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
ViewWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
ViewWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	if(this.text) {
		var textNode = this.document.createTextNode(this.text);
		parent.insertBefore(textNode,nextSibling);
		this.domNodes.push(textNode);
	} else {
		this.makeChildWidgets();
		this.renderChildren(parent,nextSibling);
	}
};

/*
Compute the internal state of the widget
*/
ViewWidget.prototype.execute = function() {
	// Get parameters from our attributes
	this.viewTitle = this.getAttribute("tiddler",this.getVariable("currentTiddler"));
	this.viewSubtiddler = this.getAttribute("subtiddler");
	this.viewField = this.getAttribute("field","text");
	this.viewIndex = this.getAttribute("index");
	this.viewFormat = this.getAttribute("format","text");
	this.viewTemplate = this.getAttribute("template","");
	this.viewMode = this.getAttribute("mode","block");
	switch(this.viewFormat) {
		case "htmlwikified":
			this.text = this.getValueAsHtmlWikified(this.viewMode);
			break;
		case "plainwikified":
			this.text = this.getValueAsPlainWikified(this.viewMode);
			break;
		case "htmlencodedplainwikified":
			this.text = this.getValueAsHtmlEncodedPlainWikified(this.viewMode);
			break;
		case "htmlencoded":
			this.text = this.getValueAsHtmlEncoded();
			break;
		case "urlencoded":
			this.text = this.getValueAsUrlEncoded();
			break;
		case "doubleurlencoded":
			this.text = this.getValueAsDoubleUrlEncoded();
			break;
		case "date":
			this.text = this.getValueAsDate(this.viewTemplate);
			break;
		case "relativedate":
			this.text = this.getValueAsRelativeDate();
			break;
		case "stripcomments":
			this.text = this.getValueAsStrippedComments();
			break;
		case "jsencoded":
			this.text = this.getValueAsJsEncoded();
			break;
		default: // "text"
			this.text = this.getValueAsText();
			break;
	}
};

/*
The various formatter functions are baked into this widget for the moment. Eventually they will be replaced by macro functions
*/

/*
Retrieve the value of the widget. Options are:
asString: Optionally return the value as a string
*/
ViewWidget.prototype.getValue = function(options) {
	options = options || {};
	var value = options.asString ? "" : undefined;
	if(this.viewIndex) {
		value = this.wiki.extractTiddlerDataItem(this.viewTitle,this.viewIndex);
	} else {
		var tiddler;
		if(this.viewSubtiddler) {
			tiddler = this.wiki.getSubTiddler(this.viewTitle,this.viewSubtiddler);	
		} else {
			tiddler = this.wiki.getTiddler(this.viewTitle);
		}
		if(tiddler) {
			if(this.viewField === "text" && !this.viewSubtiddler) {
				// Calling getTiddlerText() triggers lazy loading of skinny tiddlers
				value = this.wiki.getTiddlerText(this.viewTitle);
			} else {
				if($tw.utils.hop(tiddler.fields,this.viewField)) {
					if(options.asString) {
						value = tiddler.getFieldString(this.viewField);
					} else {
						value = tiddler.fields[this.viewField];				
					}
				}
			}
		} else {
			if(this.viewField === "title") {
				value = this.viewTitle;
			}
		}
	}
	return value;
};

ViewWidget.prototype.getValueAsText = function() {
	return this.getValue({asString: true});
};

ViewWidget.prototype.getValueAsHtmlWikified = function(mode) {
	return this.wiki.renderText("text/html","text/vnd.tiddlywiki",this.getValueAsText(),{
		parseAsInline: mode !== "block",
		parentWidget: this
	});
};

ViewWidget.prototype.getValueAsPlainWikified = function(mode) {
	return this.wiki.renderText("text/plain","text/vnd.tiddlywiki",this.getValueAsText(),{
		parseAsInline: mode !== "block",
		parentWidget: this
	});
};

ViewWidget.prototype.getValueAsHtmlEncodedPlainWikified = function(mode) {
	return $tw.utils.htmlEncode(this.wiki.renderText("text/plain","text/vnd.tiddlywiki",this.getValueAsText(),{
		parseAsInline: mode !== "block",
		parentWidget: this
	}));
};

ViewWidget.prototype.getValueAsHtmlEncoded = function() {
	return $tw.utils.htmlEncode(this.getValueAsText());
};

ViewWidget.prototype.getValueAsUrlEncoded = function() {
	return encodeURIComponent(this.getValueAsText());
};

ViewWidget.prototype.getValueAsDoubleUrlEncoded = function() {
	return encodeURIComponent(encodeURIComponent(this.getValueAsText()));
};

ViewWidget.prototype.getValueAsDate = function(format) {
	format = format || "YYYY MM DD 0hh:0mm";
	var value = $tw.utils.parseDate(this.getValue());
	if(value && $tw.utils.isDate(value) && value.toString() !== "Invalid Date") {
		return $tw.utils.formatDateString(value,format);
	} else {
		return "";
	}
};

ViewWidget.prototype.getValueAsRelativeDate = function(format) {
	var value = $tw.utils.parseDate(this.getValue());
	if(value && $tw.utils.isDate(value) && value.toString() !== "Invalid Date") {
		return $tw.utils.getRelativeDate((new Date()) - (new Date(value))).description;
	} else {
		return "";
	}
};

ViewWidget.prototype.getValueAsStrippedComments = function() {
	var lines = this.getValueAsText().split("\n"),
		out = [];
	for(var line=0; line<lines.length; line++) {
		var text = lines[line];
		if(!/^\s*\/\/#/.test(text)) {
			out.push(text);
		}
	}
	return out.join("\n");
};

ViewWidget.prototype.getValueAsJsEncoded = function() {
	return $tw.utils.stringify(this.getValueAsText());
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
ViewWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes.template || changedAttributes.format || changedTiddlers[this.viewTitle]) {
		this.refreshSelf();
		return true;
	} else {
		return false;	
	}
};

exports.view = ViewWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/widget.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/widget.js
type: application/javascript
module-type: widget

Widget base class

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Create a widget object for a parse tree node
	parseTreeNode: reference to the parse tree node to be rendered
	options: see below
Options include:
	wiki: mandatory reference to wiki associated with this render tree
	parentWidget: optional reference to a parent renderer node for the context chain
	document: optional document object to use instead of global document
*/
var Widget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Initialise widget properties. These steps are pulled out of the constructor so that we can reuse them in subclasses
*/
Widget.prototype.initialise = function(parseTreeNode,options) {
	// Bail if parseTreeNode is undefined, meaning  that the widget constructor was called without any arguments so that it can be subclassed
	if(parseTreeNode === undefined) {
		return;
	}
	options = options || {};
	// Save widget info
	this.parseTreeNode = parseTreeNode;
	this.wiki = options.wiki;
	this.parentWidget = options.parentWidget;
	this.variablesConstructor = function() {};
	this.variablesConstructor.prototype = this.parentWidget ? this.parentWidget.variables : {};
	this.variables = new this.variablesConstructor();
	this.document = options.document;
	this.attributes = {};
	this.children = [];
	this.domNodes = [];
	this.eventListeners = {};
	// Hashmap of the widget classes
	if(!this.widgetClasses) {
		// Get widget classes
		Widget.prototype.widgetClasses = $tw.modules.applyMethods("widget");
		// Process any subclasses
		$tw.modules.forEachModuleOfType("widget-subclass",function(title,module) {
			if(module.baseClass) {
				var baseClass = Widget.prototype.widgetClasses[module.baseClass];
				if(!baseClass) {
					throw "Module '" + title + "' is attemping to extend a non-existent base class '" + module.baseClass + "'";
				}
				var subClass = module.constructor;
				subClass.prototype = new baseClass();
				$tw.utils.extend(subClass.prototype,module.prototype);
				Widget.prototype.widgetClasses[module.name || module.baseClass] = subClass;
			}
		});
	}
};

/*
Render this widget into the DOM
*/
Widget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
Widget.prototype.execute = function() {
	this.makeChildWidgets();
};

/*
Set the value of a context variable
name: name of the variable
value: value of the variable
params: array of {name:, default:} for each parameter
isMacroDefinition: true if the variable is set via a \define macro pragma (and hence should have variable substitution performed)
*/
Widget.prototype.setVariable = function(name,value,params,isMacroDefinition) {
	this.variables[name] = {value: value, params: params, isMacroDefinition: !!isMacroDefinition};
};

/*
Get the prevailing value of a context variable
name: name of variable
options: see below
Options include
params: array of {name:, value:} for each parameter
defaultValue: default value if the variable is not defined

Returns an object with the following fields:

params: array of {name:,value:} of parameters passed to wikitext variables
text: text of variable, with parameters properly substituted
*/
Widget.prototype.getVariableInfo = function(name,options) {
	options = options || {};
	var actualParams = options.params || [],
		parentWidget = this.parentWidget;
	// Check for the variable defined in the parent widget (or an ancestor in the prototype chain)
	if(parentWidget && name in parentWidget.variables) {
		var variable = parentWidget.variables[name],
			value = variable.value,
			params = this.resolveVariableParameters(variable.params,actualParams);
		// Substitute any parameters specified in the definition
		$tw.utils.each(params,function(param) {
			value = $tw.utils.replaceString(value,new RegExp("\\$" + $tw.utils.escapeRegExp(param.name) + "\\$","mg"),param.value);
		});
		// Only substitute variable references if this variable was defined with the \define pragma
		if(variable.isMacroDefinition) {
			value = this.substituteVariableReferences(value);			
		}
		return {
			text: value,
			params: params
		};
	}
	// If the variable doesn't exist in the parent widget then look for a macro module
	return {
		text: this.evaluateMacroModule(name,actualParams,options.defaultValue)
	};
};

/*
Simplified version of getVariableInfo() that just returns the text
*/
Widget.prototype.getVariable = function(name,options) {
	return this.getVariableInfo(name,options).text;
};

Widget.prototype.resolveVariableParameters = function(formalParams,actualParams) {
	formalParams = formalParams || [];
	actualParams = actualParams || [];
	var nextAnonParameter = 0, // Next candidate anonymous parameter in macro call
		paramInfo, paramValue,
		results = [];
	// Step through each of the parameters in the macro definition
	for(var p=0; p<formalParams.length; p++) {
		// Check if we've got a macro call parameter with the same name
		paramInfo = formalParams[p];
		paramValue = undefined;
		for(var m=0; m<actualParams.length; m++) {
			if(actualParams[m].name === paramInfo.name) {
				paramValue = actualParams[m].value;
			}
		}
		// If not, use the next available anonymous macro call parameter
		while(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {
			nextAnonParameter++;
		}
		if(paramValue === undefined && nextAnonParameter < actualParams.length) {
			paramValue = actualParams[nextAnonParameter++].value;
		}
		// If we've still not got a value, use the default, if any
		paramValue = paramValue || paramInfo["default"] || "";
		// Store the parameter name and value
		results.push({name: paramInfo.name, value: paramValue});
	}
	return results;
};

Widget.prototype.substituteVariableReferences = function(text) {
	var self = this;
	return (text || "").replace(/\$\(([^\)\$]+)\)\$/g,function(match,p1,offset,string) {
		return self.getVariable(p1,{defaultValue: ""});
	});
};

Widget.prototype.evaluateMacroModule = function(name,actualParams,defaultValue) {
	if($tw.utils.hop($tw.macros,name)) {
		var macro = $tw.macros[name],
			args = [];
		if(macro.params.length > 0) {
			var nextAnonParameter = 0, // Next candidate anonymous parameter in macro call
				paramInfo, paramValue;
			// Step through each of the parameters in the macro definition
			for(var p=0; p<macro.params.length; p++) {
				// Check if we've got a macro call parameter with the same name
				paramInfo = macro.params[p];
				paramValue = undefined;
				for(var m=0; m<actualParams.length; m++) {
					if(actualParams[m].name === paramInfo.name) {
						paramValue = actualParams[m].value;
					}
				}
				// If not, use the next available anonymous macro call parameter
				while(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {
					nextAnonParameter++;
				}
				if(paramValue === undefined && nextAnonParameter < actualParams.length) {
					paramValue = actualParams[nextAnonParameter++].value;
				}
				// If we've still not got a value, use the default, if any
				paramValue = paramValue || paramInfo["default"] || "";
				// Save the parameter
				args.push(paramValue);
			}
		}
		else for(var i=0; i<actualParams.length; ++i) {
			args.push(actualParams[i].value);
		}
		return (macro.run.apply(this,args) || "").toString();
	} else {
		return defaultValue;
	}
};

/*
Check whether a given context variable value exists in the parent chain
*/
Widget.prototype.hasVariable = function(name,value) {
	var node = this;
	while(node) {
		if($tw.utils.hop(node.variables,name) && node.variables[name].value === value) {
			return true;
		}
		node = node.parentWidget;
	}
	return false;
};

/*
Construct a qualifying string based on a hash of concatenating the values of a given variable in the parent chain
*/
Widget.prototype.getStateQualifier = function(name) {
	this.qualifiers = this.qualifiers || Object.create(null);
	name = name || "transclusion";
	if(this.qualifiers[name]) {
		return this.qualifiers[name];
	} else {
		var output = [],
			node = this;
		while(node && node.parentWidget) {
			if($tw.utils.hop(node.parentWidget.variables,name)) {
				output.push(node.getVariable(name));
			}
			node = node.parentWidget;
		}
		var value = $tw.utils.hashString(output.join(""));
		this.qualifiers[name] = value;
		return value;
	}
};

/*
Compute the current values of the attributes of the widget. Returns a hashmap of the names of the attributes that have changed
*/
Widget.prototype.computeAttributes = function() {
	var changedAttributes = {},
		self = this,
		value;
	$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {
		if(attribute.type === "filtered") {
			value = self.wiki.filterTiddlers(attribute.filter,self)[0] || "";
		} else if(attribute.type === "indirect") {
			value = self.wiki.getTextReference(attribute.textReference,"",self.getVariable("currentTiddler"));
		} else if(attribute.type === "macro") {
			value = self.getVariable(attribute.value.name,{params: attribute.value.params});
		} else { // String attribute
			value = attribute.value;
		}
		// Check whether the attribute has changed
		if(self.attributes[name] !== value) {
			self.attributes[name] = value;
			changedAttributes[name] = true;
		}
	});
	return changedAttributes;
};

/*
Check for the presence of an attribute
*/
Widget.prototype.hasAttribute = function(name) {
	return $tw.utils.hop(this.attributes,name);
};

/*
Get the value of an attribute
*/
Widget.prototype.getAttribute = function(name,defaultText) {
	if($tw.utils.hop(this.attributes,name)) {
		return this.attributes[name];
	} else {
		return defaultText;
	}
};

/*
Assign the computed attributes of the widget to a domNode
options include:
excludeEventAttributes: ignores attributes whose name begins with "on"
*/
Widget.prototype.assignAttributes = function(domNode,options) {
	options = options || {};
	var self = this;
	$tw.utils.each(this.attributes,function(v,a) {
		// Check exclusions
		if(options.excludeEventAttributes && a.substr(0,2) === "on") {
			v = undefined;
		}
		if(v !== undefined) {
			var b = a.split(":");
			// Setting certain attributes can cause a DOM error (eg xmlns on the svg element)
			try {
				if (b.length == 2 && b[0] == "xlink"){
					domNode.setAttributeNS("http://www.w3.org/1999/xlink",b[1],v);
				} else {
					domNode.setAttributeNS(null,a,v);
				}
			} catch(e) {
			}
		}
	});
};

/*
Make child widgets correspondng to specified parseTreeNodes
*/
Widget.prototype.makeChildWidgets = function(parseTreeNodes) {
	this.children = [];
	var self = this;
	$tw.utils.each(parseTreeNodes || (this.parseTreeNode && this.parseTreeNode.children),function(childNode) {
		self.children.push(self.makeChildWidget(childNode));
	});
};

/*
Construct the widget object for a parse tree node
*/
Widget.prototype.makeChildWidget = function(parseTreeNode) {
	var WidgetClass = this.widgetClasses[parseTreeNode.type];
	if(!WidgetClass) {
		WidgetClass = this.widgetClasses.text;
		parseTreeNode = {type: "text", text: "Undefined widget '" + parseTreeNode.type + "'"};
	}
	return new WidgetClass(parseTreeNode,{
		wiki: this.wiki,
		variables: {},
		parentWidget: this,
		document: this.document
	});
};

/*
Get the next sibling of this widget
*/
Widget.prototype.nextSibling = function() {
	if(this.parentWidget) {
		var index = this.parentWidget.children.indexOf(this);
		if(index !== -1 && index < this.parentWidget.children.length-1) {
			return this.parentWidget.children[index+1];
		}
	}
	return null;
};

/*
Get the previous sibling of this widget
*/
Widget.prototype.previousSibling = function() {
	if(this.parentWidget) {
		var index = this.parentWidget.children.indexOf(this);
		if(index !== -1 && index > 0) {
			return this.parentWidget.children[index-1];
		}
	}
	return null;
};

/*
Render the children of this widget into the DOM
*/
Widget.prototype.renderChildren = function(parent,nextSibling) {
	var children = this.children;
	for(var i = 0; i < children.length; i++) {
		children[i].render(parent,nextSibling);
	};
};

/*
Add a list of event listeners from an array [{type:,handler:},...]
*/
Widget.prototype.addEventListeners = function(listeners) {
	var self = this;
	$tw.utils.each(listeners,function(listenerInfo) {
		self.addEventListener(listenerInfo.type,listenerInfo.handler);
	});
};

/*
Add an event listener
*/
Widget.prototype.addEventListener = function(type,handler) {
	var self = this;
	if(typeof handler === "string") { // The handler is a method name on this widget
		this.eventListeners[type] = function(event) {
			return self[handler].call(self,event);
		};
	} else { // The handler is a function
		this.eventListeners[type] = function(event) {
			return handler.call(self,event);
		};
	}
};

/*
Dispatch an event to a widget. If the widget doesn't handle the event then it is also dispatched to the parent widget
*/
Widget.prototype.dispatchEvent = function(event) {
	// Dispatch the event if this widget handles it
	var listener = this.eventListeners[event.type];
	if(listener) {
		// Don't propagate the event if the listener returned false
		if(!listener(event)) {
			return false;
		}
	}
	// Dispatch the event to the parent widget
	if(this.parentWidget) {
		return this.parentWidget.dispatchEvent(event);
	}
	return true;
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
Widget.prototype.refresh = function(changedTiddlers) {
	return this.refreshChildren(changedTiddlers);
};

/*
Rebuild a previously rendered widget
*/
Widget.prototype.refreshSelf = function() {
	var nextSibling = this.findNextSiblingDomNode();
	this.removeChildDomNodes();
	this.render(this.parentDomNode,nextSibling);
};

/*
Refresh all the children of a widget
*/
Widget.prototype.refreshChildren = function(changedTiddlers) {
	var children = this.children,
		refreshed = false;
	for (var i = 0; i < children.length; i++) {
		refreshed = children[i].refresh(changedTiddlers) || refreshed;
	}
	return refreshed;
};

/*
Find the next sibling in the DOM to this widget. This is done by scanning the widget tree through all next siblings and their descendents that share the same parent DOM node
*/
Widget.prototype.findNextSiblingDomNode = function(startIndex) {
	// Refer to this widget by its index within its parents children
	var parent = this.parentWidget,
		index = startIndex !== undefined ? startIndex : parent.children.indexOf(this);
if(index === -1) {
	throw "node not found in parents children";
}
	// Look for a DOM node in the later siblings
	while(++index < parent.children.length) {
		var domNode = parent.children[index].findFirstDomNode();
		if(domNode) {
			return domNode;
		}
	}
	// Go back and look for later siblings of our parent if it has the same parent dom node
	var grandParent = parent.parentWidget;
	if(grandParent && parent.parentDomNode === this.parentDomNode) {
		index = grandParent.children.indexOf(parent);
		if(index !== -1) {
			return parent.findNextSiblingDomNode(index);
		}
	}
	return null;
};

/*
Find the first DOM node generated by a widget or its children
*/
Widget.prototype.findFirstDomNode = function() {
	// Return the first dom node of this widget, if we've got one
	if(this.domNodes.length > 0) {
		return this.domNodes[0];
	}
	// Otherwise, recursively call our children
	for(var t=0; t<this.children.length; t++) {
		var domNode = this.children[t].findFirstDomNode();
		if(domNode) {
			return domNode;
		}
	}
	return null;
};

/*
Remove any DOM nodes created by this widget or its children
*/
Widget.prototype.removeChildDomNodes = function() {
	// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case
	if(this.domNodes.length > 0) {
		$tw.utils.each(this.domNodes,function(domNode) {
			domNode.parentNode.removeChild(domNode);
		});
		this.domNodes = [];
	} else {
		// Otherwise, ask the child widgets to delete their DOM nodes
		$tw.utils.each(this.children,function(childWidget) {
			childWidget.removeChildDomNodes();
		});
	}
};

/*
Invoke the action widgets that are descendents of the current widget.
*/
Widget.prototype.invokeActions = function(triggeringWidget,event) {
	var handled = false;
	// For each child widget
	for(var t=0; t<this.children.length; t++) {
		var child = this.children[t];
		// Invoke the child if it is an action widget
		if(child.invokeAction) {
			child.refreshSelf();
			if(child.invokeAction(triggeringWidget,event)) {
				handled = true;
			}
		}
		// Propagate through through the child if it permits it
		if(child.allowActionPropagation() && child.invokeActions(triggeringWidget,event)) {
			handled = true;
		}
	}
	return handled;
};

/*
Invoke the action widgets defined in a string
*/
Widget.prototype.invokeActionString = function(actions,triggeringWidget,event,variables) {
	actions = actions || "";
	var parser = this.wiki.parseText("text/vnd.tiddlywiki",actions,{
			parentWidget: this,
			document: this.document
		}),
		widgetNode = this.wiki.makeWidget(parser,{
			parentWidget: this,
			document: this.document,
			variables: variables
		});
	var container = this.document.createElement("div");
	widgetNode.render(container,null);
	return widgetNode.invokeActions(this,event);
};

Widget.prototype.allowActionPropagation = function() {
	return true;
};

exports.widget = Widget;

})();

;})();
return exports;
}));
_define("$:/core/modules/widgets/wikify.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/widgets/wikify.js
type: application/javascript
module-type: widget

Widget to wikify text into a variable

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Widget = require("$:/core/modules/widgets/widget.js").widget;

var WikifyWidget = function(parseTreeNode,options) {
	this.initialise(parseTreeNode,options);
};

/*
Inherit from the base widget class
*/
WikifyWidget.prototype = new Widget();

/*
Render this widget into the DOM
*/
WikifyWidget.prototype.render = function(parent,nextSibling) {
	this.parentDomNode = parent;
	this.computeAttributes();
	this.execute();
	this.renderChildren(parent,nextSibling);
};

/*
Compute the internal state of the widget
*/
WikifyWidget.prototype.execute = function() {
	// Get our parameters
	this.wikifyName = this.getAttribute("name");
	this.wikifyText = this.getAttribute("text");
	this.wikifyType = this.getAttribute("type");
	this.wikifyMode = this.getAttribute("mode","block");
	this.wikifyOutput = this.getAttribute("output","text");
	// Create the parse tree
	this.wikifyParser = this.wiki.parseText(this.wikifyType,this.wikifyText,{
			parseAsInline: this.wikifyMode === "inline"
		});
	// Create the widget tree 
	this.wikifyWidgetNode = this.wiki.makeWidget(this.wikifyParser,{
			document: $tw.fakeDocument,
			parentWidget: this
		});
	// Render the widget tree to the container
	this.wikifyContainer = $tw.fakeDocument.createElement("div");
	this.wikifyWidgetNode.render(this.wikifyContainer,null);
	this.wikifyResult = this.getResult();
	// Set context variable
	this.setVariable(this.wikifyName,this.wikifyResult);
	// Construct the child widgets
	this.makeChildWidgets();
};

/*
Return the result string
*/
WikifyWidget.prototype.getResult = function() {
	var result;
	switch(this.wikifyOutput) {
		case "text":
			result = this.wikifyContainer.textContent;
			break;
		case "formattedtext":
			result = this.wikifyContainer.formattedTextContent;
			break;
		case "html":
			result = this.wikifyContainer.innerHTML;
			break;
		case "parsetree":
			result = JSON.stringify(this.wikifyParser.tree,0,$tw.config.preferences.jsonSpaces);
			break;
		case "widgettree":
			result = JSON.stringify(this.getWidgetTree(),0,$tw.config.preferences.jsonSpaces);
			break;
	}
	return result;
};

/*
Return a string of the widget tree
*/
WikifyWidget.prototype.getWidgetTree = function() {
	var copyNode = function(widgetNode,resultNode) {
			var type = widgetNode.parseTreeNode.type;
			resultNode.type = type;
			switch(type) {
				case "element":
					resultNode.tag = widgetNode.parseTreeNode.tag;
					break;
				case "text":
					resultNode.text = widgetNode.parseTreeNode.text;
					break;	
			}
			if(Object.keys(widgetNode.attributes || {}).length > 0) {
				resultNode.attributes = {};
				$tw.utils.each(widgetNode.attributes,function(attr,attrName) {
					resultNode.attributes[attrName] = widgetNode.getAttribute(attrName);
				});
			}
			if(Object.keys(widgetNode.children || {}).length > 0) {
				resultNode.children = [];
				$tw.utils.each(widgetNode.children,function(widgetChildNode) {
					var node = {};
					resultNode.children.push(node);
					copyNode(widgetChildNode,node);
				});
			}
		},
		results = {};
	copyNode(this.wikifyWidgetNode,results);
	return results;
};

/*
Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
*/
WikifyWidget.prototype.refresh = function(changedTiddlers) {
	var changedAttributes = this.computeAttributes();
	// Refresh ourselves entirely if any of our attributes have changed
	if(changedAttributes.name || changedAttributes.text || changedAttributes.type || changedAttributes.mode || changedAttributes.output) {
		this.refreshSelf();
		return true;
	} else {
		// Refresh the widget tree
		if(this.wikifyWidgetNode.refresh(changedTiddlers)) {
			// Check if there was any change
			var result = this.getResult();
			if(result !== this.wikifyResult) {
				// If so, save the change
				this.wikifyResult = result;
				this.setVariable(this.wikifyName,this.wikifyResult);
				// Refresh each of our child widgets
				$tw.utils.each(this.children,function(childWidget) {
					childWidget.refreshSelf();
				});
				return true;
			}
		}
		// Just refresh the children
		return this.refreshChildren(changedTiddlers);
	}
};

exports.wikify = WikifyWidget;

})();

;})();
return exports;
}));
_define("$:/core/modules/wiki-bulkops.js","wikimethod",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/wiki-bulkops.js
type: application/javascript
module-type: wikimethod

Bulk tiddler operations such as rename.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Rename a tiddler, and relink any tags or lists that reference it.
*/
function renameTiddler(fromTitle,toTitle,options) {
	fromTitle = (fromTitle || "").trim();
	toTitle = (toTitle || "").trim();
	options = options || {};
	if(fromTitle && toTitle && fromTitle !== toTitle) {
		// Rename the tiddler itself
		var oldTiddler = this.getTiddler(fromTitle),
			newTiddler = new $tw.Tiddler(oldTiddler,{title: toTitle},this.getModificationFields());
		newTiddler = $tw.hooks.invokeHook("th-renaming-tiddler",newTiddler,oldTiddler);
		this.addTiddler(newTiddler);
		this.deleteTiddler(fromTitle);
		// Rename any tags or lists that reference it
		this.relinkTiddler(fromTitle,toTitle,options)
	}
}

/*
Relink any tags or lists that reference a given tiddler
*/
function relinkTiddler(fromTitle,toTitle,options) {
	var self = this;
	fromTitle = (fromTitle || "").trim();
	toTitle = (toTitle || "").trim();
	options = options || {};
	if(fromTitle && toTitle && fromTitle !== toTitle) {
		this.each(function(tiddler,title) {
			var type = tiddler.fields.type || "";
			// Don't touch plugins or JavaScript modules
			if(!tiddler.fields["plugin-type"] && type !== "application/javascript") {
				var tags = (tiddler.fields.tags || []).slice(0),
					list = (tiddler.fields.list || []).slice(0),
					isModified = false;
				if(!options.dontRenameInTags) {
					// Rename tags
					$tw.utils.each(tags,function (title,index) {
						if(title === fromTitle) {
console.log("Renaming tag '" + tags[index] + "' to '" + toTitle + "' of tiddler '" + tiddler.fields.title + "'");
							tags[index] = toTitle;
							isModified = true;
						}
					});
				}
				if(!options.dontRenameInLists) {
					// Rename lists
					$tw.utils.each(list,function (title,index) {
						if(title === fromTitle) {
console.log("Renaming list item '" + list[index] + "' to '" + toTitle + "' of tiddler '" + tiddler.fields.title + "'");
							list[index] = toTitle;
							isModified = true;
						}
					});
				}
				if(isModified) {
					var newTiddler = new $tw.Tiddler(tiddler,{tags: tags, list: list},self.getModificationFields())
					newTiddler = $tw.hooks.invokeHook("th-relinking-tiddler",newTiddler,tiddler);
					self.addTiddler(newTiddler);
				}
			}
		});
	}
};

exports.renameTiddler = renameTiddler;
exports.relinkTiddler = relinkTiddler;

})();

;})();
return exports;
}));
_define("$:/core/modules/wiki.js","wikimethod",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/core/modules/wiki.js
type: application/javascript
module-type: wikimethod

Extension methods for the $tw.Wiki object

Adds the following properties to the wiki object:

* `eventListeners` is a hashmap by type of arrays of listener functions
* `changedTiddlers` is a hashmap describing changes to named tiddlers since wiki change events were last dispatched. Each entry is a hashmap containing two fields:
	modified: true/false
	deleted: true/false
* `changeCount` is a hashmap by tiddler title containing a numerical index that starts at zero and is incremented each time a tiddler is created changed or deleted
* `caches` is a hashmap by tiddler title containing a further hashmap of named cache objects. Caches are automatically cleared when a tiddler is modified or deleted
* `globalCache` is a hashmap by cache name of cache objects that are cleared whenever any tiddler change occurs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var widget = require("$:/core/modules/widgets/widget.js");

var USER_NAME_TITLE = "$:/status/UserName",
	TIMESTAMP_DISABLE_TITLE = "$:/config/TimestampDisable";

/*
Add available indexers to this wiki
*/
exports.addIndexersToWiki = function() {
	var self = this;
	$tw.utils.each($tw.modules.applyMethods("indexer"),function(Indexer,name) {
		self.addIndexer(new Indexer(self),name);
	});
};

/*
Get the value of a text reference. Text references can have any of these forms:
	<tiddlertitle>
	<tiddlertitle>!!<fieldname>
	!!<fieldname> - specifies a field of the current tiddlers
	<tiddlertitle>##<index>
*/
exports.getTextReference = function(textRef,defaultText,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title = tr.title || currTiddlerTitle;
	if(tr.field) {
		var tiddler = this.getTiddler(title);
		if(tr.field === "title") { // Special case so we can return the title of a non-existent tiddler
			return title;
		} else if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {
			return tiddler.getFieldString(tr.field);
		} else {
			return defaultText;
		}
	} else if(tr.index) {
		return this.extractTiddlerDataItem(title,tr.index,defaultText);
	} else {
		return this.getTiddlerText(title,defaultText);
	}
};

exports.setTextReference = function(textRef,value,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title = tr.title || currTiddlerTitle;
	this.setText(title,tr.field,tr.index,value);
};

exports.setText = function(title,field,index,value,options) {
	options = options || {};
	var creationFields = options.suppressTimestamp ? {} : this.getCreationFields(),
		modificationFields = options.suppressTimestamp ? {} : this.getModificationFields();
	// Check if it is a reference to a tiddler field
	if(index) {
		var data = this.getTiddlerData(title,Object.create(null));
		if(value !== undefined) {
			data[index] = value;
		} else {
			delete data[index];
		}
		this.setTiddlerData(title,data,modificationFields);
	} else {
		var tiddler = this.getTiddler(title),
			fields = {title: title};
		fields[field || "text"] = value;
		this.addTiddler(new $tw.Tiddler(creationFields,tiddler,fields,modificationFields));
	}
};

exports.deleteTextReference = function(textRef,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title,tiddler,fields;
	// Check if it is a reference to a tiddler
	if(tr.title && !tr.field) {
		this.deleteTiddler(tr.title);
	// Else check for a field reference
	} else if(tr.field) {
		title = tr.title || currTiddlerTitle;
		tiddler = this.getTiddler(title);
		if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {
			fields = Object.create(null);
			fields[tr.field] = undefined;
			this.addTiddler(new $tw.Tiddler(tiddler,fields,this.getModificationFields()));
		}
	}
};

exports.addEventListener = function(type,listener) {
	this.eventListeners = this.eventListeners || {};
	this.eventListeners[type] = this.eventListeners[type]  || [];
	this.eventListeners[type].push(listener);	
};

exports.removeEventListener = function(type,listener) {
	var listeners = this.eventListeners[type];
	if(listeners) {
		var p = listeners.indexOf(listener);
		if(p !== -1) {
			listeners.splice(p,1);
		}
	}
};

exports.dispatchEvent = function(type /*, args */) {
	var args = Array.prototype.slice.call(arguments,1),
		listeners = this.eventListeners[type];
	if(listeners) {
		for(var p=0; p<listeners.length; p++) {
			var listener = listeners[p];
			listener.apply(listener,args);
		}
	}
};

/*
Causes a tiddler to be marked as changed, incrementing the change count, and triggers event handlers.
This method should be called after the changes it describes have been made to the wiki.tiddlers[] array.
	title: Title of tiddler
	isDeleted: defaults to false (meaning the tiddler has been created or modified),
		true if the tiddler has been deleted
*/
exports.enqueueTiddlerEvent = function(title,isDeleted) {
	// Record the touch in the list of changed tiddlers
	this.changedTiddlers = this.changedTiddlers || Object.create(null);
	this.changedTiddlers[title] = this.changedTiddlers[title] || Object.create(null);
	this.changedTiddlers[title][isDeleted ? "deleted" : "modified"] = true;
	// Increment the change count
	this.changeCount = this.changeCount || Object.create(null);
	if($tw.utils.hop(this.changeCount,title)) {
		this.changeCount[title]++;
	} else {
		this.changeCount[title] = 1;
	}
	// Trigger events
	this.eventListeners = this.eventListeners || {};
	if(!this.eventsTriggered) {
		var self = this;
		$tw.utils.nextTick(function() {
			var changes = self.changedTiddlers;
			self.changedTiddlers = Object.create(null);
			self.eventsTriggered = false;
			if($tw.utils.count(changes) > 0) {
				self.dispatchEvent("change",changes);
			}
		});
		this.eventsTriggered = true;
	}
};

exports.getSizeOfTiddlerEventQueue = function() {
	return $tw.utils.count(this.changedTiddlers);
};

exports.clearTiddlerEventQueue = function() {
	this.changedTiddlers = Object.create(null);
	this.changeCount = Object.create(null);
};

exports.getChangeCount = function(title) {
	this.changeCount = this.changeCount || Object.create(null);
	if($tw.utils.hop(this.changeCount,title)) {
		return this.changeCount[title];
	} else {
		return 0;
	}
};

/*
Generate an unused title from the specified base
*/
exports.generateNewTitle = function(baseTitle,options) {
	options = options || {};
	var c = 0,
		title = baseTitle;
	while(this.tiddlerExists(title) || this.isShadowTiddler(title) || this.findDraft(title)) {
		title = baseTitle + 
			(options.prefix || " ") + 
			(++c);
	}
	return title;
};

exports.isSystemTiddler = function(title) {
	return title && title.indexOf("$:/") === 0;
};

exports.isTemporaryTiddler = function(title) {
	return title && title.indexOf("$:/temp/") === 0;
};

exports.isImageTiddler = function(title) {
	var tiddler = this.getTiddler(title);
	if(tiddler) {		
		var contentTypeInfo = $tw.config.contentTypeInfo[tiddler.fields.type || "text/vnd.tiddlywiki"];
		return !!contentTypeInfo && contentTypeInfo.flags.indexOf("image") !== -1;
	} else {
		return null;
	}
};

/*
Like addTiddler() except it will silently reject any plugin tiddlers that are older than the currently loaded version. Returns true if the tiddler was imported
*/
exports.importTiddler = function(tiddler) {
	var existingTiddler = this.getTiddler(tiddler.fields.title);
	// Check if we're dealing with a plugin
	if(tiddler && tiddler.hasField("plugin-type") && tiddler.hasField("version") && existingTiddler && existingTiddler.hasField("plugin-type") && existingTiddler.hasField("version")) {
		// Reject the incoming plugin if it is older
		if(!$tw.utils.checkVersions(tiddler.fields.version,existingTiddler.fields.version)) {
			return false;
		}
	}
	// Fall through to adding the tiddler
	this.addTiddler(tiddler);
	return true;
};

/*
Return a hashmap of the fields that should be set when a tiddler is created
*/
exports.getCreationFields = function() {
	if(this.getTiddlerText(TIMESTAMP_DISABLE_TITLE,"").toLowerCase() !== "yes") {
		var fields = {
				created: new Date()
			},
			creator = this.getTiddlerText(USER_NAME_TITLE);
		if(creator) {
			fields.creator = creator;
		}
		return fields;
	} else {
		return {};
	}
};

/*
Return a hashmap of the fields that should be set when a tiddler is modified
*/
exports.getModificationFields = function() {
	if(this.getTiddlerText(TIMESTAMP_DISABLE_TITLE,"").toLowerCase() !== "yes") {
		var fields = Object.create(null),
			modifier = this.getTiddlerText(USER_NAME_TITLE);
		fields.modified = new Date();
		if(modifier) {
			fields.modifier = modifier;
		}
		return fields;
	} else {
		return {};
	}
};

/*
Return a sorted array of tiddler titles.  Options include:
sortField: field to sort by
excludeTag: tag to exclude
includeSystem: whether to include system tiddlers (defaults to false)
*/
exports.getTiddlers = function(options) {
	options = options || Object.create(null);
	var self = this,
		sortField = options.sortField || "title",
		tiddlers = [], t, titles = [];
	this.each(function(tiddler,title) {
		if(options.includeSystem || !self.isSystemTiddler(title)) {
			if(!options.excludeTag || !tiddler.hasTag(options.excludeTag)) {
				tiddlers.push(tiddler);
			}
		}
	});
	tiddlers.sort(function(a,b) {
		var aa = a.fields[sortField].toLowerCase() || "",
			bb = b.fields[sortField].toLowerCase() || "";
		if(aa < bb) {
			return -1;
		} else {
			if(aa > bb) {
				return 1;
			} else {
				return 0;
			}
		}
	});
	for(t=0; t<tiddlers.length; t++) {
		titles.push(tiddlers[t].fields.title);
	}
	return titles;
};

exports.countTiddlers = function(excludeTag) {
	var tiddlers = this.getTiddlers({excludeTag: excludeTag});
	return $tw.utils.count(tiddlers);
};

/*
Returns a function iterator(callback) that iterates through the specified titles, and invokes the callback with callback(tiddler,title)
*/
exports.makeTiddlerIterator = function(titles) {
	var self = this;
	if(!$tw.utils.isArray(titles)) {
		titles = Object.keys(titles);
	} else {
		titles = titles.slice(0);
	}
	return function(callback) {
		titles.forEach(function(title) {
			callback(self.getTiddler(title),title);
		});
	};
};

/*
Sort an array of tiddler titles by a specified field
	titles: array of titles (sorted in place)
	sortField: name of field to sort by
	isDescending: true if the sort should be descending
	isCaseSensitive: true if the sort should consider upper and lower case letters to be different
*/
exports.sortTiddlers = function(titles,sortField,isDescending,isCaseSensitive,isNumeric,isAlphaNumeric) {
	var self = this;
	titles.sort(function(a,b) {
		var x,y,
			compareNumbers = function(x,y) {
				var result = 
					isNaN(x) && !isNaN(y) ? (isDescending ? -1 : 1) :
					!isNaN(x) && isNaN(y) ? (isDescending ? 1 : -1) :
											(isDescending ? y - x :  x - y);
				return result;
			};
		if(sortField !== "title") {
			var tiddlerA = self.getTiddler(a),
				tiddlerB = self.getTiddler(b);
			if(tiddlerA) {
				a = tiddlerA.fields[sortField] || "";
			} else {
				a = "";
			}
			if(tiddlerB) {
				b = tiddlerB.fields[sortField] || "";
			} else {
				b = "";
			}
		}
		x = Number(a);
		y = Number(b);
		if(isNumeric && (!isNaN(x) || !isNaN(y))) {
			return compareNumbers(x,y);
		} else if(isAlphaNumeric) {
			return isDescending ? b.localeCompare(a,undefined,{numeric: true,sensitivity: "base"}) : a.localeCompare(b,undefined,{numeric: true,sensitivity: "base"});
		} else if($tw.utils.isDate(a) && $tw.utils.isDate(b)) {
			return isDescending ? b - a : a - b;
		} else {
			a = String(a);
			b = String(b);
			if(!isCaseSensitive) {
				a = a.toLowerCase();
				b = b.toLowerCase();
			}
			return isDescending ? b.localeCompare(a) : a.localeCompare(b);
		}
	});
};

/*
For every tiddler invoke a callback(title,tiddler) with `this` set to the wiki object. Options include:
sortField: field to sort by
excludeTag: tag to exclude
includeSystem: whether to include system tiddlers (defaults to false)
*/
exports.forEachTiddler = function(/* [options,]callback */) {
	var arg = 0,
		options = arguments.length >= 2 ? arguments[arg++] : {},
		callback = arguments[arg++],
		titles = this.getTiddlers(options),
		t, tiddler;
	for(t=0; t<titles.length; t++) {
		tiddler = this.getTiddler(titles[t]);
		if(tiddler) {
			callback.call(this,tiddler.fields.title,tiddler);
		}
	}
};

/*
Return an array of tiddler titles that are directly linked from the specified tiddler
*/
exports.getTiddlerLinks = function(title) {
	var self = this;
	// We'll cache the links so they only get computed if the tiddler changes
	return this.getCacheForTiddler(title,"links",function() {
		// Parse the tiddler
		var parser = self.parseTiddler(title);
		// Count up the links
		var links = [],
			checkParseTree = function(parseTree) {
				for(var t=0; t<parseTree.length; t++) {
					var parseTreeNode = parseTree[t];
					if(parseTreeNode.type === "link" && parseTreeNode.attributes.to && parseTreeNode.attributes.to.type === "string") {
						var value = parseTreeNode.attributes.to.value;
						if(links.indexOf(value) === -1) {
							links.push(value);
						}
					}
					if(parseTreeNode.children) {
						checkParseTree(parseTreeNode.children);
					}
				}
			};
		if(parser) {
			checkParseTree(parser.tree);
		}
		return links;
	});
};

/*
Return an array of tiddler titles that link to the specified tiddler
*/
exports.getTiddlerBacklinks = function(targetTitle) {
	var self = this,
		backlinks = [];
	this.forEachTiddler(function(title,tiddler) {
		var links = self.getTiddlerLinks(title);
		if(links.indexOf(targetTitle) !== -1) {
			backlinks.push(title);
		}
	});
	return backlinks;
};

/*
Return a hashmap of tiddler titles that are referenced but not defined. Each value is the number of times the missing tiddler is referenced
*/
exports.getMissingTitles = function() {
	var self = this,
		missing = [];
// We should cache the missing tiddler list, even if we recreate it every time any tiddler is modified
	this.forEachTiddler(function(title,tiddler) {
		var links = self.getTiddlerLinks(title);
		$tw.utils.each(links,function(link) {
			if((!self.tiddlerExists(link) && !self.isShadowTiddler(link)) && missing.indexOf(link) === -1) {
				missing.push(link);
			}
		});
	});
	return missing;
};

exports.getOrphanTitles = function() {
	var self = this,
		orphans = this.getTiddlers();
	this.forEachTiddler(function(title,tiddler) {
		var links = self.getTiddlerLinks(title);
		$tw.utils.each(links,function(link) {
			var p = orphans.indexOf(link);
			if(p !== -1) {
				orphans.splice(p,1);
			}
		});
	});
	return orphans; // Todo
};

/*
Retrieves a list of the tiddler titles that are tagged with a given tag
*/
exports.getTiddlersWithTag = function(tag) {
	// Try to use the indexer
	var self = this,
		tagIndexer = this.getIndexer("TagIndexer"),
		results = tagIndexer && tagIndexer.lookup(tag);
	if(!results) {
		// If not available, perform a manual scan
		results = this.getGlobalCache("taglist-" + tag,function() {
			var tagmap = self.getTagMap();
			return self.sortByList(tagmap[tag],tag);
		});
	}
	return results;
};

/*
Get a hashmap by tag of arrays of tiddler titles
*/
exports.getTagMap = function() {
	var self = this;
	return this.getGlobalCache("tagmap",function() {
		var tags = Object.create(null),
			storeTags = function(tagArray,title) {
				if(tagArray) {
					for(var index=0; index<tagArray.length; index++) {
						var tag = tagArray[index];
						if($tw.utils.hop(tags,tag)) {
							tags[tag].push(title);
						} else {
							tags[tag] = [title];
						}
					}
				}
			},
			title, tiddler;
		// Collect up all the tags
		self.eachShadow(function(tiddler,title) {
			if(!self.tiddlerExists(title)) {
				tiddler = self.getTiddler(title);
				storeTags(tiddler.fields.tags,title);
			}
		});
		self.each(function(tiddler,title) {
			storeTags(tiddler.fields.tags,title);
		});
		return tags;
	});
};

/*
Lookup a given tiddler and return a list of all the tiddlers that include it in the specified list field
*/
exports.findListingsOfTiddler = function(targetTitle,fieldName) {
	fieldName = fieldName || "list";
	var titles = [];
	this.each(function(tiddler,title) {
		var list = $tw.utils.parseStringArray(tiddler.fields[fieldName]);
		if(list && list.indexOf(targetTitle) !== -1) {
			titles.push(title);
		}
	});
	return titles;
};

/*
Sorts an array of tiddler titles according to an ordered list
*/
exports.sortByList = function(array,listTitle) {
	var self = this,
		replacedTitles = Object.create(null);
	function replaceItem(title) {
		if(!$tw.utils.hop(replacedTitles, title)) {
			replacedTitles[title] = true;
			var newPos = -1,
				tiddler = self.getTiddler(title);
			if(tiddler) {
				var beforeTitle = tiddler.fields["list-before"],
					afterTitle = tiddler.fields["list-after"];
				if(beforeTitle === "") {
					newPos = 0;
				} else if(afterTitle === "") {
					newPos = titles.length;
				} else if(beforeTitle) {
					replaceItem(beforeTitle);
					newPos = titles.indexOf(beforeTitle);
				} else if(afterTitle) {
					replaceItem(afterTitle);
					newPos = titles.indexOf(afterTitle);
					if(newPos >= 0) {
						++newPos;
					}
				}
				// We get the currPos //after// figuring out the newPos, because recursive replaceItem calls might alter title's currPos
				var currPos = titles.indexOf(title);
				if(newPos === -1) {
					newPos = currPos;
				}
				if(currPos >= 0 && newPos !== currPos) {
					titles.splice(currPos,1);
					if(newPos >= currPos) {
						newPos--;
					}
					titles.splice(newPos,0,title);
				}
			}
		}
	}
	var list = this.getTiddlerList(listTitle);
	if(!array || array.length === 0) {
		return [];
	} else {
		var titles = [], t, title;
		// First place any entries that are present in the list
		for(t=0; t<list.length; t++) {
			title = list[t];
			if(array.indexOf(title) !== -1) {
				titles.push(title);
			}
		}
		// Then place any remaining entries
		for(t=0; t<array.length; t++) {
			title = array[t];
			if(list.indexOf(title) === -1) {
				titles.push(title);
			}
		}
		// Finally obey the list-before and list-after fields of each tiddler in turn
		var sortedTitles = titles.slice(0);
		for(t=0; t<sortedTitles.length; t++) {
			title = sortedTitles[t];
			replaceItem(title);
		}
		return titles;
	}
};

exports.getSubTiddler = function(title,subTiddlerTitle) {
	var bundleInfo = this.getPluginInfo(title) || this.getTiddlerDataCached(title);
	if(bundleInfo && bundleInfo.tiddlers) {
		var subTiddler = bundleInfo.tiddlers[subTiddlerTitle];
		if(subTiddler) {
			return new $tw.Tiddler(subTiddler);
		}
	}
	return null;
};

/*
Retrieve a tiddler as a JSON string of the fields
*/
exports.getTiddlerAsJson = function(title) {
	var tiddler = this.getTiddler(title);
	if(tiddler) {
		var fields = Object.create(null);
		$tw.utils.each(tiddler.fields,function(value,name) {
			fields[name] = tiddler.getFieldString(name);
		});
		return JSON.stringify(fields);
	} else {
		return JSON.stringify({title: title});
	}
};

exports.getTiddlersAsJson = function(filter) {
	var tiddlers = this.filterTiddlers(filter),
		data = [];
	for(var t=0;t<tiddlers.length; t++) {
		var tiddler = this.getTiddler(tiddlers[t]);
		if(tiddler) {
			var fields = new Object();
			for(var field in tiddler.fields) {
				fields[field] = tiddler.getFieldString(field);
			}
			data.push(fields);
		}
	}
	return JSON.stringify(data,null,$tw.config.preferences.jsonSpaces);
};

/*
Get the content of a tiddler as a JavaScript object. How this is done depends on the type of the tiddler:

application/json: the tiddler JSON is parsed into an object
application/x-tiddler-dictionary: the tiddler is parsed as sequence of name:value pairs

Other types currently just return null.

titleOrTiddler: string tiddler title or a tiddler object
defaultData: default data to be returned if the tiddler is missing or doesn't contain data

Note that the same value is returned for repeated calls for the same tiddler data. The value is frozen to prevent modification; otherwise modifications would be visible to all callers
*/
exports.getTiddlerDataCached = function(titleOrTiddler,defaultData) {
	var self = this,
		tiddler = titleOrTiddler;
	if(!(tiddler instanceof $tw.Tiddler)) {
		tiddler = this.getTiddler(tiddler);	
	}
	if(tiddler) {
		return this.getCacheForTiddler(tiddler.fields.title,"data",function() {
			// Return the frozen value
			var value = self.getTiddlerData(tiddler.fields.title,undefined);
			$tw.utils.deepFreeze(value);
			return value;
		}) || defaultData;
	} else {
		return defaultData;
	}
};

/*
Alternative, uncached version of getTiddlerDataCached(). The return value can be mutated freely and reused
*/
exports.getTiddlerData = function(titleOrTiddler,defaultData) {
	var tiddler = titleOrTiddler,
		data;
	if(!(tiddler instanceof $tw.Tiddler)) {
		tiddler = this.getTiddler(tiddler);	
	}
	if(tiddler && tiddler.fields.text) {
		switch(tiddler.fields.type) {
			case "application/json":
				// JSON tiddler
				try {
					data = JSON.parse(tiddler.fields.text);
				} catch(ex) {
					return defaultData;
				}
				return data;
			case "application/x-tiddler-dictionary":
				return $tw.utils.parseFields(tiddler.fields.text);
		}
	}
	return defaultData;
};

/*
Extract an indexed field from within a data tiddler
*/
exports.extractTiddlerDataItem = function(titleOrTiddler,index,defaultText) {
	var data = this.getTiddlerDataCached(titleOrTiddler,Object.create(null)),
		text;
	if(data && $tw.utils.hop(data,index)) {
		text = data[index];
	}
	if(typeof text === "string" || typeof text === "number") {
		return text.toString();
	} else {
		return defaultText;
	}
};

/*
Set a tiddlers content to a JavaScript object. Currently this is done by setting the tiddler's type to "application/json" and setting the text to the JSON text of the data.
title: title of tiddler
data: object that can be serialised to JSON
fields: optional hashmap of additional tiddler fields to be set
*/
exports.setTiddlerData = function(title,data,fields) {
	var existingTiddler = this.getTiddler(title),
		newFields = {
			title: title
	};
	if(existingTiddler && existingTiddler.fields.type === "application/x-tiddler-dictionary") {
		newFields.text = $tw.utils.makeTiddlerDictionary(data);
	} else {
		newFields.type = "application/json";
		newFields.text = JSON.stringify(data,null,$tw.config.preferences.jsonSpaces);
	}
	this.addTiddler(new $tw.Tiddler(this.getCreationFields(),existingTiddler,fields,newFields,this.getModificationFields()));
};

/*
Return the content of a tiddler as an array containing each line
*/
exports.getTiddlerList = function(title,field,index) {
	if(index) {
		return $tw.utils.parseStringArray(this.extractTiddlerDataItem(title,index,""));
	}
	field = field || "list";
	var tiddler = this.getTiddler(title);
	if(tiddler) {
		return ($tw.utils.parseStringArray(tiddler.fields[field]) || []).slice(0);
	}
	return [];
};

// Return a named global cache object. Global cache objects are cleared whenever a tiddler change occurs
exports.getGlobalCache = function(cacheName,initializer) {
	this.globalCache = this.globalCache || Object.create(null);
	if($tw.utils.hop(this.globalCache,cacheName)) {
		return this.globalCache[cacheName];
	} else {
		this.globalCache[cacheName] = initializer();
		return this.globalCache[cacheName];
	}
};

exports.clearGlobalCache = function() {
	this.globalCache = Object.create(null);
};

// Return the named cache object for a tiddler. If the cache doesn't exist then the initializer function is invoked to create it
exports.getCacheForTiddler = function(title,cacheName,initializer) {
	this.caches = this.caches || Object.create(null);
	var caches = this.caches[title];
	if(caches && caches[cacheName]) {
		return caches[cacheName];
	} else {
		if(!caches) {
			caches = Object.create(null);
			this.caches[title] = caches;
		}
		caches[cacheName] = initializer();
		return caches[cacheName];
	}
};

// Clear all caches associated with a particular tiddler, or, if the title is null, clear all the caches for all the tiddlers
exports.clearCache = function(title) {
	if(title) {
		this.caches = this.caches || Object.create(null);
		if($tw.utils.hop(this.caches,title)) {
			delete this.caches[title];
		}
	} else {
		this.caches = Object.create(null);
	}
};

exports.initParsers = function(moduleType) {
	// Install the parser modules
	$tw.Wiki.parsers = {};
	var self = this;
	$tw.modules.forEachModuleOfType("parser",function(title,module) {
		for(var f in module) {
			if($tw.utils.hop(module,f)) {
				$tw.Wiki.parsers[f] = module[f]; // Store the parser class
			}
		}
	});
	// Use the generic binary parser for any binary types not registered so far
	if($tw.Wiki.parsers["application/octet-stream"]) {
		Object.keys($tw.config.contentTypeInfo).forEach(function(type) {
			if(!$tw.utils.hop($tw.Wiki.parsers,type) && $tw.config.contentTypeInfo[type].encoding === "base64") {
				$tw.Wiki.parsers[type] = $tw.Wiki.parsers["application/octet-stream"];
			}
		});		
	}
};

/*
Parse a block of text of a specified MIME type
	type: content type of text to be parsed
	text: text
	options: see below
Options include:
	parseAsInline: if true, the text of the tiddler will be parsed as an inline run
	_canonical_uri: optional string of the canonical URI of this content
*/
exports.parseText = function(type,text,options) {
	text = text || "";
	options = options || {};
	// Select a parser
	var Parser = $tw.Wiki.parsers[type];
	if(!Parser && $tw.utils.getFileExtensionInfo(type)) {
		Parser = $tw.Wiki.parsers[$tw.utils.getFileExtensionInfo(type).type];
	}
	if(!Parser) {
		Parser = $tw.Wiki.parsers[options.defaultType || "text/vnd.tiddlywiki"];
	}
	if(!Parser) {
		return null;
	}
	// Return the parser instance
	return new Parser(type,text,{
		parseAsInline: options.parseAsInline,
		wiki: this,
		_canonical_uri: options._canonical_uri
	});
};

/*
Parse a tiddler according to its MIME type
*/
exports.parseTiddler = function(title,options) {
	options = $tw.utils.extend({},options);
	var cacheType = options.parseAsInline ? "inlineParseTree" : "blockParseTree",
		tiddler = this.getTiddler(title),
		self = this;
	return tiddler ? this.getCacheForTiddler(title,cacheType,function() {
			if(tiddler.hasField("_canonical_uri")) {
				options._canonical_uri = tiddler.fields._canonical_uri;
			}
			return self.parseText(tiddler.fields.type,tiddler.fields.text,options);
		}) : null;
};

exports.parseTextReference = function(title,field,index,options) {
	var tiddler,text;
	if(options.subTiddler) {
		tiddler = this.getSubTiddler(title,options.subTiddler);
	} else {
		tiddler = this.getTiddler(title);
		if(field === "text" || (!field && !index)) {
			this.getTiddlerText(title); // Force the tiddler to be lazily loaded
			return this.parseTiddler(title,options);
		}
	}
	if(field === "text" || (!field && !index)) {
		if(tiddler && tiddler.fields) {
			return this.parseText(tiddler.fields.type,tiddler.fields.text,options);			
		} else {
			return null;
		}
	} else if(field) {
		if(field === "title") {
			text = title;
		} else {
			if(!tiddler || !tiddler.hasField(field)) {
				return null;
			}
			text = tiddler.fields[field];
		}
		return this.parseText("text/vnd.tiddlywiki",text.toString(),options);
	} else if(index) {
		this.getTiddlerText(title); // Force the tiddler to be lazily loaded
		text = this.extractTiddlerDataItem(tiddler,index,undefined);
		if(text === undefined) {
			return null;
		}
		return this.parseText("text/vnd.tiddlywiki",text,options);
	}
};

/*
Make a widget tree for a parse tree
parser: parser object
options: see below
Options include:
document: optional document to use
variables: hashmap of variables to set
parentWidget: optional parent widget for the root node
*/
exports.makeWidget = function(parser,options) {
	options = options || {};
	var widgetNode = {
			type: "widget",
			children: []
		},
		currWidgetNode = widgetNode;
	// Create set variable widgets for each variable
	$tw.utils.each(options.variables,function(value,name) {
		var setVariableWidget = {
			type: "set",
			attributes: {
				name: {type: "string", value: name},
				value: {type: "string", value: value}
			},
			children: []
		};
		currWidgetNode.children = [setVariableWidget];
		currWidgetNode = setVariableWidget;
	});
	// Add in the supplied parse tree nodes
	currWidgetNode.children = parser ? parser.tree : [];
	// Create the widget
	return new widget.widget(widgetNode,{
		wiki: this,
		document: options.document || $tw.fakeDocument,
		parentWidget: options.parentWidget
	});
};

/*
Make a widget tree for transclusion
title: target tiddler title
options: as for wiki.makeWidget() plus:
options.field: optional field to transclude (defaults to "text")
options.mode: transclusion mode "inline" or "block"
options.children: optional array of children for the transclude widget
options.importVariables: optional importvariables filter string for macros to be included
options.importPageMacros: optional boolean; if true, equivalent to passing "[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]" to options.importVariables
*/
exports.makeTranscludeWidget = function(title,options) {
	options = options || {};
	var parseTreeDiv = {tree: [{
			type: "element",
			tag: "div",
			children: []}]},
		parseTreeImportVariables = {
			type: "importvariables",
			attributes: {
				filter: {
					name: "filter",
					type: "string"
				}
			},
			isBlock: false,
			children: []},
		parseTreeTransclude = {
			type: "transclude",
			attributes: {
				tiddler: {
					name: "tiddler",
					type: "string",
					value: title}},
			isBlock: !options.parseAsInline};
	if(options.importVariables || options.importPageMacros) {
		if(options.importVariables) {
			parseTreeImportVariables.attributes.filter.value = options.importVariables;
		} else if(options.importPageMacros) {
			parseTreeImportVariables.attributes.filter.value = "[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]";
		}
		parseTreeDiv.tree[0].children.push(parseTreeImportVariables);
		parseTreeImportVariables.children.push(parseTreeTransclude);
	} else {
		parseTreeDiv.tree[0].children.push(parseTreeTransclude);
	}
	if(options.field) {
		parseTreeTransclude.attributes.field = {type: "string", value: options.field};
	}
	if(options.mode) {
		parseTreeTransclude.attributes.mode = {type: "string", value: options.mode};
	}
	if(options.children) {
		parseTreeTransclude.children = options.children;
	}
	return $tw.wiki.makeWidget(parseTreeDiv,options);
};

/*
Parse text in a specified format and render it into another format
	outputType: content type for the output
	textType: content type of the input text
	text: input text
	options: see below
Options include:
variables: hashmap of variables to set
parentWidget: optional parent widget for the root node
*/
exports.renderText = function(outputType,textType,text,options) {
	options = options || {};
	var parser = this.parseText(textType,text,options),
		widgetNode = this.makeWidget(parser,options);
	var container = $tw.fakeDocument.createElement("div");
	widgetNode.render(container,null);
	return outputType === "text/html" ? container.innerHTML : container.textContent;
};

/*
Parse text from a tiddler and render it into another format
	outputType: content type for the output
	title: title of the tiddler to be rendered
	options: see below
Options include:
variables: hashmap of variables to set
parentWidget: optional parent widget for the root node
*/
exports.renderTiddler = function(outputType,title,options) {
	options = options || {};
	var parser = this.parseTiddler(title,options),
		widgetNode = this.makeWidget(parser,options);
	var container = $tw.fakeDocument.createElement("div");
	widgetNode.render(container,null);
	return outputType === "text/html" ? container.innerHTML : (outputType === "text/plain-formatted" ? container.formattedTextContent : container.textContent);
};

/*
Return an array of tiddler titles that match a search string
	text: The text string to search for
	options: see below
Options available:
	source: an iterator function for the source tiddlers, called source(iterator), where iterator is called as iterator(tiddler,title)
	exclude: An array of tiddler titles to exclude from the search
	invert: If true returns tiddlers that do not contain the specified string
	caseSensitive: If true forces a case sensitive search
	field: If specified, restricts the search to the specified field, or an array of field names
	excludeField: If true, the field options are inverted to specify the fields that are not to be searched
	The search mode is determined by the first of these boolean flags to be true
		literal: searches for literal string
		whitespace: same as literal except runs of whitespace are treated as a single space
		regexp: treats the search term as a regular expression
		words: (default) treats search string as a list of tokens, and matches if all tokens are found, regardless of adjacency or ordering
*/
exports.search = function(text,options) {
	options = options || {};
	var self = this,
		t,
		invert = !!options.invert;
	// Convert the search string into a regexp for each term
	var terms, searchTermsRegExps,
		flags = options.caseSensitive ? "" : "i";
	if(options.literal) {
		if(text.length === 0) {
			searchTermsRegExps = null;
		} else {
			searchTermsRegExps = [new RegExp("(" + $tw.utils.escapeRegExp(text) + ")",flags)];
		}
	} else if(options.whitespace) {
		terms = [];
		$tw.utils.each(text.split(/\s+/g),function(term) {
			if(term) {
				terms.push($tw.utils.escapeRegExp(term));
			}
		});
		searchTermsRegExps = [new RegExp("(" + terms.join("\\s+") + ")",flags)];
	} else if(options.regexp) {
		try {
			searchTermsRegExps = [new RegExp("(" + text + ")",flags)];			
		} catch(e) {
			searchTermsRegExps = null;
			console.log("Regexp error parsing /(" + text + ")/" + flags + ": ",e);
		}
	} else {
		terms = text.split(/ +/);
		if(terms.length === 1 && terms[0] === "") {
			searchTermsRegExps = null;
		} else {
			searchTermsRegExps = [];
			for(t=0; t<terms.length; t++) {
				searchTermsRegExps.push(new RegExp("(" + $tw.utils.escapeRegExp(terms[t]) + ")",flags));
			}
		}
	}
	// Accumulate the array of fields to be searched or excluded from the search
	var fields = [];
	if(options.field) {
		if($tw.utils.isArray(options.field)) {
			$tw.utils.each(options.field,function(fieldName) {
				if(fieldName) {
					fields.push(fieldName);					
				}
			});
		} else {
			fields.push(options.field);
		}
	}
	// Use default fields if none specified and we're not excluding fields (excluding fields with an empty field array is the same as searching all fields)
	if(fields.length === 0 && !options.excludeField) {
		fields.push("title");
		fields.push("tags");
		fields.push("text");
	}
	// Function to check a given tiddler for the search term
	var searchTiddler = function(title) {
		if(!searchTermsRegExps) {
			return true;
		}
		var notYetFound = searchTermsRegExps.slice();

		var tiddler = self.getTiddler(title);
		if(!tiddler) {
			tiddler = new $tw.Tiddler({title: title, text: "", type: "text/vnd.tiddlywiki"});
		}
		var contentTypeInfo = $tw.config.contentTypeInfo[tiddler.fields.type] || $tw.config.contentTypeInfo["text/vnd.tiddlywiki"],
			searchFields;
		// Get the list of fields we're searching
		if(options.excludeField) {
			searchFields = Object.keys(tiddler.fields);
			$tw.utils.each(fields,function(fieldName) {
				var p = searchFields.indexOf(fieldName);
				if(p !== -1) {
					searchFields.splice(p,1);
				}
			});
		} else {
			searchFields = fields;
		}
		for(var fieldIndex=0; notYetFound.length>0 && fieldIndex<searchFields.length; fieldIndex++) {
			// Don't search the text field if the content type is binary
			var fieldName = searchFields[fieldIndex];
			if(fieldName === "text" && contentTypeInfo.encoding !== "utf8") {
				break;
			}
			var str = tiddler.fields[fieldName],
				t;
			if(str) {
				if($tw.utils.isArray(str)) {
					// If the field value is an array, test each regexp against each field array entry and fail if each regexp doesn't match at least one field array entry
					for(var s=0; s<str.length; s++) {
						for(t=0; t<notYetFound.length;) {
							if(notYetFound[t].test(str[s])) {
								notYetFound.splice(t, 1);
							} else {
								t++;
							}
						}
					}
				} else {
					// If the field isn't an array, force it to a string and test each regexp against it and fail if any do not match
					str = tiddler.getFieldString(fieldName);
					for(t=0; t<notYetFound.length;) {
						if(notYetFound[t].test(str)) {
							notYetFound.splice(t, 1);
						} else {
							t++;
						}
					}
				}
			}
		};
		return notYetFound.length == 0;
	};
	// Loop through all the tiddlers doing the search
	var results = [],
		source = options.source || this.each;
	source(function(tiddler,title) {
		if(searchTiddler(title) !== options.invert) {
			results.push(title);
		}
	});
	// Remove any of the results we have to exclude
	if(options.exclude) {
		for(t=0; t<options.exclude.length; t++) {
			var p = results.indexOf(options.exclude[t]);
			if(p !== -1) {
				results.splice(p,1);
			}
		}
	}
	return results;
};

/*
Trigger a load for a tiddler if it is skinny. Returns the text, or undefined if the tiddler is missing, null if the tiddler is being lazily loaded.
*/
exports.getTiddlerText = function(title,defaultText) {
	var tiddler = this.getTiddler(title);
	// Return undefined if the tiddler isn't found
	if(!tiddler) {
		return defaultText;
	}
	if(tiddler.fields.text !== undefined) {
		// Just return the text if we've got it
		return tiddler.fields.text;
	} else {
		// Tell any listeners about the need to lazily load this tiddler
		this.dispatchEvent("lazyLoad",title);
		// Indicate that the text is being loaded
		return null;
	}
};

/*
Check whether the text of a tiddler matches a given value. By default, the comparison is case insensitive, and any spaces at either end of the tiddler text is trimmed
*/
exports.checkTiddlerText = function(title,targetText,options) {
	options = options || {};
	var text = this.getTiddlerText(title,"");
	if(!options.noTrim) {
		text = text.trim();
	}
	if(!options.caseSensitive) {
		text = text.toLowerCase();
		targetText = targetText.toLowerCase();
	}
	return text === targetText;
}

/*
Read an array of browser File objects, invoking callback(tiddlerFieldsArray) once they're all read
*/
exports.readFiles = function(files,options) {
	var callback;
	if(typeof options === "function") {
		callback = options;
		options = {};
	} else {
		callback = options.callback;
	}
	var result = [],
		outstanding = files.length,
		readFileCallback = function(tiddlerFieldsArray) {
			result.push.apply(result,tiddlerFieldsArray);
			if(--outstanding === 0) {
				callback(result);
			}
		};
	for(var f=0; f<files.length; f++) {
		this.readFile(files[f],$tw.utils.extend({},options,{callback: readFileCallback}));
	}
	return files.length;
};

/*
Read a browser File object, invoking callback(tiddlerFieldsArray) with an array of tiddler fields objects
*/
exports.readFile = function(file,options) {
	var callback;
	if(typeof options === "function") {
		callback = options;
		options = {};
	} else {
		callback = options.callback;
	}
	// Get the type, falling back to the filename extension
	var self = this,
		type = file.type;
	if(type === "" || !type) {
		var dotPos = file.name.lastIndexOf(".");
		if(dotPos !== -1) {
			var fileExtensionInfo = $tw.utils.getFileExtensionInfo(file.name.substr(dotPos));
			if(fileExtensionInfo) {
				type = fileExtensionInfo.type;
			}
		}
	}
	// Figure out if we're reading a binary file
	var contentTypeInfo = $tw.config.contentTypeInfo[type],
		isBinary = contentTypeInfo ? contentTypeInfo.encoding === "base64" : false;
	// Log some debugging information
	if($tw.log.IMPORT) {
		console.log("Importing file '" + file.name + "', type: '" + type + "', isBinary: " + isBinary);
	}
	// Give the hook a chance to process the drag
	if($tw.hooks.invokeHook("th-importing-file",{
		file: file,
		type: type,
		isBinary: isBinary,
		callback: callback
	}) !== true) {
		this.readFileContent(file,type,isBinary,options.deserializer,callback);
	}
};

/*
Lower level utility to read the content of a browser File object, invoking callback(tiddlerFieldsArray) with an array of tiddler fields objects
*/
exports.readFileContent = function(file,type,isBinary,deserializer,callback) {
	var self = this;
	// Create the FileReader
	var reader = new FileReader();
	// Onload
	reader.onload = function(event) {
		var text = event.target.result,
			tiddlerFields = {title: file.name || "Untitled", type: type};
		if(isBinary) {
			var commaPos = text.indexOf(",");
			if(commaPos !== -1) {
				text = text.substr(commaPos + 1);
			}
		}
		// Check whether this is an encrypted TiddlyWiki file
		var encryptedJson = $tw.utils.extractEncryptedStoreArea(text);
		if(encryptedJson) {
			// If so, attempt to decrypt it with the current password
			$tw.utils.decryptStoreAreaInteractive(encryptedJson,function(tiddlers) {
				callback(tiddlers);
			});
		} else {
			// Otherwise, just try to deserialise any tiddlers in the file
			callback(self.deserializeTiddlers(type,text,tiddlerFields,{deserializer: deserializer}));
		}
	};
	// Kick off the read
	if(isBinary) {
		reader.readAsDataURL(file);
	} else {
		reader.readAsText(file);
	}
};

/*
Find any existing draft of a specified tiddler
*/
exports.findDraft = function(targetTitle) {
	var draftTitle = undefined;
	this.forEachTiddler({includeSystem: true},function(title,tiddler) {
		if(tiddler.fields["draft.title"] && tiddler.fields["draft.of"] === targetTitle) {
			draftTitle = title;
		}
	});
	return draftTitle;
}

/*
Check whether the specified draft tiddler has been modified.
If the original tiddler doesn't exist, create  a vanilla tiddler variable,
to check if additional fields have been added.
*/
exports.isDraftModified = function(title) {
	var tiddler = this.getTiddler(title);
	if(!tiddler.isDraft()) {
		return false;
	}
	var ignoredFields = ["created", "modified", "title", "draft.title", "draft.of"],
		origTiddler = this.getTiddler(tiddler.fields["draft.of"]) || new $tw.Tiddler({text:"", tags:[]}),
		titleModified = tiddler.fields["draft.title"] !== tiddler.fields["draft.of"];
	return titleModified || !tiddler.isEqual(origTiddler,ignoredFields);
};

/*
Add a new record to the top of the history stack
title: a title string or an array of title strings
fromPageRect: page coordinates of the origin of the navigation
historyTitle: title of history tiddler (defaults to $:/HistoryList)
*/
exports.addToHistory = function(title,fromPageRect,historyTitle) {
	var story = new $tw.Story({wiki: this, historyTitle: historyTitle});
	story.addToHistory(title,fromPageRect);
};

/*
Add a new tiddler to the story river
title: a title string or an array of title strings
fromTitle: the title of the tiddler from which the navigation originated
storyTitle: title of story tiddler (defaults to $:/StoryList)
options: see story.js
*/
exports.addToStory = function(title,fromTitle,storyTitle,options) {
	var story = new $tw.Story({wiki: this, storyTitle: storyTitle});
	story.addToStory(title,fromTitle,options);
};

/*
Generate a title for the draft of a given tiddler
*/
exports.generateDraftTitle = function(title) {
	var c = 0,
		draftTitle,
		username = this.getTiddlerText("$:/status/UserName"),
		attribution = username ? " by " + username : "";
	do {
		draftTitle = "Draft " + (c ? (c + 1) + " " : "") + "of '" + title + "'" + attribution;
		c++;
	} while(this.tiddlerExists(draftTitle));
	return draftTitle;
};

/*
Invoke the available upgrader modules
titles: array of tiddler titles to be processed
tiddlers: hashmap by title of tiddler fields of pending import tiddlers. These can be modified by the upgraders. An entry with no fields indicates a tiddler that was pending import has been suppressed. When entries are added to the pending import the tiddlers hashmap may have entries that are not present in the titles array
Returns a hashmap of messages keyed by tiddler title.
*/
exports.invokeUpgraders = function(titles,tiddlers) {
	// Collect up the available upgrader modules
	var self = this;
	if(!this.upgraderModules) {
		this.upgraderModules = [];
		$tw.modules.forEachModuleOfType("upgrader",function(title,module) {
			if(module.upgrade) {
				self.upgraderModules.push(module);
			}
		});
	}
	// Invoke each upgrader in turn
	var messages = {};
	for(var t=0; t<this.upgraderModules.length; t++) {
		var upgrader = this.upgraderModules[t],
			upgraderMessages = upgrader.upgrade(this,titles,tiddlers);
		$tw.utils.extend(messages,upgraderMessages);
	}
	return messages;
};

})();


;})();
return exports;
}));
_define("$:/plugins/tiddlywiki/filesystem/filesystemadaptor.js","syncadaptor",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/plugins/tiddlywiki/filesystem/filesystemadaptor.js
type: application/javascript
module-type: syncadaptor

A sync adaptor module for synchronising with the local filesystem via node.js APIs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Get a reference to the file system
var fs = $tw.node ? require("fs") : null,
	path = $tw.node ? require("path") : null;

function FileSystemAdaptor(options) {
	var self = this;
	this.wiki = options.wiki;
	this.logger = new $tw.utils.Logger("filesystem",{colour: "blue"});
	// Create the <wiki>/tiddlers folder if it doesn't exist
	$tw.utils.createDirectory($tw.boot.wikiTiddlersPath);
}

FileSystemAdaptor.prototype.name = "filesystem";

FileSystemAdaptor.prototype.isReady = function() {
	// The file system adaptor is always ready
	return true;
};

FileSystemAdaptor.prototype.getTiddlerInfo = function(tiddler) {
	return {};
};

/*
Return a fileInfo object for a tiddler, creating it if necessary:
  filepath: the absolute path to the file containing the tiddler
  type: the type of the tiddler file (NOT the type of the tiddler -- see below)
  hasMetaFile: true if the file also has a companion .meta file

The boot process populates $tw.boot.files for each of the tiddler files that it loads. The type is found by looking up the extension in $tw.config.fileExtensionInfo (eg "application/x-tiddler" for ".tid" files).

It is the responsibility of the filesystem adaptor to update $tw.boot.files for new files that are created.
*/
FileSystemAdaptor.prototype.getTiddlerFileInfo = function(tiddler,callback) {
	// See if we've already got information about this file
	var title = tiddler.fields.title,
		fileInfo = $tw.boot.files[title];
	if(!fileInfo) {
		// Otherwise, we'll need to generate it
		fileInfo = $tw.utils.generateTiddlerFileInfo(tiddler,{
			directory: $tw.boot.wikiTiddlersPath,
			pathFilters: this.wiki.getTiddlerText("$:/config/FileSystemPaths"),
			wiki: this.wiki
		});
		$tw.boot.files[title] = fileInfo;
	}
	callback(null,fileInfo);
};


/*
Save a tiddler and invoke the callback with (err,adaptorInfo,revision)
*/
FileSystemAdaptor.prototype.saveTiddler = function(tiddler,callback) {
	var self = this;
	this.getTiddlerFileInfo(tiddler,function(err,fileInfo) {
		if(err) {
			return callback(err);
		}
		$tw.utils.saveTiddlerToFile(tiddler,fileInfo,callback);
	});
};

/*
Load a tiddler and invoke the callback with (err,tiddlerFields)

We don't need to implement loading for the file system adaptor, because all the tiddler files will have been loaded during the boot process.
*/
FileSystemAdaptor.prototype.loadTiddler = function(title,callback) {
	callback(null,null);
};

/*
Delete a tiddler and invoke the callback with (err)
*/
FileSystemAdaptor.prototype.deleteTiddler = function(title,callback,options) {
	var self = this,
		fileInfo = $tw.boot.files[title];
	// Only delete the tiddler if we have writable information for the file
	if(fileInfo) {
		// Delete the file
		fs.unlink(fileInfo.filepath,function(err) {
			if(err) {
				return callback(err);
			}
			// Delete the metafile if present
			if(fileInfo.hasMetaFile) {
				fs.unlink(fileInfo.filepath + ".meta",function(err) {
					if(err) {
						return callback(err);
					}
					return $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);
				});
			} else {
				return $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);
			}
		});
	} else {
		callback(null);
	}
};

if(fs) {
	exports.adaptorClass = FileSystemAdaptor;
}

})();

;})();
return exports;
}));
_define("$:/plugins/tiddlywiki/highlight/highlight.js","library",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
var hljs = require("$:/plugins/tiddlywiki/highlight/highlight.js");
/*! highlight.js v9.15.6 | BSD3 License | git.io/hljslicense */
!function(e){var n="object"==typeof window&&window||"object"==typeof self&&self;"undefined"!=typeof exports?e(exports):n&&(n.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return n.hljs}))}(function(a){var E=[],u=Object.keys,N={},g={},n=/^(no-?highlight|plain|text)$/i,R=/\blang(?:uage)?-([\w-]+)\b/i,t=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,r={case_insensitive:"cI",lexemes:"l",contains:"c",keywords:"k",subLanguage:"sL",className:"cN",begin:"b",beginKeywords:"bK",end:"e",endsWithParent:"eW",illegal:"i",excludeBegin:"eB",excludeEnd:"eE",returnBegin:"rB",returnEnd:"rE",relevance:"r",variants:"v",IDENT_RE:"IR",UNDERSCORE_IDENT_RE:"UIR",NUMBER_RE:"NR",C_NUMBER_RE:"CNR",BINARY_NUMBER_RE:"BNR",RE_STARTERS_RE:"RSR",BACKSLASH_ESCAPE:"BE",APOS_STRING_MODE:"ASM",QUOTE_STRING_MODE:"QSM",PHRASAL_WORDS_MODE:"PWM",C_LINE_COMMENT_MODE:"CLCM",C_BLOCK_COMMENT_MODE:"CBCM",HASH_COMMENT_MODE:"HCM",NUMBER_MODE:"NM",C_NUMBER_MODE:"CNM",BINARY_NUMBER_MODE:"BNM",CSS_NUMBER_MODE:"CSSNM",REGEXP_MODE:"RM",TITLE_MODE:"TM",UNDERSCORE_TITLE_MODE:"UTM",COMMENT:"C",beginRe:"bR",endRe:"eR",illegalRe:"iR",lexemesRe:"lR",terminators:"t",terminator_end:"tE"},b="</span>",h={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0};function _(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function d(e){return e.nodeName.toLowerCase()}function v(e,n){var t=e&&e.exec(n);return t&&0===t.index}function p(e){return n.test(e)}function l(e){var n,t={},r=Array.prototype.slice.call(arguments,1);for(n in e)t[n]=e[n];return r.forEach(function(e){for(n in e)t[n]=e[n]}),t}function M(e){var a=[];return function e(n,t){for(var r=n.firstChild;r;r=r.nextSibling)3===r.nodeType?t+=r.nodeValue.length:1===r.nodeType&&(a.push({event:"start",offset:t,node:r}),t=e(r,t),d(r).match(/br|hr|img|input/)||a.push({event:"stop",offset:t,node:r}));return t}(e,0),a}function i(e){if(r&&!e.langApiRestored){for(var n in e.langApiRestored=!0,r)e[n]&&(e[r[n]]=e[n]);(e.c||[]).concat(e.v||[]).forEach(i)}}function m(c){function s(e){return e&&e.source||e}function o(e,n){return new RegExp(s(e),"m"+(c.cI?"i":"")+(n?"g":""))}!function n(t,e){if(!t.compiled){if(t.compiled=!0,t.k=t.k||t.bK,t.k){var r={},a=function(t,e){c.cI&&(e=e.toLowerCase()),e.split(" ").forEach(function(e){var n=e.split("|");r[n[0]]=[t,n[1]?Number(n[1]):1]})};"string"==typeof t.k?a("keyword",t.k):u(t.k).forEach(function(e){a(e,t.k[e])}),t.k=r}t.lR=o(t.l||/\w+/,!0),e&&(t.bK&&(t.b="\\b("+t.bK.split(" ").join("|")+")\\b"),t.b||(t.b=/\B|\b/),t.bR=o(t.b),t.endSameAsBegin&&(t.e=t.b),t.e||t.eW||(t.e=/\B|\b/),t.e&&(t.eR=o(t.e)),t.tE=s(t.e)||"",t.eW&&e.tE&&(t.tE+=(t.e?"|":"")+e.tE)),t.i&&(t.iR=o(t.i)),null==t.r&&(t.r=1),t.c||(t.c=[]),t.c=Array.prototype.concat.apply([],t.c.map(function(e){return(n="self"===e?t:e).v&&!n.cached_variants&&(n.cached_variants=n.v.map(function(e){return l(n,{v:null},e)})),n.cached_variants||n.eW&&[l(n)]||[n];var n})),t.c.forEach(function(e){n(e,t)}),t.starts&&n(t.starts,e);var i=t.c.map(function(e){return e.bK?"\\.?(?:"+e.b+")\\.?":e.b}).concat([t.tE,t.i]).map(s).filter(Boolean);t.t=i.length?o(function(e,n){for(var t=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./,r=0,a="",i=0;i<e.length;i++){var c=r,o=s(e[i]);for(0<i&&(a+=n);0<o.length;){var u=t.exec(o);if(null==u){a+=o;break}a+=o.substring(0,u.index),o=o.substring(u.index+u[0].length),"\\"==u[0][0]&&u[1]?a+="\\"+String(Number(u[1])+c):(a+=u[0],"("==u[0]&&r++)}}return a}(i,"|"),!0):{exec:function(){return null}}}}(c)}function C(e,n,o,t){function u(e,n,t,r){var a='<span class="'+(r?"":h.classPrefix);return(a+=e+'">')+n+(t?"":b)}function s(){g+=null!=E.sL?function(){var e="string"==typeof E.sL;if(e&&!N[E.sL])return _(R);var n=e?C(E.sL,R,!0,i[E.sL]):O(R,E.sL.length?E.sL:void 0);return 0<E.r&&(d+=n.r),e&&(i[E.sL]=n.top),u(n.language,n.value,!1,!0)}():function(){var e,n,t,r,a,i,c;if(!E.k)return _(R);for(r="",n=0,E.lR.lastIndex=0,t=E.lR.exec(R);t;)r+=_(R.substring(n,t.index)),a=E,i=t,c=f.cI?i[0].toLowerCase():i[0],(e=a.k.hasOwnProperty(c)&&a.k[c])?(d+=e[1],r+=u(e[0],_(t[0]))):r+=_(t[0]),n=E.lR.lastIndex,t=E.lR.exec(R);return r+_(R.substr(n))}(),R=""}function l(e){g+=e.cN?u(e.cN,"",!0):"",E=Object.create(e,{parent:{value:E}})}function r(e,n){if(R+=e,null==n)return s(),0;var t=function(e,n){var t,r,a;for(t=0,r=n.c.length;t<r;t++)if(v(n.c[t].bR,e))return n.c[t].endSameAsBegin&&(n.c[t].eR=(a=n.c[t].bR.exec(e)[0],new RegExp(a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&"),"m"))),n.c[t]}(n,E);if(t)return t.skip?R+=n:(t.eB&&(R+=n),s(),t.rB||t.eB||(R=n)),l(t),t.rB?0:n.length;var r,a,i=function e(n,t){if(v(n.eR,t)){for(;n.endsParent&&n.parent;)n=n.parent;return n}if(n.eW)return e(n.parent,t)}(E,n);if(i){var c=E;for(c.skip?R+=n:(c.rE||c.eE||(R+=n),s(),c.eE&&(R=n));E.cN&&(g+=b),E.skip||E.sL||(d+=E.r),(E=E.parent)!==i.parent;);return i.starts&&(i.endSameAsBegin&&(i.starts.eR=i.eR),l(i.starts)),c.rE?0:n.length}if(r=n,a=E,!o&&v(a.iR,r))throw new Error('Illegal lexeme "'+n+'" for mode "'+(E.cN||"<unnamed>")+'"');return R+=n,n.length||1}var f=S(e);if(!f)throw new Error('Unknown language: "'+e+'"');m(f);var a,E=t||f,i={},g="";for(a=E;a!==f;a=a.parent)a.cN&&(g=u(a.cN,"",!0)+g);var R="",d=0;try{for(var c,p,M=0;E.t.lastIndex=M,c=E.t.exec(n);)p=r(n.substring(M,c.index),c[0]),M=c.index+p;for(r(n.substr(M)),a=E;a.parent;a=a.parent)a.cN&&(g+=b);return{r:d,value:g,language:e,top:E}}catch(e){if(e.message&&-1!==e.message.indexOf("Illegal"))return{r:0,value:_(n)};throw e}}function O(t,e){e=e||h.languages||u(N);var r={r:0,value:_(t)},a=r;return e.filter(S).filter(s).forEach(function(e){var n=C(e,t,!1);n.language=e,n.r>a.r&&(a=n),n.r>r.r&&(a=r,r=n)}),a.language&&(r.second_best=a),r}function B(e){return h.tabReplace||h.useBR?e.replace(t,function(e,n){return h.useBR&&"\n"===e?"<br>":h.tabReplace?n.replace(/\t/g,h.tabReplace):""}):e}function c(e){var n,t,r,a,i,c,o,u,s,l,f=function(e){var n,t,r,a,i=e.className+" ";if(i+=e.parentNode?e.parentNode.className:"",t=R.exec(i))return S(t[1])?t[1]:"no-highlight";for(n=0,r=(i=i.split(/\s+/)).length;n<r;n++)if(p(a=i[n])||S(a))return a}(e);p(f)||(h.useBR?(n=document.createElementNS("http://www.w3.org/1999/xhtml","div")).innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n"):n=e,i=n.textContent,r=f?C(f,i,!0):O(i),(t=M(n)).length&&((a=document.createElementNS("http://www.w3.org/1999/xhtml","div")).innerHTML=r.value,r.value=function(e,n,t){var r=0,a="",i=[];function c(){return e.length&&n.length?e[0].offset!==n[0].offset?e[0].offset<n[0].offset?e:n:"start"===n[0].event?e:n:e.length?e:n}function o(e){a+="<"+d(e)+E.map.call(e.attributes,function(e){return" "+e.nodeName+'="'+_(e.value).replace('"',"&quot;")+'"'}).join("")+">"}function u(e){a+="</"+d(e)+">"}function s(e){("start"===e.event?o:u)(e.node)}for(;e.length||n.length;){var l=c();if(a+=_(t.substring(r,l[0].offset)),r=l[0].offset,l===e){for(i.reverse().forEach(u);s(l.splice(0,1)[0]),(l=c())===e&&l.length&&l[0].offset===r;);i.reverse().forEach(o)}else"start"===l[0].event?i.push(l[0].node):i.pop(),s(l.splice(0,1)[0])}return a+_(t.substr(r))}(t,M(a),i)),r.value=B(r.value),e.innerHTML=r.value,e.className=(c=e.className,o=f,u=r.language,s=o?g[o]:u,l=[c.trim()],c.match(/\bhljs\b/)||l.push("hljs"),-1===c.indexOf(s)&&l.push(s),l.join(" ").trim()),e.result={language:r.language,re:r.r},r.second_best&&(e.second_best={language:r.second_best.language,re:r.second_best.r}))}function o(){if(!o.called){o.called=!0;var e=document.querySelectorAll("pre code");E.forEach.call(e,c)}}function S(e){return e=(e||"").toLowerCase(),N[e]||N[g[e]]}function s(e){var n=S(e);return n&&!n.disableAutodetect}return a.highlight=C,a.highlightAuto=O,a.fixMarkup=B,a.highlightBlock=c,a.configure=function(e){h=l(h,e)},a.initHighlighting=o,a.initHighlightingOnLoad=function(){addEventListener("DOMContentLoaded",o,!1),addEventListener("load",o,!1)},a.registerLanguage=function(n,e){var t=N[n]=e(a);i(t),t.aliases&&t.aliases.forEach(function(e){g[e]=n})},a.listLanguages=function(){return u(N)},a.getLanguage=S,a.autoDetection=s,a.inherit=l,a.IR=a.IDENT_RE="[a-zA-Z]\\w*",a.UIR=a.UNDERSCORE_IDENT_RE="[a-zA-Z_]\\w*",a.NR=a.NUMBER_RE="\\b\\d+(\\.\\d+)?",a.CNR=a.C_NUMBER_RE="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",a.BNR=a.BINARY_NUMBER_RE="\\b(0b[01]+)",a.RSR=a.RE_STARTERS_RE="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",a.BE=a.BACKSLASH_ESCAPE={b:"\\\\[\\s\\S]",r:0},a.ASM=a.APOS_STRING_MODE={cN:"string",b:"'",e:"'",i:"\\n",c:[a.BE]},a.QSM=a.QUOTE_STRING_MODE={cN:"string",b:'"',e:'"',i:"\\n",c:[a.BE]},a.PWM=a.PHRASAL_WORDS_MODE={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},a.C=a.COMMENT=function(e,n,t){var r=a.inherit({cN:"comment",b:e,e:n,c:[]},t||{});return r.c.push(a.PWM),r.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),r},a.CLCM=a.C_LINE_COMMENT_MODE=a.C("//","$"),a.CBCM=a.C_BLOCK_COMMENT_MODE=a.C("/\\*","\\*/"),a.HCM=a.HASH_COMMENT_MODE=a.C("#","$"),a.NM=a.NUMBER_MODE={cN:"number",b:a.NR,r:0},a.CNM=a.C_NUMBER_MODE={cN:"number",b:a.CNR,r:0},a.BNM=a.BINARY_NUMBER_MODE={cN:"number",b:a.BNR,r:0},a.CSSNM=a.CSS_NUMBER_MODE={cN:"number",b:a.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},a.RM=a.REGEXP_MODE={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[a.BE,{b:/\[/,e:/\]/,r:0,c:[a.BE]}]},a.TM=a.TITLE_MODE={cN:"title",b:a.IR,r:0},a.UTM=a.UNDERSCORE_TITLE_MODE={cN:"title",b:a.UIR,r:0},a.METHOD_GUARD={b:"\\.\\s*"+a.UIR,r:0},a});hljs.registerLanguage("json",function(e){var i={literal:"true false null"},n=[e.QSM,e.CNM],r={e:",",eW:!0,eE:!0,c:n,k:i},t={b:"{",e:"}",c:[{cN:"attr",b:/"/,e:/"/,c:[e.BE],i:"\\n"},e.inherit(r,{b:/:/})],i:"\\S"},c={b:"\\[",e:"\\]",c:[e.inherit(r)],i:"\\S"};return n.splice(n.length,0,t,c),{c:n,k:i,i:"\\S"}});hljs.registerLanguage("coffeescript",function(e){var c={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super yield import export from as default await then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",built_in:"npm require console print module global window document"},n="[A-Za-z$_][0-9A-Za-z$_]*",r={cN:"subst",b:/#\{/,e:/}/,k:c},i=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,r]},{b:/"/,e:/"/,c:[e.BE,r]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[r,e.HCM]},{b:"//[gim]*",r:0},{b:/\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/}]},{b:"@"+n},{sL:"javascript",eB:!0,eE:!0,v:[{b:"```",e:"```"},{b:"`",e:"`"}]}];r.c=i;var s=e.inherit(e.TM,{b:n}),t="(\\(.*\\))?\\s*\\B[-=]>",o={cN:"params",b:"\\([^\\(]",rB:!0,c:[{b:/\(/,e:/\)/,k:c,c:["self"].concat(i)}]};return{aliases:["coffee","cson","iced"],k:c,i:/\/\*/,c:i.concat([e.C("###","###"),e.HCM,{cN:"function",b:"^\\s*"+n+"\\s*=\\s*"+t,e:"[-=]>",rB:!0,c:[s,o]},{b:/[:\(,=]\s*/,r:0,c:[{cN:"function",b:t,e:"[-=]>",rB:!0,c:[o]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[s]},s]},{b:n+":",e:":",rB:!0,rE:!0,r:0}])}});hljs.registerLanguage("properties",function(r){var t="[ \\t\\f]*",e="("+t+"[:=]"+t+"|[ \\t\\f]+)",s="([^\\\\\\W:= \\t\\f\\n]|\\\\.)+",n="([^\\\\:= \\t\\f\\n]|\\\\.)+",a={e:e,r:0,starts:{cN:"string",e:/$/,r:0,c:[{b:"\\\\\\n"}]}};return{cI:!0,i:/\S/,c:[r.C("^\\s*[!#]","$"),{b:s+e,rB:!0,c:[{cN:"attr",b:s,endsParent:!0,r:0}],starts:a},{b:n+e,rB:!0,r:0,c:[{cN:"meta",b:n,endsParent:!0,r:0}],starts:a},{cN:"attr",r:0,b:n+t+"$"}]}});hljs.registerLanguage("typescript",function(e){var r="[A-Za-z$_][0-9A-Za-z$_]*",t={keyword:"in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const class public private protected get set super static implements enum export import declare type namespace abstract as from extends async await",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document any number boolean string void Promise"},n={cN:"meta",b:"@"+r},a={b:"\\(",e:/\)/,k:t,c:["self",e.QSM,e.ASM,e.NM]},o={cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,c:[e.CLCM,e.CBCM,n,a]};return{aliases:["ts"],k:t,c:[{cN:"meta",b:/^\s*['"]use strict['"]/},e.ASM,e.QSM,{cN:"string",b:"`",e:"`",c:[e.BE,{cN:"subst",b:"\\$\\{",e:"\\}"}]},e.CLCM,e.CBCM,{cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{cN:"function",b:"(\\(.*?\\)|"+e.IR+")\\s*=>",rB:!0,e:"\\s*=>",c:[{cN:"params",v:[{b:e.IR},{b:/\(\s*\)/},{b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,c:["self",e.CLCM,e.CBCM]}]}]}],r:0},{cN:"function",b:"function",e:/[\{;]/,eE:!0,k:t,c:["self",e.inherit(e.TM,{b:r}),o],i:/%/,r:0},{bK:"constructor",e:/\{/,eE:!0,c:["self",o]},{b:/module\./,k:{built_in:"module"},r:0},{bK:"module",e:/\{/,eE:!0},{bK:"interface",e:/\{/,eE:!0,k:"interface extends"},{b:/\$[(.]/},{b:"\\."+e.IR,r:0},n,a]}});hljs.registerLanguage("rust",function(e){var t="([ui](8|16|32|64|128|size)|f(32|64))?",r="drop i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize f32 f64 str char bool Box Option Result String Vec Copy Send Sized Sync Drop Fn FnMut FnOnce ToOwned Clone Debug PartialEq PartialOrd Eq Ord AsRef AsMut Into From Default Iterator Extend IntoIterator DoubleEndedIterator ExactSizeIterator SliceConcatExt ToString assert! assert_eq! bitflags! bytes! cfg! col! concat! concat_idents! debug_assert! debug_assert_eq! env! panic! file! format! format_args! include_bin! include_str! line! local_data_key! module_path! option_env! print! println! select! stringify! try! unimplemented! unreachable! vec! write! writeln! macro_rules! assert_ne! debug_assert_ne!";return{aliases:["rs"],k:{keyword:"alignof as be box break const continue crate do else enum extern false fn for if impl in let loop match mod mut offsetof once priv proc pub pure ref return self Self sizeof static struct super trait true type typeof unsafe unsized use virtual while where yield move default",literal:"true false Some None Ok Err",built_in:r},l:e.IR+"!?",i:"</",c:[e.CLCM,e.C("/\\*","\\*/",{c:["self"]}),e.inherit(e.QSM,{b:/b?"/,i:null}),{cN:"string",v:[{b:/r(#*)"(.|\n)*?"\1(?!#)/},{b:/b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/}]},{cN:"symbol",b:/'[a-zA-Z_][a-zA-Z0-9_]*/},{cN:"number",v:[{b:"\\b0b([01_]+)"+t},{b:"\\b0o([0-7_]+)"+t},{b:"\\b0x([A-Fa-f0-9_]+)"+t},{b:"\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)"+t}],r:0},{cN:"function",bK:"fn",e:"(\\(|<)",eE:!0,c:[e.UTM]},{cN:"meta",b:"#\\!?\\[",e:"\\]",c:[{cN:"meta-string",b:/"/,e:/"/}]},{cN:"class",bK:"type",e:";",c:[e.inherit(e.UTM,{endsParent:!0})],i:"\\S"},{cN:"class",bK:"trait enum struct union",e:"{",c:[e.inherit(e.UTM,{endsParent:!0})],i:"[\\w\\d]"},{b:e.IR+"::",k:{built_in:r}},{b:"->"}]}});hljs.registerLanguage("http",function(e){var t="HTTP/[0-9\\.]+";return{aliases:["https"],i:"\\S",c:[{b:"^"+t,e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{b:"^[A-Z]+ (.*?) "+t+"$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0},{b:t},{cN:"keyword",b:"[A-Z]+"}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{e:"$",r:0}},{b:"\\n\\n",starts:{sL:[],eW:!0}}]}});hljs.registerLanguage("kotlin",function(e){var t={keyword:"abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual trait volatile transient native default",built_in:"Byte Short Char Int Long Boolean Float Double Void Unit Nothing",literal:"true false null"},r={cN:"symbol",b:e.UIR+"@"},a={cN:"subst",b:"\\${",e:"}",c:[e.ASM,e.CNM]},i={cN:"variable",b:"\\$"+e.UIR},n={cN:"string",v:[{b:'"""',e:'"""',c:[i,a]},{b:"'",e:"'",i:/\n/,c:[e.BE]},{b:'"',e:'"',i:/\n/,c:[e.BE,i,a]}]},c={cN:"meta",b:"@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*"+e.UIR+")?"},s={cN:"meta",b:"@"+e.UIR,c:[{b:/\(/,e:/\)/,c:[e.inherit(n,{cN:"meta-string"})]}]},l={cN:"number",b:"\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",r:0};return{aliases:["kt"],k:t,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,{cN:"keyword",b:/\b(break|continue|return|this)\b/,starts:{c:[{cN:"symbol",b:/@\w+/}]}},r,c,s,{cN:"function",bK:"fun",e:"[(]|$",rB:!0,eE:!0,k:t,i:/fun\s+(<.*>)?[^\s\(]+(\s+[^\s\(]+)\s*=/,r:5,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"type",b:/</,e:/>/,k:"reified",r:0},{cN:"params",b:/\(/,e:/\)/,endsParent:!0,k:t,r:0,c:[{b:/:/,e:/[=,\/]/,eW:!0,c:[{cN:"type",b:e.UIR},e.CLCM,e.CBCM],r:0},e.CLCM,e.CBCM,c,s,n,e.CNM]},e.CBCM]},{cN:"class",bK:"class interface trait",e:/[:\{(]|$/,eE:!0,i:"extends implements",c:[{bK:"public protected internal private constructor"},e.UTM,{cN:"type",b:/</,e:/>/,eB:!0,eE:!0,r:0},{cN:"type",b:/[,:]\s*/,e:/[<\(,]|$/,eB:!0,rE:!0},c,s]},n,{cN:"meta",b:"^#!/usr/bin/env",e:"$",i:"\n"},l]}});hljs.registerLanguage("gradle",function(e){return{cI:!0,k:{keyword:"task project allprojects subprojects artifacts buildscript configurations dependencies repositories sourceSets description delete from into include exclude source classpath destinationDir includes options sourceCompatibility targetCompatibility group flatDir doLast doFirst flatten todir fromdir ant def abstract break case catch continue default do else extends final finally for if implements instanceof native new private protected public return static switch synchronized throw throws transient try volatile while strictfp package import false null super this true antlrtask checkstyle codenarc copy boolean byte char class double float int interface long short void compile runTime file fileTree abs any append asList asWritable call collect compareTo count div dump each eachByte eachFile eachLine every find findAll flatten getAt getErr getIn getOut getText grep immutable inject inspect intersect invokeMethods isCase join leftShift minus multiply newInputStream newOutputStream newPrintWriter newReader newWriter next plus pop power previous print println push putAt read readBytes readLines reverse reverseEach round size sort splitEachLine step subMap times toInteger toList tokenize upto waitForOrKill withPrintWriter withReader withStream withWriter withWriterAppend write writeLine"},c:[e.CLCM,e.CBCM,e.ASM,e.QSM,e.NM,e.RM]}});hljs.registerLanguage("xml",function(s){var e={eW:!0,i:/</,r:0,c:[{cN:"attr",b:"[A-Za-z0-9\\._:-]+",r:0},{b:/=\s*/,r:0,c:[{cN:"string",endsParent:!0,v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s"'=<>`]+/}]}]}]};return{aliases:["html","xhtml","rss","atom","xjb","xsd","xsl","plist"],cI:!0,c:[{cN:"meta",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},s.C("\x3c!--","--\x3e",{r:10}),{b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"meta",b:/<\?xml/,e:/\?>/,r:10},{b:/<\?(php)?/,e:/\?>/,sL:"php",c:[{b:"/\\*",e:"\\*/",skip:!0},{b:'b"',e:'"',skip:!0},{b:"b'",e:"'",skip:!0},s.inherit(s.ASM,{i:null,cN:null,c:null,skip:!0}),s.inherit(s.QSM,{i:null,cN:null,c:null,skip:!0})]},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{name:"style"},c:[e],starts:{e:"</style>",rE:!0,sL:["css","xml"]}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{name:"script"},c:[e],starts:{e:"<\/script>",rE:!0,sL:["actionscript","javascript","handlebars","xml"]}},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"name",b:/[^\/><\s]+/,r:0},e]}]}});hljs.registerLanguage("asciidoc",function(e){return{aliases:["adoc"],c:[e.C("^/{4,}\\n","\\n/{4,}$",{r:10}),e.C("^//","$",{r:0}),{cN:"title",b:"^\\.\\w.*$"},{b:"^[=\\*]{4,}\\n",e:"\\n^[=\\*]{4,}$",r:10},{cN:"section",r:10,v:[{b:"^(={1,5}) .+?( \\1)?$"},{b:"^[^\\[\\]\\n]+?\\n[=\\-~\\^\\+]{2,}$"}]},{cN:"meta",b:"^:.+?:",e:"\\s",eE:!0,r:10},{cN:"meta",b:"^\\[.+?\\]$",r:0},{cN:"quote",b:"^_{4,}\\n",e:"\\n_{4,}$",r:10},{cN:"code",b:"^[\\-\\.]{4,}\\n",e:"\\n[\\-\\.]{4,}$",r:10},{b:"^\\+{4,}\\n",e:"\\n\\+{4,}$",c:[{b:"<",e:">",sL:"xml",r:0}],r:10},{cN:"bullet",b:"^(\\*+|\\-+|\\.+|[^\\n]+?::)\\s+"},{cN:"symbol",b:"^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):\\s+",r:10},{cN:"strong",b:"\\B\\*(?![\\*\\s])",e:"(\\n{2}|\\*)",c:[{b:"\\\\*\\w",r:0}]},{cN:"emphasis",b:"\\B'(?!['\\s])",e:"(\\n{2}|')",c:[{b:"\\\\'\\w",r:0}],r:0},{cN:"emphasis",b:"_(?![_\\s])",e:"(\\n{2}|_)",r:0},{cN:"string",v:[{b:"``.+?''"},{b:"`.+?'"}]},{cN:"code",b:"(`.+?`|\\+.+?\\+)",r:0},{cN:"code",b:"^[ \\t]",e:"$",r:0},{b:"^'{3,}[ \\t]*$",r:10},{b:"(link:)?(http|https|ftp|file|irc|image:?):\\S+\\[.*?\\]",rB:!0,c:[{b:"(link|image:?):",r:0},{cN:"link",b:"\\w",e:"[^\\[]+",r:0},{cN:"string",b:"\\[",e:"\\]",eB:!0,eE:!0,r:0}],r:10}]}});hljs.registerLanguage("erlang-repl",function(e){return{k:{built_in:"spawn spawn_link self",keyword:"after and andalso|10 band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse|10 query receive rem try when xor"},c:[{cN:"meta",b:"^[0-9]+> ",r:10},e.C("%","$"),{cN:"number",b:"\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)",r:0},e.ASM,e.QSM,{b:"\\?(::)?([A-Z]\\w*(::)?)+"},{b:"->"},{b:"ok"},{b:"!"},{b:"(\\b[a-z'][a-zA-Z0-9_']*:[a-z'][a-zA-Z0-9_']*)|(\\b[a-z'][a-zA-Z0-9_']*)",r:0},{b:"[A-Z][a-zA-Z0-9_']*",r:0}]}});hljs.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},s={b:"->{",e:"}"},n={v:[{b:/\$\d/},{b:/[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/},{b:/[\$%@][^\s\w{]/,r:0}]},i=[e.BE,r,n],o=[n,e.HCM,e.C("^\\=\\w","\\=cut",{eW:!0}),s,{cN:"string",c:i,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"function",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",eE:!0,r:5,c:[e.TM]},{b:"-\\w\\b",r:0},{b:"^__DATA__$",e:"^__END__$",sL:"mojolicious",c:[{b:"^@@.*",e:"$",cN:"comment"}]}];return r.c=o,{aliases:["pl","pm"],l:/[\w\.]+/,k:t,c:s.c=o}});hljs.registerLanguage("cpp",function(t){var e={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[{b:'(u8?|U|L)?"',e:'"',i:"\\n",c:[t.BE]},{b:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\((?:.|\n)*?\)\1"/},{b:"'\\\\?.",e:"'",i:"."}]},s={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},i={cN:"meta",b:/#\s*[a-z]+\b/,e:/$/,k:{"meta-keyword":"if else elif endif define undef warning error line pragma ifdef ifndef include"},c:[{b:/\\\n/,r:0},t.inherit(r,{cN:"meta-string"}),{cN:"meta-string",b:/<[^\n>]*>/,e:/$/,i:"\\n"},t.CLCM,t.CBCM]},a=t.IR+"\\s*\\(",c={keyword:"int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and or not",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",literal:"true false nullptr NULL"},n=[e,t.CLCM,t.CBCM,s,r];return{aliases:["c","cc","h","c++","h++","hpp"],k:c,i:"</",c:n.concat([i,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:c,c:["self",e]},{b:t.IR+"::",k:c},{v:[{b:/=/,e:/;/},{b:/\(/,e:/\)/},{bK:"new throw return else",e:/;/}],k:c,c:n.concat([{b:/\(/,e:/\)/,k:c,c:n.concat(["self"]),r:0}]),r:0},{cN:"function",b:"("+t.IR+"[\\*&\\s]+)+"+a,rB:!0,e:/[{;=]/,eE:!0,k:c,i:/[^\w\s\*&]/,c:[{b:a,rB:!0,c:[t.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:c,r:0,c:[t.CLCM,t.CBCM,r,s,e,{b:/\(/,e:/\)/,k:c,r:0,c:["self",t.CLCM,t.CBCM,r,s,e]}]},t.CLCM,t.CBCM,i]},{cN:"class",bK:"class struct",e:/[{;:]/,c:[{b:/</,e:/>/,c:["self"]},t.TM]}]),exports:{preprocessor:i,strings:r,k:c}}});hljs.registerLanguage("arduino",function(e){var t=e.getLanguage("cpp").exports;return{k:{keyword:"boolean byte word string String array "+t.k.keyword,built_in:"setup loop while catch for if do goto try switch case else default break continue return KeyboardController MouseController SoftwareSerial EthernetServer EthernetClient LiquidCrystal RobotControl GSMVoiceCall EthernetUDP EsploraTFT HttpClient RobotMotor WiFiClient GSMScanner FileSystem Scheduler GSMServer YunClient YunServer IPAddress GSMClient GSMModem Keyboard Ethernet Console GSMBand Esplora Stepper Process WiFiUDP GSM_SMS Mailbox USBHost Firmata PImage Client Server GSMPIN FileIO Bridge Serial EEPROM Stream Mouse Audio Servo File Task GPRS WiFi Wire TFT GSM SPI SD runShellCommandAsynchronously analogWriteResolution retrieveCallingNumber printFirmwareVersion analogReadResolution sendDigitalPortPair noListenOnLocalhost readJoystickButton setFirmwareVersion readJoystickSwitch scrollDisplayRight getVoiceCallStatus scrollDisplayLeft writeMicroseconds delayMicroseconds beginTransmission getSignalStrength runAsynchronously getAsynchronously listenOnLocalhost getCurrentCarrier readAccelerometer messageAvailable sendDigitalPorts lineFollowConfig countryNameWrite runShellCommand readStringUntil rewindDirectory readTemperature setClockDivider readLightSensor endTransmission analogReference detachInterrupt countryNameRead attachInterrupt encryptionType readBytesUntil robotNameWrite readMicrophone robotNameRead cityNameWrite userNameWrite readJoystickY readJoystickX mouseReleased openNextFile scanNetworks noInterrupts digitalWrite beginSpeaker mousePressed isActionDone mouseDragged displayLogos noAutoscroll addParameter remoteNumber getModifiers keyboardRead userNameRead waitContinue processInput parseCommand printVersion readNetworks writeMessage blinkVersion cityNameRead readMessage setDataMode parsePacket isListening setBitOrder beginPacket isDirectory motorsWrite drawCompass digitalRead clearScreen serialEvent rightToLeft setTextSize leftToRight requestFrom keyReleased compassRead analogWrite interrupts WiFiServer disconnect playMelody parseFloat autoscroll getPINUsed setPINUsed setTimeout sendAnalog readSlider analogRead beginWrite createChar motorsStop keyPressed tempoWrite readButton subnetMask debugPrint macAddress writeGreen randomSeed attachGPRS readString sendString remotePort releaseAll mouseMoved background getXChange getYChange answerCall getResult voiceCall endPacket constrain getSocket writeJSON getButton available connected findUntil readBytes exitValue readGreen writeBlue startLoop IPAddress isPressed sendSysex pauseMode gatewayIP setCursor getOemKey tuneWrite noDisplay loadImage switchPIN onRequest onReceive changePIN playFile noBuffer parseInt overflow checkPIN knobRead beginTFT bitClear updateIR bitWrite position writeRGB highByte writeRed setSpeed readBlue noStroke remoteIP transfer shutdown hangCall beginSMS endWrite attached maintain noCursor checkReg checkPUK shiftOut isValid shiftIn pulseIn connect println localIP pinMode getIMEI display noBlink process getBand running beginSD drawBMP lowByte setBand release bitRead prepare pointTo readRed setMode noFill remove listen stroke detach attach noTone exists buffer height bitSet circle config cursor random IRread setDNS endSMS getKey micros millis begin print write ready flush width isPIN blink clear press mkdir rmdir close point yield image BSSID click delay read text move peek beep rect line open seek fill size turn stop home find step tone sqrt RSSI SSID end bit tan cos sin pow map abs max min get run put",literal:"DIGITAL_MESSAGE FIRMATA_STRING ANALOG_MESSAGE REPORT_DIGITAL REPORT_ANALOG INPUT_PULLUP SET_PIN_MODE INTERNAL2V56 SYSTEM_RESET LED_BUILTIN INTERNAL1V1 SYSEX_START INTERNAL EXTERNAL DEFAULT OUTPUT INPUT HIGH LOW"},c:[t.preprocessor,e.CLCM,e.CBCM,e.ASM,e.QSM,e.CNM]}});hljs.registerLanguage("apache",function(e){var r={cN:"number",b:"[\\$%]\\d+"};return{aliases:["apacheconf"],cI:!0,c:[e.HCM,{cN:"section",b:"</?",e:">"},{cN:"attribute",b:/\w+/,r:0,k:{nomarkup:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"meta",b:"\\s\\[",e:"\\]$"},{cN:"variable",b:"[\\$%]\\{",e:"\\}",c:["self",r]},r,e.QSM]}}],i:/\S/}});hljs.registerLanguage("cmake",function(e){return{aliases:["cmake.in"],cI:!0,k:{keyword:"break cmake_host_system_information cmake_minimum_required cmake_parse_arguments cmake_policy configure_file continue elseif else endforeach endfunction endif endmacro endwhile execute_process file find_file find_library find_package find_path find_program foreach function get_cmake_property get_directory_property get_filename_component get_property if include include_guard list macro mark_as_advanced math message option return separate_arguments set_directory_properties set_property set site_name string unset variable_watch while add_compile_definitions add_compile_options add_custom_command add_custom_target add_definitions add_dependencies add_executable add_library add_link_options add_subdirectory add_test aux_source_directory build_command create_test_sourcelist define_property enable_language enable_testing export fltk_wrap_ui get_source_file_property get_target_property get_test_property include_directories include_external_msproject include_regular_expression install link_directories link_libraries load_cache project qt_wrap_cpp qt_wrap_ui remove_definitions set_source_files_properties set_target_properties set_tests_properties source_group target_compile_definitions target_compile_features target_compile_options target_include_directories target_link_directories target_link_libraries target_link_options target_sources try_compile try_run ctest_build ctest_configure ctest_coverage ctest_empty_binary_directory ctest_memcheck ctest_read_custom_files ctest_run_script ctest_sleep ctest_start ctest_submit ctest_test ctest_update ctest_upload build_name exec_program export_library_dependencies install_files install_programs install_targets load_command make_directory output_required_files remove subdir_depends subdirs use_mangled_mesa utility_source variable_requires write_file qt5_use_modules qt5_use_package qt5_wrap_cpp on off true false and or not command policy target test exists is_newer_than is_directory is_symlink is_absolute matches less greater equal less_equal greater_equal strless strgreater strequal strless_equal strgreater_equal version_less version_greater version_equal version_less_equal version_greater_equal in_list defined"},c:[{cN:"variable",b:"\\${",e:"}"},e.HCM,e.QSM,e.NM]}});hljs.registerLanguage("markdown",function(e){return{aliases:["md","mkdown","mkd"],c:[{cN:"section",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"quote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"^```w*s*$",e:"^```s*$"},{b:"`.+?`"},{b:"^( {4}|\t)",e:"$",r:0}]},{b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].*?[\\)\\]]",rB:!0,c:[{cN:"string",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"symbol",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:/^\[[^\n]+\]:/,rB:!0,c:[{cN:"symbol",b:/\[/,e:/\]/,eB:!0,eE:!0},{cN:"link",b:/:\s*/,e:/$/,eB:!0}]}]}});hljs.registerLanguage("diff",function(e){return{aliases:["patch"],c:[{cN:"meta",r:10,v:[{b:/^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"comment",v:[{b:/Index: /,e:/$/},{b:/={3,}/,e:/$/},{b:/^\-{3}/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+{3}/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"addition",b:"^\\!",e:"$"}]}});hljs.registerLanguage("java",function(e){var a="false synchronized int abstract float private char boolean var static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private module requires exports do",t={cN:"number",b:"\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",r:0};return{aliases:["jsp"],k:a,i:/<\/|#/,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{b:/\w+@/,r:0},{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:"class",bK:"class interface",e:/[{;=]/,eE:!0,k:"class interface",i:/[:"\[\]]/,c:[{bK:"extends implements"},e.UTM]},{bK:"new throw return else",r:0},{cN:"function",b:"([À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*(<[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*(\\s*,\\s*[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*)*>)?\\s+)+"+e.UIR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:a,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"params",b:/\(/,e:/\)/,k:a,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},t,{cN:"meta",b:"@[A-Za-z]+"}]}});hljs.registerLanguage("sql",function(e){var t=e.C("--","$");return{cI:!0,i:/[<>{}*]/,c:[{bK:"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke comment values with",e:/;/,eW:!0,l:/[\w\.]+/,k:{keyword:"as abort abs absolute acc acce accep accept access accessed accessible account acos action activate add addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias all allocate allow alter always analyze ancillary and anti any anydata anydataset anyschema anytype apply archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound bucket buffer_cache buffer_pool build bulk by byte byteordermark bytes cache caching call calling cancel capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base char_length character_length characters characterset charindex charset charsetform charsetid check checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation collect colu colum column column_value columns columns_updated comment commit compact compatibility compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection consider consistent constant constraint constraints constructor container content contents context contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime customdatum cycle data database databases datafile datafiles datalength date_add date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor deterministic diagnostics difference dimension direct_load directory disable disable_all disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div do document domain dotnet double downgrade drop dumpfile duplicate duration each edition editionable editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding execu execut execute exempt exists exit exp expire explain explode export export_set extended extent external external_1 external_2 externally extract failed failed_login_attempts failover failure far fast feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final finish first first_value fixed flash_cache flashback floor flush following follows for forall force foreign form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ftp full function general generated get get_format get_lock getdate getutcdate global global_name globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex hierarchy high high_priority hosts hour hours http id ident_current ident_incr ident_seed identified identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile initial initialized initially initrans inmemory inner innodb input insert install instance instantiable instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists keep keep_duplicates key keys kill language large last last_day last_insert_id last_value lateral lax lcase lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call logoff logon logs long loop low low_priority lower lpad lrtrim ltrim main make_set makedate maketime managed management manual map mapping mask master master_pos_wait match matched materialized max maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans md5 measures median medium member memcompress memory merge microsecond mid migration min minextents minimum mining minus minute minutes minvalue missing mod mode model modification modify module monitoring month months mount move movement multiset mutex name name_const names nan national native natural nav nchar nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck noswitch not nothing notice notnull notrim novalidate now nowait nth_value nullif nulls num numb numbe nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary out outer outfile outline output over overflow overriding package pad parallel parallel_enable parameters parent parse partial partition partitions pascal passing password password_grace_time password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction prediction_cost prediction_details prediction_probability prediction_set prepare present preserve prior priority private private_sga privileges procedural procedure procedure_analyze processlist profiles project prompt protection public publishingservername purge quarter query quick quiesce quota quotename radians raise rand range rank raw read reads readsize rebuild record records recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename repair repeat replace replicate replication required reset resetlogs resize resource respect restore restricted result result_cache resumable resume retention return returning returns reuse reverse revoke right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll sdo_georaster sdo_topo_geometry search sec_to_time second seconds section securefile security seed segment select self semi sequence sequential serializable server servererror session session_user sessions_per_user set sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone standby start starting startup statement static statistics stats_binomial_test stats_crosstab stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime table tables tablespace tablesample tan tdo template temporary terminated tertiary_weights test than then thread through tier ties time time_format time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unnest unpivot unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear wellformed when whene whenev wheneve whenever where while whitespace window with within without work wrapped xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek",literal:"true false null unknown",built_in:"array bigint binary bit blob bool boolean char character date dec decimal float int int8 integer interval number numeric real record serial serial8 smallint text time timestamp tinyint varchar varying void"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM,e.CBCM,t,e.HCM]},e.CBCM,t,e.HCM]}});hljs.registerLanguage("armasm",function(s){return{cI:!0,aliases:["arm"],l:"\\.?"+s.IR,k:{meta:".2byte .4byte .align .ascii .asciz .balign .byte .code .data .else .end .endif .endm .endr .equ .err .exitm .extern .global .hword .if .ifdef .ifndef .include .irp .long .macro .rept .req .section .set .skip .space .text .word .arm .thumb .code16 .code32 .force_thumb .thumb_func .ltorg ALIAS ALIGN ARM AREA ASSERT ATTR CN CODE CODE16 CODE32 COMMON CP DATA DCB DCD DCDU DCDO DCFD DCFDU DCI DCQ DCQU DCW DCWU DN ELIF ELSE END ENDFUNC ENDIF ENDP ENTRY EQU EXPORT EXPORTAS EXTERN FIELD FILL FUNCTION GBLA GBLL GBLS GET GLOBAL IF IMPORT INCBIN INCLUDE INFO KEEP LCLA LCLL LCLS LTORG MACRO MAP MEND MEXIT NOFP OPT PRESERVE8 PROC QN READONLY RELOC REQUIRE REQUIRE8 RLIST FN ROUT SETA SETL SETS SN SPACE SUBT THUMB THUMBX TTL WHILE WEND ",built_in:"r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 pc lr sp ip sl sb fp a1 a2 a3 a4 v1 v2 v3 v4 v5 v6 v7 v8 f0 f1 f2 f3 f4 f5 f6 f7 p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 cpsr_c cpsr_x cpsr_s cpsr_f cpsr_cx cpsr_cxs cpsr_xs cpsr_xsf cpsr_sf cpsr_cxsf spsr_c spsr_x spsr_s spsr_f spsr_cx spsr_cxs spsr_xs spsr_xsf spsr_sf spsr_cxsf s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 {PC} {VAR} {TRUE} {FALSE} {OPT} {CONFIG} {ENDIAN} {CODESIZE} {CPU} {FPU} {ARCHITECTURE} {PCSTOREOFFSET} {ARMASM_VERSION} {INTER} {ROPI} {RWPI} {SWST} {NOSWST} . @"},c:[{cN:"keyword",b:"\\b(adc|(qd?|sh?|u[qh]?)?add(8|16)?|usada?8|(q|sh?|u[qh]?)?(as|sa)x|and|adrl?|sbc|rs[bc]|asr|b[lx]?|blx|bxj|cbn?z|tb[bh]|bic|bfc|bfi|[su]bfx|bkpt|cdp2?|clz|clrex|cmp|cmn|cpsi[ed]|cps|setend|dbg|dmb|dsb|eor|isb|it[te]{0,3}|lsl|lsr|ror|rrx|ldm(([id][ab])|f[ds])?|ldr((s|ex)?[bhd])?|movt?|mvn|mra|mar|mul|[us]mull|smul[bwt][bt]|smu[as]d|smmul|smmla|mla|umlaal|smlal?([wbt][bt]|d)|mls|smlsl?[ds]|smc|svc|sev|mia([bt]{2}|ph)?|mrr?c2?|mcrr2?|mrs|msr|orr|orn|pkh(tb|bt)|rbit|rev(16|sh)?|sel|[su]sat(16)?|nop|pop|push|rfe([id][ab])?|stm([id][ab])?|str(ex)?[bhd]?|(qd?)?sub|(sh?|q|u[qh]?)?sub(8|16)|[su]xt(a?h|a?b(16)?)|srs([id][ab])?|swpb?|swi|smi|tst|teq|wfe|wfi|yield)(eq|ne|cs|cc|mi|pl|vs|vc|hi|ls|ge|lt|gt|le|al|hs|lo)?[sptrx]?",e:"\\s"},s.C("[;@]","$",{r:0}),s.CBCM,s.QSM,{cN:"string",b:"'",e:"[^\\\\]'",r:0},{cN:"title",b:"\\|",e:"\\|",i:"\\n",r:0},{cN:"number",v:[{b:"[#$=]?0x[0-9a-f]+"},{b:"[#$=]?0b[01]+"},{b:"[#$=]\\d+"},{b:"\\b\\d+"}],r:0},{cN:"symbol",v:[{b:"^[a-z_\\.\\$][a-z0-9_\\.\\$]+"},{b:"^\\s*[a-z_\\.\\$][a-z0-9_\\.\\$]+:"},{b:"[=#]\\w+"}],r:0}]}});hljs.registerLanguage("go",function(e){var t={keyword:"break default func interface select case map struct chan else goto package switch const fallthrough if range type continue for import return var go defer bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 uint16 uint32 uint64 int uint uintptr rune",literal:"true false iota nil",built_in:"append cap close complex copy imag len make new panic print println real recover delete"};return{aliases:["golang"],k:t,i:"</",c:[e.CLCM,e.CBCM,{cN:"string",v:[e.QSM,{b:"'",e:"[^\\\\]'"},{b:"`",e:"`"}]},{cN:"number",v:[{b:e.CNR+"[dflsi]",r:1},e.CNM]},{b:/:=/},{cN:"function",bK:"func",e:/\s*\{/,eE:!0,c:[e.TM,{cN:"params",b:/\(/,e:/\)/,k:t,i:/["']/}]}]}});hljs.registerLanguage("mathematica",function(e){return{aliases:["mma"],l:"(\\$|\\b)"+e.IR+"\\b",k:"AbelianGroup Abort AbortKernels AbortProtect Above Abs Absolute AbsoluteCorrelation AbsoluteCorrelationFunction AbsoluteCurrentValue AbsoluteDashing AbsoluteFileName AbsoluteOptions AbsolutePointSize AbsoluteThickness AbsoluteTime AbsoluteTiming AccountingForm Accumulate Accuracy AccuracyGoal ActionDelay ActionMenu ActionMenuBox ActionMenuBoxOptions Active ActiveItem ActiveStyle AcyclicGraphQ AddOnHelpPath AddTo AdjacencyGraph AdjacencyList AdjacencyMatrix AdjustmentBox AdjustmentBoxOptions AdjustTimeSeriesForecast AffineTransform After AiryAi AiryAiPrime AiryAiZero AiryBi AiryBiPrime AiryBiZero AlgebraicIntegerQ AlgebraicNumber AlgebraicNumberDenominator AlgebraicNumberNorm AlgebraicNumberPolynomial AlgebraicNumberTrace AlgebraicRules AlgebraicRulesData Algebraics AlgebraicUnitQ Alignment AlignmentMarker AlignmentPoint All AllowedDimensions AllowGroupClose AllowInlineCells AllowKernelInitialization AllowReverseGroupClose AllowScriptLevelChange AlphaChannel AlternatingGroup AlternativeHypothesis Alternatives AmbientLight Analytic AnchoredSearch And AndersonDarlingTest AngerJ AngleBracket AngularGauge Animate AnimationCycleOffset AnimationCycleRepetitions AnimationDirection AnimationDisplayTime AnimationRate AnimationRepetitions AnimationRunning Animator AnimatorBox AnimatorBoxOptions AnimatorElements Annotation Annuity AnnuityDue Antialiasing Antisymmetric Apart ApartSquareFree Appearance AppearanceElements AppellF1 Append AppendTo Apply ArcCos ArcCosh ArcCot ArcCoth ArcCsc ArcCsch ArcSec ArcSech ArcSin ArcSinDistribution ArcSinh ArcTan ArcTanh Arg ArgMax ArgMin ArgumentCountQ ARIMAProcess ArithmeticGeometricMean ARMAProcess ARProcess Array ArrayComponents ArrayDepth ArrayFlatten ArrayPad ArrayPlot ArrayQ ArrayReshape ArrayRules Arrays Arrow Arrow3DBox ArrowBox Arrowheads AspectRatio AspectRatioFixed Assert Assuming Assumptions AstronomicalData Asynchronous AsynchronousTaskObject AsynchronousTasks AtomQ Attributes AugmentedSymmetricPolynomial AutoAction AutoDelete AutoEvaluateEvents AutoGeneratedPackage AutoIndent AutoIndentSpacings AutoItalicWords AutoloadPath AutoMatch Automatic AutomaticImageSize AutoMultiplicationSymbol AutoNumberFormatting AutoOpenNotebooks AutoOpenPalettes AutorunSequencing AutoScaling AutoScroll AutoSpacing AutoStyleOptions AutoStyleWords Axes AxesEdge AxesLabel AxesOrigin AxesStyle Axis BabyMonsterGroupB Back Background BackgroundTasksSettings Backslash Backsubstitution Backward Band BandpassFilter BandstopFilter BarabasiAlbertGraphDistribution BarChart BarChart3D BarLegend BarlowProschanImportance BarnesG BarOrigin BarSpacing BartlettHannWindow BartlettWindow BaseForm Baseline BaselinePosition BaseStyle BatesDistribution BattleLemarieWavelet Because BeckmannDistribution Beep Before Begin BeginDialogPacket BeginFrontEndInteractionPacket BeginPackage BellB BellY Below BenfordDistribution BeniniDistribution BenktanderGibratDistribution BenktanderWeibullDistribution BernoulliB BernoulliDistribution BernoulliGraphDistribution BernoulliProcess BernsteinBasis BesselFilterModel BesselI BesselJ BesselJZero BesselK BesselY BesselYZero Beta BetaBinomialDistribution BetaDistribution BetaNegativeBinomialDistribution BetaPrimeDistribution BetaRegularized BetweennessCentrality BezierCurve BezierCurve3DBox BezierCurve3DBoxOptions BezierCurveBox BezierCurveBoxOptions BezierFunction BilateralFilter Binarize BinaryFormat BinaryImageQ BinaryRead BinaryReadList BinaryWrite BinCounts BinLists Binomial BinomialDistribution BinomialProcess BinormalDistribution BiorthogonalSplineWavelet BipartiteGraphQ BirnbaumImportance BirnbaumSaundersDistribution BitAnd BitClear BitGet BitLength BitNot BitOr BitSet BitShiftLeft BitShiftRight BitXor Black BlackmanHarrisWindow BlackmanNuttallWindow BlackmanWindow Blank BlankForm BlankNullSequence BlankSequence Blend Block BlockRandom BlomqvistBeta BlomqvistBetaTest Blue Blur BodePlot BohmanWindow Bold Bookmarks Boole BooleanConsecutiveFunction BooleanConvert BooleanCountingFunction BooleanFunction BooleanGraph BooleanMaxterms BooleanMinimize BooleanMinterms Booleans BooleanTable BooleanVariables BorderDimensions BorelTannerDistribution Bottom BottomHatTransform BoundaryStyle Bounds Box BoxBaselineShift BoxData BoxDimensions Boxed Boxes BoxForm BoxFormFormatTypes BoxFrame BoxID BoxMargins BoxMatrix BoxRatios BoxRotation BoxRotationPoint BoxStyle BoxWhiskerChart Bra BracketingBar BraKet BrayCurtisDistance BreadthFirstScan Break Brown BrownForsytheTest BrownianBridgeProcess BrowserCategory BSplineBasis BSplineCurve BSplineCurve3DBox BSplineCurveBox BSplineCurveBoxOptions BSplineFunction BSplineSurface BSplineSurface3DBox BubbleChart BubbleChart3D BubbleScale BubbleSizes BulletGauge BusinessDayQ ButterflyGraph ButterworthFilterModel Button ButtonBar ButtonBox ButtonBoxOptions ButtonCell ButtonContents ButtonData ButtonEvaluator ButtonExpandable ButtonFrame ButtonFunction ButtonMargins ButtonMinHeight ButtonNote ButtonNotebook ButtonSource ButtonStyle ButtonStyleMenuListing Byte ByteCount ByteOrdering C CachedValue CacheGraphics CalendarData CalendarType CallPacket CanberraDistance Cancel CancelButton CandlestickChart Cap CapForm CapitalDifferentialD CardinalBSplineBasis CarmichaelLambda Cases Cashflow Casoratian Catalan CatalanNumber Catch CauchyDistribution CauchyWindow CayleyGraph CDF CDFDeploy CDFInformation CDFWavelet Ceiling Cell CellAutoOverwrite CellBaseline CellBoundingBox CellBracketOptions CellChangeTimes CellContents CellContext CellDingbat CellDynamicExpression CellEditDuplicate CellElementsBoundingBox CellElementSpacings CellEpilog CellEvaluationDuplicate CellEvaluationFunction CellEventActions CellFrame CellFrameColor CellFrameLabelMargins CellFrameLabels CellFrameMargins CellGroup CellGroupData CellGrouping CellGroupingRules CellHorizontalScrolling CellID CellLabel CellLabelAutoDelete CellLabelMargins CellLabelPositioning CellMargins CellObject CellOpen CellPrint CellProlog Cells CellSize CellStyle CellTags CellularAutomaton CensoredDistribution Censoring Center CenterDot CentralMoment CentralMomentGeneratingFunction CForm ChampernowneNumber ChanVeseBinarize Character CharacterEncoding CharacterEncodingsPath CharacteristicFunction CharacteristicPolynomial CharacterRange Characters ChartBaseStyle ChartElementData ChartElementDataFunction ChartElementFunction ChartElements ChartLabels ChartLayout ChartLegends ChartStyle Chebyshev1FilterModel Chebyshev2FilterModel ChebyshevDistance ChebyshevT ChebyshevU Check CheckAbort CheckAll Checkbox CheckboxBar CheckboxBox CheckboxBoxOptions ChemicalData ChessboardDistance ChiDistribution ChineseRemainder ChiSquareDistribution ChoiceButtons ChoiceDialog CholeskyDecomposition Chop Circle CircleBox CircleDot CircleMinus CirclePlus CircleTimes CirculantGraph CityData Clear ClearAll ClearAttributes ClearSystemCache ClebschGordan ClickPane Clip ClipboardNotebook ClipFill ClippingStyle ClipPlanes ClipRange Clock ClockGauge ClockwiseContourIntegral Close Closed CloseKernels ClosenessCentrality Closing ClosingAutoSave ClosingEvent ClusteringComponents CMYKColor Coarse Coefficient CoefficientArrays CoefficientDomain CoefficientList CoefficientRules CoifletWavelet Collect Colon ColonForm ColorCombine ColorConvert ColorData ColorDataFunction ColorFunction ColorFunctionScaling Colorize ColorNegate ColorOutput ColorProfileData ColorQuantize ColorReplace ColorRules ColorSelectorSettings ColorSeparate ColorSetter ColorSetterBox ColorSetterBoxOptions ColorSlider ColorSpace Column ColumnAlignments ColumnBackgrounds ColumnForm ColumnLines ColumnsEqual ColumnSpacings ColumnWidths CommonDefaultFormatTypes Commonest CommonestFilter CommonUnits CommunityBoundaryStyle CommunityGraphPlot CommunityLabels CommunityRegionStyle CompatibleUnitQ CompilationOptions CompilationTarget Compile Compiled CompiledFunction Complement CompleteGraph CompleteGraphQ CompleteKaryTree CompletionsListPacket Complex Complexes ComplexExpand ComplexInfinity ComplexityFunction ComponentMeasurements ComponentwiseContextMenu Compose ComposeList ComposeSeries Composition CompoundExpression CompoundPoissonDistribution CompoundPoissonProcess CompoundRenewalProcess Compress CompressedData Condition ConditionalExpression Conditioned Cone ConeBox ConfidenceLevel ConfidenceRange ConfidenceTransform ConfigurationPath Congruent Conjugate ConjugateTranspose Conjunction Connect ConnectedComponents ConnectedGraphQ ConnesWindow ConoverTest ConsoleMessage ConsoleMessagePacket ConsolePrint Constant ConstantArray Constants ConstrainedMax ConstrainedMin ContentPadding ContentsBoundingBox ContentSelectable ContentSize Context ContextMenu Contexts ContextToFilename ContextToFileName Continuation Continue ContinuedFraction ContinuedFractionK ContinuousAction ContinuousMarkovProcess ContinuousTimeModelQ ContinuousWaveletData ContinuousWaveletTransform ContourDetect ContourGraphics ContourIntegral ContourLabels ContourLines ContourPlot ContourPlot3D Contours ContourShading ContourSmoothing ContourStyle ContraharmonicMean Control ControlActive ControlAlignment ControllabilityGramian ControllabilityMatrix ControllableDecomposition ControllableModelQ ControllerDuration ControllerInformation ControllerInformationData ControllerLinking ControllerManipulate ControllerMethod ControllerPath ControllerState ControlPlacement ControlsRendering ControlType Convergents ConversionOptions ConversionRules ConvertToBitmapPacket ConvertToPostScript ConvertToPostScriptPacket Convolve ConwayGroupCo1 ConwayGroupCo2 ConwayGroupCo3 CoordinateChartData CoordinatesToolOptions CoordinateTransform CoordinateTransformData CoprimeQ Coproduct CopulaDistribution Copyable CopyDirectory CopyFile CopyTag CopyToClipboard CornerFilter CornerNeighbors Correlation CorrelationDistance CorrelationFunction CorrelationTest Cos Cosh CoshIntegral CosineDistance CosineWindow CosIntegral Cot Coth Count CounterAssignments CounterBox CounterBoxOptions CounterClockwiseContourIntegral CounterEvaluator CounterFunction CounterIncrements CounterStyle CounterStyleMenuListing CountRoots CountryData Covariance CovarianceEstimatorFunction CovarianceFunction CoxianDistribution CoxIngersollRossProcess CoxModel CoxModelFit CramerVonMisesTest CreateArchive CreateDialog CreateDirectory CreateDocument CreateIntermediateDirectories CreatePalette CreatePalettePacket CreateScheduledTask CreateTemporary CreateWindow CriticalityFailureImportance CriticalitySuccessImportance CriticalSection Cross CrossingDetect CrossMatrix Csc Csch CubeRoot Cubics Cuboid CuboidBox Cumulant CumulantGeneratingFunction Cup CupCap Curl CurlyDoubleQuote CurlyQuote CurrentImage CurrentlySpeakingPacket CurrentValue CurvatureFlowFilter CurveClosed Cyan CycleGraph CycleIndexPolynomial Cycles CyclicGroup Cyclotomic Cylinder CylinderBox CylindricalDecomposition D DagumDistribution DamerauLevenshteinDistance DampingFactor Darker Dashed Dashing DataCompression DataDistribution DataRange DataReversed Date DateDelimiters DateDifference DateFunction DateList DateListLogPlot DateListPlot DatePattern DatePlus DateRange DateString DateTicksFormat DaubechiesWavelet DavisDistribution DawsonF DayCount DayCountConvention DayMatchQ DayName DayPlus DayRange DayRound DeBruijnGraph Debug DebugTag Decimal DeclareKnownSymbols DeclarePackage Decompose Decrement DedekindEta Default DefaultAxesStyle DefaultBaseStyle DefaultBoxStyle DefaultButton DefaultColor DefaultControlPlacement DefaultDuplicateCellStyle DefaultDuration DefaultElement DefaultFaceGridsStyle DefaultFieldHintStyle DefaultFont DefaultFontProperties DefaultFormatType DefaultFormatTypeForStyle DefaultFrameStyle DefaultFrameTicksStyle DefaultGridLinesStyle DefaultInlineFormatType DefaultInputFormatType DefaultLabelStyle DefaultMenuStyle DefaultNaturalLanguage DefaultNewCellStyle DefaultNewInlineCellStyle DefaultNotebook DefaultOptions DefaultOutputFormatType DefaultStyle DefaultStyleDefinitions DefaultTextFormatType DefaultTextInlineFormatType DefaultTicksStyle DefaultTooltipStyle DefaultValues Defer DefineExternal DefineInputStreamMethod DefineOutputStreamMethod Definition Degree DegreeCentrality DegreeGraphDistribution DegreeLexicographic DegreeReverseLexicographic Deinitialization Del Deletable Delete DeleteBorderComponents DeleteCases DeleteContents DeleteDirectory DeleteDuplicates DeleteFile DeleteSmallComponents DeleteWithContents DeletionWarning Delimiter DelimiterFlashTime DelimiterMatching Delimiters Denominator DensityGraphics DensityHistogram DensityPlot DependentVariables Deploy Deployed Depth DepthFirstScan Derivative DerivativeFilter DescriptorStateSpace DesignMatrix Det DGaussianWavelet DiacriticalPositioning Diagonal DiagonalMatrix Dialog DialogIndent DialogInput DialogLevel DialogNotebook DialogProlog DialogReturn DialogSymbols Diamond DiamondMatrix DiceDissimilarity DictionaryLookup DifferenceDelta DifferenceOrder DifferenceRoot DifferenceRootReduce Differences DifferentialD DifferentialRoot DifferentialRootReduce DifferentiatorFilter DigitBlock DigitBlockMinimum DigitCharacter DigitCount DigitQ DihedralGroup Dilation Dimensions DiracComb DiracDelta DirectedEdge DirectedEdges DirectedGraph DirectedGraphQ DirectedInfinity Direction Directive Directory DirectoryName DirectoryQ DirectoryStack DirichletCharacter DirichletConvolve DirichletDistribution DirichletL DirichletTransform DirichletWindow DisableConsolePrintPacket DiscreteChirpZTransform DiscreteConvolve DiscreteDelta DiscreteHadamardTransform DiscreteIndicator DiscreteLQEstimatorGains DiscreteLQRegulatorGains DiscreteLyapunovSolve DiscreteMarkovProcess DiscretePlot DiscretePlot3D DiscreteRatio DiscreteRiccatiSolve DiscreteShift DiscreteTimeModelQ DiscreteUniformDistribution DiscreteVariables DiscreteWaveletData DiscreteWaveletPacketTransform DiscreteWaveletTransform Discriminant Disjunction Disk DiskBox DiskMatrix Dispatch DispersionEstimatorFunction Display DisplayAllSteps DisplayEndPacket DisplayFlushImagePacket DisplayForm DisplayFunction DisplayPacket DisplayRules DisplaySetSizePacket DisplayString DisplayTemporary DisplayWith DisplayWithRef DisplayWithVariable DistanceFunction DistanceTransform Distribute Distributed DistributedContexts DistributeDefinitions DistributionChart DistributionDomain DistributionFitTest DistributionParameterAssumptions DistributionParameterQ Dithering Div Divergence Divide DivideBy Dividers Divisible Divisors DivisorSigma DivisorSum DMSList DMSString Do DockedCells DocumentNotebook DominantColors DOSTextFormat Dot DotDashed DotEqual Dotted DoubleBracketingBar DoubleContourIntegral DoubleDownArrow DoubleLeftArrow DoubleLeftRightArrow DoubleLeftTee DoubleLongLeftArrow DoubleLongLeftRightArrow DoubleLongRightArrow DoubleRightArrow DoubleRightTee DoubleUpArrow DoubleUpDownArrow DoubleVerticalBar DoublyInfinite Down DownArrow DownArrowBar DownArrowUpArrow DownLeftRightVector DownLeftTeeVector DownLeftVector DownLeftVectorBar DownRightTeeVector DownRightVector DownRightVectorBar Downsample DownTee DownTeeArrow DownValues DragAndDrop DrawEdges DrawFrontFaces DrawHighlighted Drop DSolve Dt DualLinearProgramming DualSystemsModel DumpGet DumpSave DuplicateFreeQ Dynamic DynamicBox DynamicBoxOptions DynamicEvaluationTimeout DynamicLocation DynamicModule DynamicModuleBox DynamicModuleBoxOptions DynamicModuleParent DynamicModuleValues DynamicName DynamicNamespace DynamicReference DynamicSetting DynamicUpdating DynamicWrapper DynamicWrapperBox DynamicWrapperBoxOptions E EccentricityCentrality EdgeAdd EdgeBetweennessCentrality EdgeCapacity EdgeCapForm EdgeColor EdgeConnectivity EdgeCost EdgeCount EdgeCoverQ EdgeDashing EdgeDelete EdgeDetect EdgeForm EdgeIndex EdgeJoinForm EdgeLabeling EdgeLabels EdgeLabelStyle EdgeList EdgeOpacity EdgeQ EdgeRenderingFunction EdgeRules EdgeShapeFunction EdgeStyle EdgeThickness EdgeWeight Editable EditButtonSettings EditCellTagsSettings EditDistance EffectiveInterest Eigensystem Eigenvalues EigenvectorCentrality Eigenvectors Element ElementData Eliminate EliminationOrder EllipticE EllipticExp EllipticExpPrime EllipticF EllipticFilterModel EllipticK EllipticLog EllipticNomeQ EllipticPi EllipticReducedHalfPeriods EllipticTheta EllipticThetaPrime EmitSound EmphasizeSyntaxErrors EmpiricalDistribution Empty EmptyGraphQ EnableConsolePrintPacket Enabled Encode End EndAdd EndDialogPacket EndFrontEndInteractionPacket EndOfFile EndOfLine EndOfString EndPackage EngineeringForm Enter EnterExpressionPacket EnterTextPacket Entropy EntropyFilter Environment Epilog Equal EqualColumns EqualRows EqualTilde EquatedTo Equilibrium EquirippleFilterKernel Equivalent Erf Erfc Erfi ErlangB ErlangC ErlangDistribution Erosion ErrorBox ErrorBoxOptions ErrorNorm ErrorPacket ErrorsDialogSettings EstimatedDistribution EstimatedProcess EstimatorGains EstimatorRegulator EuclideanDistance EulerE EulerGamma EulerianGraphQ EulerPhi Evaluatable Evaluate Evaluated EvaluatePacket EvaluationCell EvaluationCompletionAction EvaluationElements EvaluationMode EvaluationMonitor EvaluationNotebook EvaluationObject EvaluationOrder Evaluator EvaluatorNames EvenQ EventData EventEvaluator EventHandler EventHandlerTag EventLabels ExactBlackmanWindow ExactNumberQ ExactRootIsolation ExampleData Except ExcludedForms ExcludePods Exclusions ExclusionsStyle Exists Exit ExitDialog Exp Expand ExpandAll ExpandDenominator ExpandFileName ExpandNumerator Expectation ExpectationE ExpectedValue ExpGammaDistribution ExpIntegralE ExpIntegralEi Exponent ExponentFunction ExponentialDistribution ExponentialFamily ExponentialGeneratingFunction ExponentialMovingAverage ExponentialPowerDistribution ExponentPosition ExponentStep Export ExportAutoReplacements ExportPacket ExportString Expression ExpressionCell ExpressionPacket ExpToTrig ExtendedGCD Extension ExtentElementFunction ExtentMarkers ExtentSize ExternalCall ExternalDataCharacterEncoding Extract ExtractArchive ExtremeValueDistribution FaceForm FaceGrids FaceGridsStyle Factor FactorComplete Factorial Factorial2 FactorialMoment FactorialMomentGeneratingFunction FactorialPower FactorInteger FactorList FactorSquareFree FactorSquareFreeList FactorTerms FactorTermsList Fail FailureDistribution False FARIMAProcess FEDisableConsolePrintPacket FeedbackSector FeedbackSectorStyle FeedbackType FEEnableConsolePrintPacket Fibonacci FieldHint FieldHintStyle FieldMasked FieldSize File FileBaseName FileByteCount FileDate FileExistsQ FileExtension FileFormat FileHash FileInformation FileName FileNameDepth FileNameDialogSettings FileNameDrop FileNameJoin FileNames FileNameSetter FileNameSplit FileNameTake FilePrint FileType FilledCurve FilledCurveBox Filling FillingStyle FillingTransform FilterRules FinancialBond FinancialData FinancialDerivative FinancialIndicator Find FindArgMax FindArgMin FindClique FindClusters FindCurvePath FindDistributionParameters FindDivisions FindEdgeCover FindEdgeCut FindEulerianCycle FindFaces FindFile FindFit FindGeneratingFunction FindGeoLocation FindGeometricTransform FindGraphCommunities FindGraphIsomorphism FindGraphPartition FindHamiltonianCycle FindIndependentEdgeSet FindIndependentVertexSet FindInstance FindIntegerNullVector FindKClan FindKClique FindKClub FindKPlex FindLibrary FindLinearRecurrence FindList FindMaximum FindMaximumFlow FindMaxValue FindMinimum FindMinimumCostFlow FindMinimumCut FindMinValue FindPermutation FindPostmanTour FindProcessParameters FindRoot FindSequenceFunction FindSettings FindShortestPath FindShortestTour FindThreshold FindVertexCover FindVertexCut Fine FinishDynamic FiniteAbelianGroupCount FiniteGroupCount FiniteGroupData First FirstPassageTimeDistribution FischerGroupFi22 FischerGroupFi23 FischerGroupFi24Prime FisherHypergeometricDistribution FisherRatioTest FisherZDistribution Fit FitAll FittedModel FixedPoint FixedPointList FlashSelection Flat Flatten FlattenAt FlatTopWindow FlipView Floor FlushPrintOutputPacket Fold FoldList Font FontColor FontFamily FontForm FontName FontOpacity FontPostScriptName FontProperties FontReencoding FontSize FontSlant FontSubstitutions FontTracking FontVariations FontWeight For ForAll Format FormatRules FormatType FormatTypeAutoConvert FormatValues FormBox FormBoxOptions FortranForm Forward ForwardBackward Fourier FourierCoefficient FourierCosCoefficient FourierCosSeries FourierCosTransform FourierDCT FourierDCTFilter FourierDCTMatrix FourierDST FourierDSTMatrix FourierMatrix FourierParameters FourierSequenceTransform FourierSeries FourierSinCoefficient FourierSinSeries FourierSinTransform FourierTransform FourierTrigSeries FractionalBrownianMotionProcess FractionalPart FractionBox FractionBoxOptions FractionLine Frame FrameBox FrameBoxOptions Framed FrameInset FrameLabel Frameless FrameMargins FrameStyle FrameTicks FrameTicksStyle FRatioDistribution FrechetDistribution FreeQ FrequencySamplingFilterKernel FresnelC FresnelS Friday FrobeniusNumber FrobeniusSolve FromCharacterCode FromCoefficientRules FromContinuedFraction FromDate FromDigits FromDMS Front FrontEndDynamicExpression FrontEndEventActions FrontEndExecute FrontEndObject FrontEndResource FrontEndResourceString FrontEndStackSize FrontEndToken FrontEndTokenExecute FrontEndValueCache FrontEndVersion FrontFaceColor FrontFaceOpacity Full FullAxes FullDefinition FullForm FullGraphics FullOptions FullSimplify Function FunctionExpand FunctionInterpolation FunctionSpace FussellVeselyImportance GaborFilter GaborMatrix GaborWavelet GainMargins GainPhaseMargins Gamma GammaDistribution GammaRegularized GapPenalty Gather GatherBy GaugeFaceElementFunction GaugeFaceStyle GaugeFrameElementFunction GaugeFrameSize GaugeFrameStyle GaugeLabels GaugeMarkers GaugeStyle GaussianFilter GaussianIntegers GaussianMatrix GaussianWindow GCD GegenbauerC General GeneralizedLinearModelFit GenerateConditions GeneratedCell GeneratedParameters GeneratingFunction Generic GenericCylindricalDecomposition GenomeData GenomeLookup GeodesicClosing GeodesicDilation GeodesicErosion GeodesicOpening GeoDestination GeodesyData GeoDirection GeoDistance GeoGridPosition GeometricBrownianMotionProcess GeometricDistribution GeometricMean GeometricMeanFilter GeometricTransformation GeometricTransformation3DBox GeometricTransformation3DBoxOptions GeometricTransformationBox GeometricTransformationBoxOptions GeoPosition GeoPositionENU GeoPositionXYZ GeoProjectionData GestureHandler GestureHandlerTag Get GetBoundingBoxSizePacket GetContext GetEnvironment GetFileName GetFrontEndOptionsDataPacket GetLinebreakInformationPacket GetMenusPacket GetPageBreakInformationPacket Glaisher GlobalClusteringCoefficient GlobalPreferences GlobalSession Glow GoldenRatio GompertzMakehamDistribution GoodmanKruskalGamma GoodmanKruskalGammaTest Goto Grad Gradient GradientFilter GradientOrientationFilter Graph GraphAssortativity GraphCenter GraphComplement GraphData GraphDensity GraphDiameter GraphDifference GraphDisjointUnion GraphDistance GraphDistanceMatrix GraphElementData GraphEmbedding GraphHighlight GraphHighlightStyle GraphHub Graphics Graphics3D Graphics3DBox Graphics3DBoxOptions GraphicsArray GraphicsBaseline GraphicsBox GraphicsBoxOptions GraphicsColor GraphicsColumn GraphicsComplex GraphicsComplex3DBox GraphicsComplex3DBoxOptions GraphicsComplexBox GraphicsComplexBoxOptions GraphicsContents GraphicsData GraphicsGrid GraphicsGridBox GraphicsGroup GraphicsGroup3DBox GraphicsGroup3DBoxOptions GraphicsGroupBox GraphicsGroupBoxOptions GraphicsGrouping GraphicsHighlightColor GraphicsRow GraphicsSpacing GraphicsStyle GraphIntersection GraphLayout GraphLinkEfficiency GraphPeriphery GraphPlot GraphPlot3D GraphPower GraphPropertyDistribution GraphQ GraphRadius GraphReciprocity GraphRoot GraphStyle GraphUnion Gray GrayLevel GreatCircleDistance Greater GreaterEqual GreaterEqualLess GreaterFullEqual GreaterGreater GreaterLess GreaterSlantEqual GreaterTilde Green Grid GridBaseline GridBox GridBoxAlignment GridBoxBackground GridBoxDividers GridBoxFrame GridBoxItemSize GridBoxItemStyle GridBoxOptions GridBoxSpacings GridCreationSettings GridDefaultElement GridElementStyleOptions GridFrame GridFrameMargins GridGraph GridLines GridLinesStyle GroebnerBasis GroupActionBase GroupCentralizer GroupElementFromWord GroupElementPosition GroupElementQ GroupElements GroupElementToWord GroupGenerators GroupMultiplicationTable GroupOrbits GroupOrder GroupPageBreakWithin GroupSetwiseStabilizer GroupStabilizer GroupStabilizerChain Gudermannian GumbelDistribution HaarWavelet HadamardMatrix HalfNormalDistribution HamiltonianGraphQ HammingDistance HammingWindow HankelH1 HankelH2 HankelMatrix HannPoissonWindow HannWindow HaradaNortonGroupHN HararyGraph HarmonicMean HarmonicMeanFilter HarmonicNumber Hash HashTable Haversine HazardFunction Head HeadCompose Heads HeavisideLambda HeavisidePi HeavisideTheta HeldGroupHe HeldPart HelpBrowserLookup HelpBrowserNotebook HelpBrowserSettings HermiteDecomposition HermiteH HermitianMatrixQ HessenbergDecomposition Hessian HexadecimalCharacter Hexahedron HexahedronBox HexahedronBoxOptions HiddenSurface HighlightGraph HighlightImage HighpassFilter HigmanSimsGroupHS HilbertFilter HilbertMatrix Histogram Histogram3D HistogramDistribution HistogramList HistogramTransform HistogramTransformInterpolation HitMissTransform HITSCentrality HodgeDual HoeffdingD HoeffdingDTest Hold HoldAll HoldAllComplete HoldComplete HoldFirst HoldForm HoldPattern HoldRest HolidayCalendar HomeDirectory HomePage Horizontal HorizontalForm HorizontalGauge HorizontalScrollPosition HornerForm HotellingTSquareDistribution HoytDistribution HTMLSave Hue HumpDownHump HumpEqual HurwitzLerchPhi HurwitzZeta HyperbolicDistribution HypercubeGraph HyperexponentialDistribution Hyperfactorial Hypergeometric0F1 Hypergeometric0F1Regularized Hypergeometric1F1 Hypergeometric1F1Regularized Hypergeometric2F1 Hypergeometric2F1Regularized HypergeometricDistribution HypergeometricPFQ HypergeometricPFQRegularized HypergeometricU Hyperlink HyperlinkCreationSettings Hyphenation HyphenationOptions HypoexponentialDistribution HypothesisTestData I Identity IdentityMatrix If IgnoreCase Im Image Image3D Image3DSlices ImageAccumulate ImageAdd ImageAdjust ImageAlign ImageApply ImageAspectRatio ImageAssemble ImageCache ImageCacheValid ImageCapture ImageChannels ImageClip ImageColorSpace ImageCompose ImageConvolve ImageCooccurrence ImageCorners ImageCorrelate ImageCorrespondingPoints ImageCrop ImageData ImageDataPacket ImageDeconvolve ImageDemosaic ImageDifference ImageDimensions ImageDistance ImageEffect ImageFeatureTrack ImageFileApply ImageFileFilter ImageFileScan ImageFilter ImageForestingComponents ImageForwardTransformation ImageHistogram ImageKeypoints ImageLevels ImageLines ImageMargins ImageMarkers ImageMeasurements ImageMultiply ImageOffset ImagePad ImagePadding ImagePartition ImagePeriodogram ImagePerspectiveTransformation ImageQ ImageRangeCache ImageReflect ImageRegion ImageResize ImageResolution ImageRotate ImageRotated ImageScaled ImageScan ImageSize ImageSizeAction ImageSizeCache ImageSizeMultipliers ImageSizeRaw ImageSubtract ImageTake ImageTransformation ImageTrim ImageType ImageValue ImageValuePositions Implies Import ImportAutoReplacements ImportString ImprovementImportance In IncidenceGraph IncidenceList IncidenceMatrix IncludeConstantBasis IncludeFileExtension IncludePods IncludeSingularTerm Increment Indent IndentingNewlineSpacings IndentMaxFraction IndependenceTest IndependentEdgeSetQ IndependentUnit IndependentVertexSetQ Indeterminate IndexCreationOptions Indexed IndexGraph IndexTag Inequality InexactNumberQ InexactNumbers Infinity Infix Information Inherited InheritScope Initialization InitializationCell InitializationCellEvaluation InitializationCellWarning InlineCounterAssignments InlineCounterIncrements InlineRules Inner Inpaint Input InputAliases InputAssumptions InputAutoReplacements InputField InputFieldBox InputFieldBoxOptions InputForm InputGrouping InputNamePacket InputNotebook InputPacket InputSettings InputStream InputString InputStringPacket InputToBoxFormPacket Insert InsertionPointObject InsertResults Inset Inset3DBox Inset3DBoxOptions InsetBox InsetBoxOptions Install InstallService InString Integer IntegerDigits IntegerExponent IntegerLength IntegerPart IntegerPartitions IntegerQ Integers IntegerString Integral Integrate Interactive InteractiveTradingChart Interlaced Interleaving InternallyBalancedDecomposition InterpolatingFunction InterpolatingPolynomial Interpolation InterpolationOrder InterpolationPoints InterpolationPrecision Interpretation InterpretationBox InterpretationBoxOptions InterpretationFunction InterpretTemplate InterquartileRange Interrupt InterruptSettings Intersection Interval IntervalIntersection IntervalMemberQ IntervalUnion Inverse InverseBetaRegularized InverseCDF InverseChiSquareDistribution InverseContinuousWaveletTransform InverseDistanceTransform InverseEllipticNomeQ InverseErf InverseErfc InverseFourier InverseFourierCosTransform InverseFourierSequenceTransform InverseFourierSinTransform InverseFourierTransform InverseFunction InverseFunctions InverseGammaDistribution InverseGammaRegularized InverseGaussianDistribution InverseGudermannian InverseHaversine InverseJacobiCD InverseJacobiCN InverseJacobiCS InverseJacobiDC InverseJacobiDN InverseJacobiDS InverseJacobiNC InverseJacobiND InverseJacobiNS InverseJacobiSC InverseJacobiSD InverseJacobiSN InverseLaplaceTransform InversePermutation InverseRadon InverseSeries InverseSurvivalFunction InverseWaveletTransform InverseWeierstrassP InverseZTransform Invisible InvisibleApplication InvisibleTimes IrreduciblePolynomialQ IsolatingInterval IsomorphicGraphQ IsotopeData Italic Item ItemBox ItemBoxOptions ItemSize ItemStyle ItoProcess JaccardDissimilarity JacobiAmplitude Jacobian JacobiCD JacobiCN JacobiCS JacobiDC JacobiDN JacobiDS JacobiNC JacobiND JacobiNS JacobiP JacobiSC JacobiSD JacobiSN JacobiSymbol JacobiZeta JankoGroupJ1 JankoGroupJ2 JankoGroupJ3 JankoGroupJ4 JarqueBeraALMTest JohnsonDistribution Join Joined JoinedCurve JoinedCurveBox JoinForm JordanDecomposition JordanModelDecomposition K KagiChart KaiserBesselWindow KaiserWindow KalmanEstimator KalmanFilter KarhunenLoeveDecomposition KaryTree KatzCentrality KCoreComponents KDistribution KelvinBei KelvinBer KelvinKei KelvinKer KendallTau KendallTauTest KernelExecute KernelMixtureDistribution KernelObject Kernels Ket Khinchin KirchhoffGraph KirchhoffMatrix KleinInvariantJ KnightTourGraph KnotData KnownUnitQ KolmogorovSmirnovTest KroneckerDelta KroneckerModelDecomposition KroneckerProduct KroneckerSymbol KuiperTest KumaraswamyDistribution Kurtosis KuwaharaFilter Label Labeled LabeledSlider LabelingFunction LabelStyle LaguerreL LambdaComponents LambertW LanczosWindow LandauDistribution Language LanguageCategory LaplaceDistribution LaplaceTransform Laplacian LaplacianFilter LaplacianGaussianFilter Large Larger Last Latitude LatitudeLongitude LatticeData LatticeReduce Launch LaunchKernels LayeredGraphPlot LayerSizeFunction LayoutInformation LCM LeafCount LeapYearQ LeastSquares LeastSquaresFilterKernel Left LeftArrow LeftArrowBar LeftArrowRightArrow LeftDownTeeVector LeftDownVector LeftDownVectorBar LeftRightArrow LeftRightVector LeftTee LeftTeeArrow LeftTeeVector LeftTriangle LeftTriangleBar LeftTriangleEqual LeftUpDownVector LeftUpTeeVector LeftUpVector LeftUpVectorBar LeftVector LeftVectorBar LegendAppearance Legended LegendFunction LegendLabel LegendLayout LegendMargins LegendMarkers LegendMarkerSize LegendreP LegendreQ LegendreType Length LengthWhile LerchPhi Less LessEqual LessEqualGreater LessFullEqual LessGreater LessLess LessSlantEqual LessTilde LetterCharacter LetterQ Level LeveneTest LeviCivitaTensor LevyDistribution Lexicographic LibraryFunction LibraryFunctionError LibraryFunctionInformation LibraryFunctionLoad LibraryFunctionUnload LibraryLoad LibraryUnload LicenseID LiftingFilterData LiftingWaveletTransform LightBlue LightBrown LightCyan Lighter LightGray LightGreen Lighting LightingAngle LightMagenta LightOrange LightPink LightPurple LightRed LightSources LightYellow Likelihood Limit LimitsPositioning LimitsPositioningTokens LindleyDistribution Line Line3DBox LinearFilter LinearFractionalTransform LinearModelFit LinearOffsetFunction LinearProgramming LinearRecurrence LinearSolve LinearSolveFunction LineBox LineBreak LinebreakAdjustments LineBreakChart LineBreakWithin LineColor LineForm LineGraph LineIndent LineIndentMaxFraction LineIntegralConvolutionPlot LineIntegralConvolutionScale LineLegend LineOpacity LineSpacing LineWrapParts LinkActivate LinkClose LinkConnect LinkConnectedQ LinkCreate LinkError LinkFlush LinkFunction LinkHost LinkInterrupt LinkLaunch LinkMode LinkObject LinkOpen LinkOptions LinkPatterns LinkProtocol LinkRead LinkReadHeld LinkReadyQ Links LinkWrite LinkWriteHeld LiouvilleLambda List Listable ListAnimate ListContourPlot ListContourPlot3D ListConvolve ListCorrelate ListCurvePathPlot ListDeconvolve ListDensityPlot Listen ListFourierSequenceTransform ListInterpolation ListLineIntegralConvolutionPlot ListLinePlot ListLogLinearPlot ListLogLogPlot ListLogPlot ListPicker ListPickerBox ListPickerBoxBackground ListPickerBoxOptions ListPlay ListPlot ListPlot3D ListPointPlot3D ListPolarPlot ListQ ListStreamDensityPlot ListStreamPlot ListSurfacePlot3D ListVectorDensityPlot ListVectorPlot ListVectorPlot3D ListZTransform Literal LiteralSearch LocalClusteringCoefficient LocalizeVariables LocationEquivalenceTest LocationTest Locator LocatorAutoCreate LocatorBox LocatorBoxOptions LocatorCentering LocatorPane LocatorPaneBox LocatorPaneBoxOptions LocatorRegion Locked Log Log10 Log2 LogBarnesG LogGamma LogGammaDistribution LogicalExpand LogIntegral LogisticDistribution LogitModelFit LogLikelihood LogLinearPlot LogLogisticDistribution LogLogPlot LogMultinormalDistribution LogNormalDistribution LogPlot LogRankTest LogSeriesDistribution LongEqual Longest LongestAscendingSequence LongestCommonSequence LongestCommonSequencePositions LongestCommonSubsequence LongestCommonSubsequencePositions LongestMatch LongForm Longitude LongLeftArrow LongLeftRightArrow LongRightArrow Loopback LoopFreeGraphQ LowerCaseQ LowerLeftArrow LowerRightArrow LowerTriangularize LowpassFilter LQEstimatorGains LQGRegulator LQOutputRegulatorGains LQRegulatorGains LUBackSubstitution LucasL LuccioSamiComponents LUDecomposition LyapunovSolve LyonsGroupLy MachineID MachineName MachineNumberQ MachinePrecision MacintoshSystemPageSetup Magenta Magnification Magnify MainSolve MaintainDynamicCaches Majority MakeBoxes MakeExpression MakeRules MangoldtLambda ManhattanDistance Manipulate Manipulator MannWhitneyTest MantissaExponent Manual Map MapAll MapAt MapIndexed MAProcess MapThread MarcumQ MardiaCombinedTest MardiaKurtosisTest MardiaSkewnessTest MarginalDistribution MarkovProcessProperties Masking MatchingDissimilarity MatchLocalNameQ MatchLocalNames MatchQ Material MathematicaNotation MathieuC MathieuCharacteristicA MathieuCharacteristicB MathieuCharacteristicExponent MathieuCPrime MathieuGroupM11 MathieuGroupM12 MathieuGroupM22 MathieuGroupM23 MathieuGroupM24 MathieuS MathieuSPrime MathMLForm MathMLText Matrices MatrixExp MatrixForm MatrixFunction MatrixLog MatrixPlot MatrixPower MatrixQ MatrixRank Max MaxBend MaxDetect MaxExtraBandwidths MaxExtraConditions MaxFeatures MaxFilter Maximize MaxIterations MaxMemoryUsed MaxMixtureKernels MaxPlotPoints MaxPoints MaxRecursion MaxStableDistribution MaxStepFraction MaxSteps MaxStepSize MaxValue MaxwellDistribution McLaughlinGroupMcL Mean MeanClusteringCoefficient MeanDegreeConnectivity MeanDeviation MeanFilter MeanGraphDistance MeanNeighborDegree MeanShift MeanShiftFilter Median MedianDeviation MedianFilter Medium MeijerG MeixnerDistribution MemberQ MemoryConstrained MemoryInUse Menu MenuAppearance MenuCommandKey MenuEvaluator MenuItem MenuPacket MenuSortingValue MenuStyle MenuView MergeDifferences Mesh MeshFunctions MeshRange MeshShading MeshStyle Message MessageDialog MessageList MessageName MessageOptions MessagePacket Messages MessagesNotebook MetaCharacters MetaInformation Method MethodOptions MexicanHatWavelet MeyerWavelet Min MinDetect MinFilter MinimalPolynomial MinimalStateSpaceModel Minimize Minors MinRecursion MinSize MinStableDistribution Minus MinusPlus MinValue Missing MissingDataMethod MittagLefflerE MixedRadix MixedRadixQuantity MixtureDistribution Mod Modal Mode Modular ModularLambda Module Modulus MoebiusMu Moment Momentary MomentConvert MomentEvaluate MomentGeneratingFunction Monday Monitor MonomialList MonomialOrder MonsterGroupM MorletWavelet MorphologicalBinarize MorphologicalBranchPoints MorphologicalComponents MorphologicalEulerNumber MorphologicalGraph MorphologicalPerimeter MorphologicalTransform Most MouseAnnotation MouseAppearance MouseAppearanceTag MouseButtons Mouseover MousePointerNote MousePosition MovingAverage MovingMedian MoyalDistribution MultiedgeStyle MultilaunchWarning MultiLetterItalics MultiLetterStyle MultilineFunction Multinomial MultinomialDistribution MultinormalDistribution MultiplicativeOrder Multiplicity Multiselection MultivariateHypergeometricDistribution MultivariatePoissonDistribution MultivariateTDistribution N NakagamiDistribution NameQ Names NamespaceBox Nand NArgMax NArgMin NBernoulliB NCache NDSolve NDSolveValue Nearest NearestFunction NeedCurrentFrontEndPackagePacket NeedCurrentFrontEndSymbolsPacket NeedlemanWunschSimilarity Needs Negative NegativeBinomialDistribution NegativeMultinomialDistribution NeighborhoodGraph Nest NestedGreaterGreater NestedLessLess NestedScriptRules NestList NestWhile NestWhileList NevilleThetaC NevilleThetaD NevilleThetaN NevilleThetaS NewPrimitiveStyle NExpectation Next NextPrime NHoldAll NHoldFirst NHoldRest NicholsGridLines NicholsPlot NIntegrate NMaximize NMaxValue NMinimize NMinValue NominalVariables NonAssociative NoncentralBetaDistribution NoncentralChiSquareDistribution NoncentralFRatioDistribution NoncentralStudentTDistribution NonCommutativeMultiply NonConstants None NonlinearModelFit NonlocalMeansFilter NonNegative NonPositive Nor NorlundB Norm Normal NormalDistribution NormalGrouping Normalize NormalizedSquaredEuclideanDistance NormalsFunction NormFunction Not NotCongruent NotCupCap NotDoubleVerticalBar Notebook NotebookApply NotebookAutoSave NotebookClose NotebookConvertSettings NotebookCreate NotebookCreateReturnObject NotebookDefault NotebookDelete NotebookDirectory NotebookDynamicExpression NotebookEvaluate NotebookEventActions NotebookFileName NotebookFind NotebookFindReturnObject NotebookGet NotebookGetLayoutInformationPacket NotebookGetMisspellingsPacket NotebookInformation NotebookInterfaceObject NotebookLocate NotebookObject NotebookOpen NotebookOpenReturnObject NotebookPath NotebookPrint NotebookPut NotebookPutReturnObject NotebookRead NotebookResetGeneratedCells Notebooks NotebookSave NotebookSaveAs NotebookSelection NotebookSetupLayoutInformationPacket NotebooksMenu NotebookWrite NotElement NotEqualTilde NotExists NotGreater NotGreaterEqual NotGreaterFullEqual NotGreaterGreater NotGreaterLess NotGreaterSlantEqual NotGreaterTilde NotHumpDownHump NotHumpEqual NotLeftTriangle NotLeftTriangleBar NotLeftTriangleEqual NotLess NotLessEqual NotLessFullEqual NotLessGreater NotLessLess NotLessSlantEqual NotLessTilde NotNestedGreaterGreater NotNestedLessLess NotPrecedes NotPrecedesEqual NotPrecedesSlantEqual NotPrecedesTilde NotReverseElement NotRightTriangle NotRightTriangleBar NotRightTriangleEqual NotSquareSubset NotSquareSubsetEqual NotSquareSuperset NotSquareSupersetEqual NotSubset NotSubsetEqual NotSucceeds NotSucceedsEqual NotSucceedsSlantEqual NotSucceedsTilde NotSuperset NotSupersetEqual NotTilde NotTildeEqual NotTildeFullEqual NotTildeTilde NotVerticalBar NProbability NProduct NProductFactors NRoots NSolve NSum NSumTerms Null NullRecords NullSpace NullWords Number NumberFieldClassNumber NumberFieldDiscriminant NumberFieldFundamentalUnits NumberFieldIntegralBasis NumberFieldNormRepresentatives NumberFieldRegulator NumberFieldRootsOfUnity NumberFieldSignature NumberForm NumberFormat NumberMarks NumberMultiplier NumberPadding NumberPoint NumberQ NumberSeparator NumberSigns NumberString Numerator NumericFunction NumericQ NuttallWindow NValues NyquistGridLines NyquistPlot O ObservabilityGramian ObservabilityMatrix ObservableDecomposition ObservableModelQ OddQ Off Offset OLEData On ONanGroupON OneIdentity Opacity Open OpenAppend Opener OpenerBox OpenerBoxOptions OpenerView OpenFunctionInspectorPacket Opening OpenRead OpenSpecialOptions OpenTemporary OpenWrite Operate OperatingSystem OptimumFlowData Optional OptionInspectorSettings OptionQ Options OptionsPacket OptionsPattern OptionValue OptionValueBox OptionValueBoxOptions Or Orange Order OrderDistribution OrderedQ Ordering Orderless OrnsteinUhlenbeckProcess Orthogonalize Out Outer OutputAutoOverwrite OutputControllabilityMatrix OutputControllableModelQ OutputForm OutputFormData OutputGrouping OutputMathEditExpression OutputNamePacket OutputResponse OutputSizeLimit OutputStream Over OverBar OverDot Overflow OverHat Overlaps Overlay OverlayBox OverlayBoxOptions Overscript OverscriptBox OverscriptBoxOptions OverTilde OverVector OwenT OwnValues PackingMethod PaddedForm Padding PadeApproximant PadLeft PadRight PageBreakAbove PageBreakBelow PageBreakWithin PageFooterLines PageFooters PageHeaderLines PageHeaders PageHeight PageRankCentrality PageWidth PairedBarChart PairedHistogram PairedSmoothHistogram PairedTTest PairedZTest PaletteNotebook PalettePath Pane PaneBox PaneBoxOptions Panel PanelBox PanelBoxOptions Paneled PaneSelector PaneSelectorBox PaneSelectorBoxOptions PaperWidth ParabolicCylinderD ParagraphIndent ParagraphSpacing ParallelArray ParallelCombine ParallelDo ParallelEvaluate Parallelization Parallelize ParallelMap ParallelNeeds ParallelProduct ParallelSubmit ParallelSum ParallelTable ParallelTry Parameter ParameterEstimator ParameterMixtureDistribution ParameterVariables ParametricFunction ParametricNDSolve ParametricNDSolveValue ParametricPlot ParametricPlot3D ParentConnect ParentDirectory ParentForm Parenthesize ParentList ParetoDistribution Part PartialCorrelationFunction PartialD ParticleData Partition PartitionsP PartitionsQ ParzenWindow PascalDistribution PassEventsDown PassEventsUp Paste PasteBoxFormInlineCells PasteButton Path PathGraph PathGraphQ Pattern PatternSequence PatternTest PauliMatrix PaulWavelet Pause PausedTime PDF PearsonChiSquareTest PearsonCorrelationTest PearsonDistribution PerformanceGoal PeriodicInterpolation Periodogram PeriodogramArray PermutationCycles PermutationCyclesQ PermutationGroup PermutationLength PermutationList PermutationListQ PermutationMax PermutationMin PermutationOrder PermutationPower PermutationProduct PermutationReplace Permutations PermutationSupport Permute PeronaMalikFilter Perpendicular PERTDistribution PetersenGraph PhaseMargins Pi Pick PIDData PIDDerivativeFilter PIDFeedforward PIDTune Piecewise PiecewiseExpand PieChart PieChart3D PillaiTrace PillaiTraceTest Pink Pivoting PixelConstrained PixelValue PixelValuePositions Placed Placeholder PlaceholderReplace Plain PlanarGraphQ Play PlayRange Plot Plot3D Plot3Matrix PlotDivision PlotJoined PlotLabel PlotLayout PlotLegends PlotMarkers PlotPoints PlotRange PlotRangeClipping PlotRangePadding PlotRegion PlotStyle Plus PlusMinus Pochhammer PodStates PodWidth Point Point3DBox PointBox PointFigureChart PointForm PointLegend PointSize PoissonConsulDistribution PoissonDistribution PoissonProcess PoissonWindow PolarAxes PolarAxesOrigin PolarGridLines PolarPlot PolarTicks PoleZeroMarkers PolyaAeppliDistribution PolyGamma Polygon Polygon3DBox Polygon3DBoxOptions PolygonBox PolygonBoxOptions PolygonHoleScale PolygonIntersections PolygonScale PolyhedronData PolyLog PolynomialExtendedGCD PolynomialForm PolynomialGCD PolynomialLCM PolynomialMod PolynomialQ PolynomialQuotient PolynomialQuotientRemainder PolynomialReduce PolynomialRemainder Polynomials PopupMenu PopupMenuBox PopupMenuBoxOptions PopupView PopupWindow Position Positive PositiveDefiniteMatrixQ PossibleZeroQ Postfix PostScript Power PowerDistribution PowerExpand PowerMod PowerModList PowerSpectralDensity PowersRepresentations PowerSymmetricPolynomial Precedence PrecedenceForm Precedes PrecedesEqual PrecedesSlantEqual PrecedesTilde Precision PrecisionGoal PreDecrement PredictionRoot PreemptProtect PreferencesPath Prefix PreIncrement Prepend PrependTo PreserveImageOptions Previous PriceGraphDistribution PrimaryPlaceholder Prime PrimeNu PrimeOmega PrimePi PrimePowerQ PrimeQ Primes PrimeZetaP PrimitiveRoot PrincipalComponents PrincipalValue Print PrintAction PrintForm PrintingCopies PrintingOptions PrintingPageRange PrintingStartingPageNumber PrintingStyleEnvironment PrintPrecision PrintTemporary Prism PrismBox PrismBoxOptions PrivateCellOptions PrivateEvaluationOptions PrivateFontOptions PrivateFrontEndOptions PrivateNotebookOptions PrivatePaths Probability ProbabilityDistribution ProbabilityPlot ProbabilityPr ProbabilityScalePlot ProbitModelFit ProcessEstimator ProcessParameterAssumptions ProcessParameterQ ProcessStateDomain ProcessTimeDomain Product ProductDistribution ProductLog ProgressIndicator ProgressIndicatorBox ProgressIndicatorBoxOptions Projection Prolog PromptForm Properties Property PropertyList PropertyValue Proportion Proportional Protect Protected ProteinData Pruning PseudoInverse Purple Put PutAppend Pyramid PyramidBox PyramidBoxOptions QBinomial QFactorial QGamma QHypergeometricPFQ QPochhammer QPolyGamma QRDecomposition QuadraticIrrationalQ Quantile QuantilePlot Quantity QuantityForm QuantityMagnitude QuantityQ QuantityUnit Quartics QuartileDeviation Quartiles QuartileSkewness QueueingNetworkProcess QueueingProcess QueueProperties Quiet Quit Quotient QuotientRemainder RadialityCentrality RadicalBox RadicalBoxOptions RadioButton RadioButtonBar RadioButtonBox RadioButtonBoxOptions Radon RamanujanTau RamanujanTauL RamanujanTauTheta RamanujanTauZ Random RandomChoice RandomComplex RandomFunction RandomGraph RandomImage RandomInteger RandomPermutation RandomPrime RandomReal RandomSample RandomSeed RandomVariate RandomWalkProcess Range RangeFilter RangeSpecification RankedMax RankedMin Raster Raster3D Raster3DBox Raster3DBoxOptions RasterArray RasterBox RasterBoxOptions Rasterize RasterSize Rational RationalFunctions Rationalize Rationals Ratios Raw RawArray RawBoxes RawData RawMedium RayleighDistribution Re Read ReadList ReadProtected Real RealBlockDiagonalForm RealDigits RealExponent Reals Reap Record RecordLists RecordSeparators Rectangle RectangleBox RectangleBoxOptions RectangleChart RectangleChart3D RecurrenceFilter RecurrenceTable RecurringDigitsForm Red Reduce RefBox ReferenceLineStyle ReferenceMarkers ReferenceMarkerStyle Refine ReflectionMatrix ReflectionTransform Refresh RefreshRate RegionBinarize RegionFunction RegionPlot RegionPlot3D RegularExpression Regularization Reinstall Release ReleaseHold ReliabilityDistribution ReliefImage ReliefPlot Remove RemoveAlphaChannel RemoveAsynchronousTask Removed RemoveInputStreamMethod RemoveOutputStreamMethod RemoveProperty RemoveScheduledTask RenameDirectory RenameFile RenderAll RenderingOptions RenewalProcess RenkoChart Repeated RepeatedNull RepeatedString Replace ReplaceAll ReplaceHeldPart ReplaceImageValue ReplaceList ReplacePart ReplacePixelValue ReplaceRepeated Resampling Rescale RescalingTransform ResetDirectory ResetMenusPacket ResetScheduledTask Residue Resolve Rest Resultant ResumePacket Return ReturnExpressionPacket ReturnInputFormPacket ReturnPacket ReturnTextPacket Reverse ReverseBiorthogonalSplineWavelet ReverseElement ReverseEquilibrium ReverseGraph ReverseUpEquilibrium RevolutionAxis RevolutionPlot3D RGBColor RiccatiSolve RiceDistribution RidgeFilter RiemannR RiemannSiegelTheta RiemannSiegelZ Riffle Right RightArrow RightArrowBar RightArrowLeftArrow RightCosetRepresentative RightDownTeeVector RightDownVector RightDownVectorBar RightTee RightTeeArrow RightTeeVector RightTriangle RightTriangleBar RightTriangleEqual RightUpDownVector RightUpTeeVector RightUpVector RightUpVectorBar RightVector RightVectorBar RiskAchievementImportance RiskReductionImportance RogersTanimotoDissimilarity Root RootApproximant RootIntervals RootLocusPlot RootMeanSquare RootOfUnityQ RootReduce Roots RootSum Rotate RotateLabel RotateLeft RotateRight RotationAction RotationBox RotationBoxOptions RotationMatrix RotationTransform Round RoundImplies RoundingRadius Row RowAlignments RowBackgrounds RowBox RowHeights RowLines RowMinHeight RowReduce RowsEqual RowSpacings RSolve RudvalisGroupRu Rule RuleCondition RuleDelayed RuleForm RulerUnits Run RunScheduledTask RunThrough RuntimeAttributes RuntimeOptions RussellRaoDissimilarity SameQ SameTest SampleDepth SampledSoundFunction SampledSoundList SampleRate SamplingPeriod SARIMAProcess SARMAProcess SatisfiabilityCount SatisfiabilityInstances SatisfiableQ Saturday Save Saveable SaveAutoDelete SaveDefinitions SawtoothWave Scale Scaled ScaleDivisions ScaledMousePosition ScaleOrigin ScalePadding ScaleRanges ScaleRangeStyle ScalingFunctions ScalingMatrix ScalingTransform Scan ScheduledTaskActiveQ ScheduledTaskData ScheduledTaskObject ScheduledTasks SchurDecomposition ScientificForm ScreenRectangle ScreenStyleEnvironment ScriptBaselineShifts ScriptLevel ScriptMinSize ScriptRules ScriptSizeMultipliers Scrollbars ScrollingOptions ScrollPosition Sec Sech SechDistribution SectionGrouping SectorChart SectorChart3D SectorOrigin SectorSpacing SeedRandom Select Selectable SelectComponents SelectedCells SelectedNotebook Selection SelectionAnimate SelectionCell SelectionCellCreateCell SelectionCellDefaultStyle SelectionCellParentStyle SelectionCreateCell SelectionDebuggerTag SelectionDuplicateCell SelectionEvaluate SelectionEvaluateCreateCell SelectionMove SelectionPlaceholder SelectionSetStyle SelectWithContents SelfLoops SelfLoopStyle SemialgebraicComponentInstances SendMail Sequence SequenceAlignment SequenceForm SequenceHold SequenceLimit Series SeriesCoefficient SeriesData SessionTime Set SetAccuracy SetAlphaChannel SetAttributes Setbacks SetBoxFormNamesPacket SetDelayed SetDirectory SetEnvironment SetEvaluationNotebook SetFileDate SetFileLoadingContext SetNotebookStatusLine SetOptions SetOptionsPacket SetPrecision SetProperty SetSelectedNotebook SetSharedFunction SetSharedVariable SetSpeechParametersPacket SetStreamPosition SetSystemOptions Setter SetterBar SetterBox SetterBoxOptions Setting SetValue Shading Shallow ShannonWavelet ShapiroWilkTest Share Sharpen ShearingMatrix ShearingTransform ShenCastanMatrix Short ShortDownArrow Shortest ShortestMatch ShortestPathFunction ShortLeftArrow ShortRightArrow ShortUpArrow Show ShowAutoStyles ShowCellBracket ShowCellLabel ShowCellTags ShowClosedCellArea ShowContents ShowControls ShowCursorTracker ShowGroupOpenCloseIcon ShowGroupOpener ShowInvisibleCharacters ShowPageBreaks ShowPredictiveInterface ShowSelection ShowShortBoxForm ShowSpecialCharacters ShowStringCharacters ShowSyntaxStyles ShrinkingDelay ShrinkWrapBoundingBox SiegelTheta SiegelTukeyTest Sign Signature SignedRankTest SignificanceLevel SignPadding SignTest SimilarityRules SimpleGraph SimpleGraphQ Simplify Sin Sinc SinghMaddalaDistribution SingleEvaluation SingleLetterItalics SingleLetterStyle SingularValueDecomposition SingularValueList SingularValuePlot SingularValues Sinh SinhIntegral SinIntegral SixJSymbol Skeleton SkeletonTransform SkellamDistribution Skewness SkewNormalDistribution Skip SliceDistribution Slider Slider2D Slider2DBox Slider2DBoxOptions SliderBox SliderBoxOptions SlideView Slot SlotSequence Small SmallCircle Smaller SmithDelayCompensator SmithWatermanSimilarity SmoothDensityHistogram SmoothHistogram SmoothHistogram3D SmoothKernelDistribution SocialMediaData Socket SokalSneathDissimilarity Solve SolveAlways SolveDelayed Sort SortBy Sound SoundAndGraphics SoundNote SoundVolume Sow Space SpaceForm Spacer Spacings Span SpanAdjustments SpanCharacterRounding SpanFromAbove SpanFromBoth SpanFromLeft SpanLineThickness SpanMaxSize SpanMinSize SpanningCharacters SpanSymmetric SparseArray SpatialGraphDistribution Speak SpeakTextPacket SpearmanRankTest SpearmanRho Spectrogram SpectrogramArray Specularity SpellingCorrection SpellingDictionaries SpellingDictionariesPath SpellingOptions SpellingSuggestionsPacket Sphere SphereBox SphericalBesselJ SphericalBesselY SphericalHankelH1 SphericalHankelH2 SphericalHarmonicY SphericalPlot3D SphericalRegion SpheroidalEigenvalue SpheroidalJoiningFactor SpheroidalPS SpheroidalPSPrime SpheroidalQS SpheroidalQSPrime SpheroidalRadialFactor SpheroidalS1 SpheroidalS1Prime SpheroidalS2 SpheroidalS2Prime Splice SplicedDistribution SplineClosed SplineDegree SplineKnots SplineWeights Split SplitBy SpokenString Sqrt SqrtBox SqrtBoxOptions Square SquaredEuclideanDistance SquareFreeQ SquareIntersection SquaresR SquareSubset SquareSubsetEqual SquareSuperset SquareSupersetEqual SquareUnion SquareWave StabilityMargins StabilityMarginsStyle StableDistribution Stack StackBegin StackComplete StackInhibit StandardDeviation StandardDeviationFilter StandardForm Standardize StandbyDistribution Star StarGraph StartAsynchronousTask StartingStepSize StartOfLine StartOfString StartScheduledTask StartupSound StateDimensions StateFeedbackGains StateOutputEstimator StateResponse StateSpaceModel StateSpaceRealization StateSpaceTransform StationaryDistribution StationaryWaveletPacketTransform StationaryWaveletTransform StatusArea StatusCentrality StepMonitor StieltjesGamma StirlingS1 StirlingS2 StopAsynchronousTask StopScheduledTask StrataVariables StratonovichProcess StreamColorFunction StreamColorFunctionScaling StreamDensityPlot StreamPlot StreamPoints StreamPosition Streams StreamScale StreamStyle String StringBreak StringByteCount StringCases StringCount StringDrop StringExpression StringForm StringFormat StringFreeQ StringInsert StringJoin StringLength StringMatchQ StringPosition StringQ StringReplace StringReplaceList StringReplacePart StringReverse StringRotateLeft StringRotateRight StringSkeleton StringSplit StringTake StringToStream StringTrim StripBoxes StripOnInput StripWrapperBoxes StrokeForm StructuralImportance StructuredArray StructuredSelection StruveH StruveL Stub StudentTDistribution Style StyleBox StyleBoxAutoDelete StyleBoxOptions StyleData StyleDefinitions StyleForm StyleKeyMapping StyleMenuListing StyleNameDialogSettings StyleNames StylePrint StyleSheetPath Subfactorial Subgraph SubMinus SubPlus SubresultantPolynomialRemainders SubresultantPolynomials Subresultants Subscript SubscriptBox SubscriptBoxOptions Subscripted Subset SubsetEqual Subsets SubStar Subsuperscript SubsuperscriptBox SubsuperscriptBoxOptions Subtract SubtractFrom SubValues Succeeds SucceedsEqual SucceedsSlantEqual SucceedsTilde SuchThat Sum SumConvergence Sunday SuperDagger SuperMinus SuperPlus Superscript SuperscriptBox SuperscriptBoxOptions Superset SupersetEqual SuperStar Surd SurdForm SurfaceColor SurfaceGraphics SurvivalDistribution SurvivalFunction SurvivalModel SurvivalModelFit SuspendPacket SuzukiDistribution SuzukiGroupSuz SwatchLegend Switch Symbol SymbolName SymletWavelet Symmetric SymmetricGroup SymmetricMatrixQ SymmetricPolynomial SymmetricReduction Symmetrize SymmetrizedArray SymmetrizedArrayRules SymmetrizedDependentComponents SymmetrizedIndependentComponents SymmetrizedReplacePart SynchronousInitialization SynchronousUpdating Syntax SyntaxForm SyntaxInformation SyntaxLength SyntaxPacket SyntaxQ SystemDialogInput SystemException SystemHelpPath SystemInformation SystemInformationData SystemOpen SystemOptions SystemsModelDelay SystemsModelDelayApproximate SystemsModelDelete SystemsModelDimensions SystemsModelExtract SystemsModelFeedbackConnect SystemsModelLabels SystemsModelOrder SystemsModelParallelConnect SystemsModelSeriesConnect SystemsModelStateFeedbackConnect SystemStub Tab TabFilling Table TableAlignments TableDepth TableDirections TableForm TableHeadings TableSpacing TableView TableViewBox TabSpacings TabView TabViewBox TabViewBoxOptions TagBox TagBoxNote TagBoxOptions TaggingRules TagSet TagSetDelayed TagStyle TagUnset Take TakeWhile Tally Tan Tanh TargetFunctions TargetUnits TautologyQ TelegraphProcess TemplateBox TemplateBoxOptions TemplateSlotSequence TemporalData Temporary TemporaryVariable TensorContract TensorDimensions TensorExpand TensorProduct TensorQ TensorRank TensorReduce TensorSymmetry TensorTranspose TensorWedge Tetrahedron TetrahedronBox TetrahedronBoxOptions TeXForm TeXSave Text Text3DBox Text3DBoxOptions TextAlignment TextBand TextBoundingBox TextBox TextCell TextClipboardType TextData TextForm TextJustification TextLine TextPacket TextParagraph TextRecognize TextRendering TextStyle Texture TextureCoordinateFunction TextureCoordinateScaling Therefore ThermometerGauge Thick Thickness Thin Thinning ThisLink ThompsonGroupTh Thread ThreeJSymbol Threshold Through Throw Thumbnail Thursday Ticks TicksStyle Tilde TildeEqual TildeFullEqual TildeTilde TimeConstrained TimeConstraint Times TimesBy TimeSeriesForecast TimeSeriesInvertibility TimeUsed TimeValue TimeZone Timing Tiny TitleGrouping TitsGroupT ToBoxes ToCharacterCode ToColor ToContinuousTimeModel ToDate ToDiscreteTimeModel ToeplitzMatrix ToExpression ToFileName Together Toggle ToggleFalse Toggler TogglerBar TogglerBox TogglerBoxOptions ToHeldExpression ToInvertibleTimeSeries TokenWords Tolerance ToLowerCase ToNumberField TooBig Tooltip TooltipBox TooltipBoxOptions TooltipDelay TooltipStyle Top TopHatTransform TopologicalSort ToRadicals ToRules ToString Total TotalHeight TotalVariationFilter TotalWidth TouchscreenAutoZoom TouchscreenControlPlacement ToUpperCase Tr Trace TraceAbove TraceAction TraceBackward TraceDepth TraceDialog TraceForward TraceInternal TraceLevel TraceOff TraceOn TraceOriginal TracePrint TraceScan TrackedSymbols TradingChart TraditionalForm TraditionalFunctionNotation TraditionalNotation TraditionalOrder TransferFunctionCancel TransferFunctionExpand TransferFunctionFactor TransferFunctionModel TransferFunctionPoles TransferFunctionTransform TransferFunctionZeros TransformationFunction TransformationFunctions TransformationMatrix TransformedDistribution TransformedField Translate TranslationTransform TransparentColor Transpose TreeForm TreeGraph TreeGraphQ TreePlot TrendStyle TriangleWave TriangularDistribution Trig TrigExpand TrigFactor TrigFactorList Trigger TrigReduce TrigToExp TrimmedMean True TrueQ TruncatedDistribution TsallisQExponentialDistribution TsallisQGaussianDistribution TTest Tube TubeBezierCurveBox TubeBezierCurveBoxOptions TubeBox TubeBSplineCurveBox TubeBSplineCurveBoxOptions Tuesday TukeyLambdaDistribution TukeyWindow Tuples TuranGraph TuringMachine Transparent UnateQ Uncompress Undefined UnderBar Underflow Underlined Underoverscript UnderoverscriptBox UnderoverscriptBoxOptions Underscript UnderscriptBox UnderscriptBoxOptions UndirectedEdge UndirectedGraph UndirectedGraphQ UndocumentedTestFEParserPacket UndocumentedTestGetSelectionPacket Unequal Unevaluated UniformDistribution UniformGraphDistribution UniformSumDistribution Uninstall Union UnionPlus Unique UnitBox UnitConvert UnitDimensions Unitize UnitRootTest UnitSimplify UnitStep UnitTriangle UnitVector Unprotect UnsameQ UnsavedVariables Unset UnsetShared UntrackedVariables Up UpArrow UpArrowBar UpArrowDownArrow Update UpdateDynamicObjects UpdateDynamicObjectsSynchronous UpdateInterval UpDownArrow UpEquilibrium UpperCaseQ UpperLeftArrow UpperRightArrow UpperTriangularize Upsample UpSet UpSetDelayed UpTee UpTeeArrow UpValues URL URLFetch URLFetchAsynchronous URLSave URLSaveAsynchronous UseGraphicsRange Using UsingFrontEnd V2Get ValidationLength Value ValueBox ValueBoxOptions ValueForm ValueQ ValuesData Variables Variance VarianceEquivalenceTest VarianceEstimatorFunction VarianceGammaDistribution VarianceTest VectorAngle VectorColorFunction VectorColorFunctionScaling VectorDensityPlot VectorGlyphData VectorPlot VectorPlot3D VectorPoints VectorQ Vectors VectorScale VectorStyle Vee Verbatim Verbose VerboseConvertToPostScriptPacket VerifyConvergence VerifySolutions VerifyTestAssumptions Version VersionNumber VertexAdd VertexCapacity VertexColors VertexComponent VertexConnectivity VertexCoordinateRules VertexCoordinates VertexCorrelationSimilarity VertexCosineSimilarity VertexCount VertexCoverQ VertexDataCoordinates VertexDegree VertexDelete VertexDiceSimilarity VertexEccentricity VertexInComponent VertexInDegree VertexIndex VertexJaccardSimilarity VertexLabeling VertexLabels VertexLabelStyle VertexList VertexNormals VertexOutComponent VertexOutDegree VertexQ VertexRenderingFunction VertexReplace VertexShape VertexShapeFunction VertexSize VertexStyle VertexTextureCoordinates VertexWeight Vertical VerticalBar VerticalForm VerticalGauge VerticalSeparator VerticalSlider VerticalTilde ViewAngle ViewCenter ViewMatrix ViewPoint ViewPointSelectorSettings ViewPort ViewRange ViewVector ViewVertical VirtualGroupData Visible VisibleCell VoigtDistribution VonMisesDistribution WaitAll WaitAsynchronousTask WaitNext WaitUntil WakebyDistribution WalleniusHypergeometricDistribution WaringYuleDistribution WatershedComponents WatsonUSquareTest WattsStrogatzGraphDistribution WaveletBestBasis WaveletFilterCoefficients WaveletImagePlot WaveletListPlot WaveletMapIndexed WaveletMatrixPlot WaveletPhi WaveletPsi WaveletScale WaveletScalogram WaveletThreshold WeaklyConnectedComponents WeaklyConnectedGraphQ WeakStationarity WeatherData WeberE Wedge Wednesday WeibullDistribution WeierstrassHalfPeriods WeierstrassInvariants WeierstrassP WeierstrassPPrime WeierstrassSigma WeierstrassZeta WeightedAdjacencyGraph WeightedAdjacencyMatrix WeightedData WeightedGraphQ Weights WelchWindow WheelGraph WhenEvent Which While White Whitespace WhitespaceCharacter WhittakerM WhittakerW WienerFilter WienerProcess WignerD WignerSemicircleDistribution WilksW WilksWTest WindowClickSelect WindowElements WindowFloating WindowFrame WindowFrameElements WindowMargins WindowMovable WindowOpacity WindowSelected WindowSize WindowStatusArea WindowTitle WindowToolbars WindowWidth With WolframAlpha WolframAlphaDate WolframAlphaQuantity WolframAlphaResult Word WordBoundary WordCharacter WordData WordSearch WordSeparators WorkingPrecision Write WriteString Wronskian XMLElement XMLObject Xnor Xor Yellow YuleDissimilarity ZernikeR ZeroSymmetric ZeroTest ZeroWidthTimes Zeta ZetaZero ZipfDistribution ZTest ZTransform $Aborted $ActivationGroupID $ActivationKey $ActivationUserRegistered $AddOnsDirectory $AssertFunction $Assumptions $AsynchronousTask $BaseDirectory $BatchInput $BatchOutput $BoxForms $ByteOrdering $Canceled $CharacterEncoding $CharacterEncodings $CommandLine $CompilationTarget $ConditionHold $ConfiguredKernels $Context $ContextPath $ControlActiveSetting $CreationDate $CurrentLink $DateStringFormat $DefaultFont $DefaultFrontEnd $DefaultImagingDevice $DefaultPath $Display $DisplayFunction $DistributedContexts $DynamicEvaluation $Echo $Epilog $ExportFormats $Failed $FinancialDataSource $FormatType $FrontEnd $FrontEndSession $GeoLocation $HistoryLength $HomeDirectory $HTTPCookies $IgnoreEOF $ImagingDevices $ImportFormats $InitialDirectory $Input $InputFileName $InputStreamMethods $Inspector $InstallationDate $InstallationDirectory $InterfaceEnvironment $IterationLimit $KernelCount $KernelID $Language $LaunchDirectory $LibraryPath $LicenseExpirationDate $LicenseID $LicenseProcesses $LicenseServer $LicenseSubprocesses $LicenseType $Line $Linked $LinkSupported $LoadedFiles $MachineAddresses $MachineDomain $MachineDomains $MachineEpsilon $MachineID $MachineName $MachinePrecision $MachineType $MaxExtraPrecision $MaxLicenseProcesses $MaxLicenseSubprocesses $MaxMachineNumber $MaxNumber $MaxPiecewiseCases $MaxPrecision $MaxRootDegree $MessageGroups $MessageList $MessagePrePrint $Messages $MinMachineNumber $MinNumber $MinorReleaseNumber $MinPrecision $ModuleNumber $NetworkLicense $NewMessage $NewSymbol $Notebooks $NumberMarks $Off $OperatingSystem $Output $OutputForms $OutputSizeLimit $OutputStreamMethods $Packages $ParentLink $ParentProcessID $PasswordFile $PatchLevelID $Path $PathnameSeparator $PerformanceGoal $PipeSupported $Post $Pre $PreferencesDirectory $PrePrint $PreRead $PrintForms $PrintLiteral $ProcessID $ProcessorCount $ProcessorType $ProductInformation $ProgramName $RandomState $RecursionLimit $ReleaseNumber $RootDirectory $ScheduledTask $ScriptCommandLine $SessionID $SetParentLink $SharedFunctions $SharedVariables $SoundDisplay $SoundDisplayFunction $SuppressInputFormHeads $SynchronousEvaluation $SyntaxHandler $System $SystemCharacterEncoding $SystemID $SystemWordLength $TemporaryDirectory $TemporaryPrefix $TextStyle $TimedOut $TimeUnit $TimeZone $TopDirectory $TraceOff $TraceOn $TracePattern $TracePostAction $TracePreAction $Urgent $UserAddOnsDirectory $UserBaseDirectory $UserDocumentsDirectory $UserName $Version $VersionNumber",c:[{cN:"comment",b:/\(\*/,e:/\*\)/},e.ASM,e.QSM,e.CNM,{b:/\{/,e:/\}/,i:/:/}]}});hljs.registerLanguage("haskell",function(e){var i={v:[e.C("--","$"),e.C("{-","-}",{c:["self"]})]},a={cN:"meta",b:"{-#",e:"#-}"},l={cN:"meta",b:"^#",e:"$"},c={cN:"type",b:"\\b[A-Z][\\w']*",r:0},n={b:"\\(",e:"\\)",i:'"',c:[a,l,{cN:"type",b:"\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?"},e.inherit(e.TM,{b:"[_a-z][\\w']*"}),i]};return{aliases:["hs"],k:"let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",c:[{bK:"module",e:"where",k:"module where",c:[n,i],i:"\\W\\.|;"},{b:"\\bimport\\b",e:"$",k:"import qualified as hiding",c:[n,i],i:"\\W\\.|;"},{cN:"class",b:"^(\\s*)?(class|instance)\\b",e:"where",k:"class family instance where",c:[c,n,i]},{cN:"class",b:"\\b(data|(new)?type)\\b",e:"$",k:"data family type newtype deriving",c:[a,c,n,{b:"{",e:"}",c:n.c},i]},{bK:"default",e:"$",c:[c,n,i]},{bK:"infix infixl infixr",e:"$",c:[e.CNM,i]},{b:"\\bforeign\\b",e:"$",k:"foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",c:[c,e.QSM,i]},{cN:"meta",b:"#!\\/usr\\/bin\\/env runhaskell",e:"$"},a,l,e.QSM,e.CNM,c,e.inherit(e.TM,{b:"^[_a-z][\\w']*"}),i,{b:"->|<-"}]}});hljs.registerLanguage("php",function(e){var c={b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},i={cN:"meta",b:/<\?(php)?|\?>/},t={cN:"string",c:[e.BE,i],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},a={v:[e.BNM,e.CNM]};return{aliases:["php","php3","php4","php5","php6","php7"],cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.HCM,e.C("//","$",{c:[i]}),e.C("/\\*","\\*/",{c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.C("__halt_compiler.+?;",!1,{eW:!0,k:"__halt_compiler",l:e.UIR}),{cN:"string",b:/<<<['"]?\w+['"]?$/,e:/^\w+;?$/,c:[e.BE,{cN:"subst",v:[{b:/\$\w+/},{b:/\{\$/,e:/\}/}]}]},i,{cN:"keyword",b:/\$this\b/},c,{b:/(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/},{cN:"function",bK:"function",e:/[;{]/,eE:!0,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",c,e.CBCM,t,a]}]},{cN:"class",bK:"class interface",e:"{",eE:!0,i:/[:\(\$"]/,c:[{bK:"extends implements"},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},t,a]}});hljs.registerLanguage("autohotkey",function(e){var r={b:"`[\\s\\S]"};return{cI:!0,aliases:["ahk"],k:{keyword:"Break Continue Critical Exit ExitApp Gosub Goto New OnExit Pause return SetBatchLines SetTimer Suspend Thread Throw Until ahk_id ahk_class ahk_pid ahk_exe ahk_group",literal:"A|0 true false NOT AND OR",built_in:"ComSpec Clipboard ClipboardAll ErrorLevel"},c:[{cN:"built_in",b:"A_[a-zA-Z0-9]+"},r,e.inherit(e.QSM,{c:[r]}),e.C(";","$",{r:0}),e.CBCM,{cN:"number",b:e.NR,r:0},{cN:"subst",b:"%(?=[a-zA-Z0-9#_$@])",e:"%",i:"[^a-zA-Z0-9#_$@]"},{cN:"built_in",b:"^\\s*\\w+\\s*,"},{cN:"meta",b:"^\\s*#w+",e:"$",r:0},{cN:"symbol",c:[r],v:[{b:'^[^\\n";]+::(?!=)'},{b:'^[^\\n";]+:(?!=)',r:0}]},{b:",\\s*,"}]}});hljs.registerLanguage("x86asm",function(s){return{cI:!0,l:"[.%]?"+s.IR,k:{keyword:"lock rep repe repz repne repnz xaquire xrelease bnd nobnd aaa aad aam aas adc add and arpl bb0_reset bb1_reset bound bsf bsr bswap bt btc btr bts call cbw cdq cdqe clc cld cli clts cmc cmp cmpsb cmpsd cmpsq cmpsw cmpxchg cmpxchg486 cmpxchg8b cmpxchg16b cpuid cpu_read cpu_write cqo cwd cwde daa das dec div dmint emms enter equ f2xm1 fabs fadd faddp fbld fbstp fchs fclex fcmovb fcmovbe fcmove fcmovnb fcmovnbe fcmovne fcmovnu fcmovu fcom fcomi fcomip fcomp fcompp fcos fdecstp fdisi fdiv fdivp fdivr fdivrp femms feni ffree ffreep fiadd ficom ficomp fidiv fidivr fild fimul fincstp finit fist fistp fisttp fisub fisubr fld fld1 fldcw fldenv fldl2e fldl2t fldlg2 fldln2 fldpi fldz fmul fmulp fnclex fndisi fneni fninit fnop fnsave fnstcw fnstenv fnstsw fpatan fprem fprem1 fptan frndint frstor fsave fscale fsetpm fsin fsincos fsqrt fst fstcw fstenv fstp fstsw fsub fsubp fsubr fsubrp ftst fucom fucomi fucomip fucomp fucompp fxam fxch fxtract fyl2x fyl2xp1 hlt ibts icebp idiv imul in inc incbin insb insd insw int int01 int1 int03 int3 into invd invpcid invlpg invlpga iret iretd iretq iretw jcxz jecxz jrcxz jmp jmpe lahf lar lds lea leave les lfence lfs lgdt lgs lidt lldt lmsw loadall loadall286 lodsb lodsd lodsq lodsw loop loope loopne loopnz loopz lsl lss ltr mfence monitor mov movd movq movsb movsd movsq movsw movsx movsxd movzx mul mwait neg nop not or out outsb outsd outsw packssdw packsswb packuswb paddb paddd paddsb paddsiw paddsw paddusb paddusw paddw pand pandn pause paveb pavgusb pcmpeqb pcmpeqd pcmpeqw pcmpgtb pcmpgtd pcmpgtw pdistib pf2id pfacc pfadd pfcmpeq pfcmpge pfcmpgt pfmax pfmin pfmul pfrcp pfrcpit1 pfrcpit2 pfrsqit1 pfrsqrt pfsub pfsubr pi2fd pmachriw pmaddwd pmagw pmulhriw pmulhrwa pmulhrwc pmulhw pmullw pmvgezb pmvlzb pmvnzb pmvzb pop popa popad popaw popf popfd popfq popfw por prefetch prefetchw pslld psllq psllw psrad psraw psrld psrlq psrlw psubb psubd psubsb psubsiw psubsw psubusb psubusw psubw punpckhbw punpckhdq punpckhwd punpcklbw punpckldq punpcklwd push pusha pushad pushaw pushf pushfd pushfq pushfw pxor rcl rcr rdshr rdmsr rdpmc rdtsc rdtscp ret retf retn rol ror rdm rsdc rsldt rsm rsts sahf sal salc sar sbb scasb scasd scasq scasw sfence sgdt shl shld shr shrd sidt sldt skinit smi smint smintold smsw stc std sti stosb stosd stosq stosw str sub svdc svldt svts swapgs syscall sysenter sysexit sysret test ud0 ud1 ud2b ud2 ud2a umov verr verw fwait wbinvd wrshr wrmsr xadd xbts xchg xlatb xlat xor cmove cmovz cmovne cmovnz cmova cmovnbe cmovae cmovnb cmovb cmovnae cmovbe cmovna cmovg cmovnle cmovge cmovnl cmovl cmovnge cmovle cmovng cmovc cmovnc cmovo cmovno cmovs cmovns cmovp cmovpe cmovnp cmovpo je jz jne jnz ja jnbe jae jnb jb jnae jbe jna jg jnle jge jnl jl jnge jle jng jc jnc jo jno js jns jpo jnp jpe jp sete setz setne setnz seta setnbe setae setnb setnc setb setnae setcset setbe setna setg setnle setge setnl setl setnge setle setng sets setns seto setno setpe setp setpo setnp addps addss andnps andps cmpeqps cmpeqss cmpleps cmpless cmpltps cmpltss cmpneqps cmpneqss cmpnleps cmpnless cmpnltps cmpnltss cmpordps cmpordss cmpunordps cmpunordss cmpps cmpss comiss cvtpi2ps cvtps2pi cvtsi2ss cvtss2si cvttps2pi cvttss2si divps divss ldmxcsr maxps maxss minps minss movaps movhps movlhps movlps movhlps movmskps movntps movss movups mulps mulss orps rcpps rcpss rsqrtps rsqrtss shufps sqrtps sqrtss stmxcsr subps subss ucomiss unpckhps unpcklps xorps fxrstor fxrstor64 fxsave fxsave64 xgetbv xsetbv xsave xsave64 xsaveopt xsaveopt64 xrstor xrstor64 prefetchnta prefetcht0 prefetcht1 prefetcht2 maskmovq movntq pavgb pavgw pextrw pinsrw pmaxsw pmaxub pminsw pminub pmovmskb pmulhuw psadbw pshufw pf2iw pfnacc pfpnacc pi2fw pswapd maskmovdqu clflush movntdq movnti movntpd movdqa movdqu movdq2q movq2dq paddq pmuludq pshufd pshufhw pshuflw pslldq psrldq psubq punpckhqdq punpcklqdq addpd addsd andnpd andpd cmpeqpd cmpeqsd cmplepd cmplesd cmpltpd cmpltsd cmpneqpd cmpneqsd cmpnlepd cmpnlesd cmpnltpd cmpnltsd cmpordpd cmpordsd cmpunordpd cmpunordsd cmppd comisd cvtdq2pd cvtdq2ps cvtpd2dq cvtpd2pi cvtpd2ps cvtpi2pd cvtps2dq cvtps2pd cvtsd2si cvtsd2ss cvtsi2sd cvtss2sd cvttpd2pi cvttpd2dq cvttps2dq cvttsd2si divpd divsd maxpd maxsd minpd minsd movapd movhpd movlpd movmskpd movupd mulpd mulsd orpd shufpd sqrtpd sqrtsd subpd subsd ucomisd unpckhpd unpcklpd xorpd addsubpd addsubps haddpd haddps hsubpd hsubps lddqu movddup movshdup movsldup clgi stgi vmcall vmclear vmfunc vmlaunch vmload vmmcall vmptrld vmptrst vmread vmresume vmrun vmsave vmwrite vmxoff vmxon invept invvpid pabsb pabsw pabsd palignr phaddw phaddd phaddsw phsubw phsubd phsubsw pmaddubsw pmulhrsw pshufb psignb psignw psignd extrq insertq movntsd movntss lzcnt blendpd blendps blendvpd blendvps dppd dpps extractps insertps movntdqa mpsadbw packusdw pblendvb pblendw pcmpeqq pextrb pextrd pextrq phminposuw pinsrb pinsrd pinsrq pmaxsb pmaxsd pmaxud pmaxuw pminsb pminsd pminud pminuw pmovsxbw pmovsxbd pmovsxbq pmovsxwd pmovsxwq pmovsxdq pmovzxbw pmovzxbd pmovzxbq pmovzxwd pmovzxwq pmovzxdq pmuldq pmulld ptest roundpd roundps roundsd roundss crc32 pcmpestri pcmpestrm pcmpistri pcmpistrm pcmpgtq popcnt getsec pfrcpv pfrsqrtv movbe aesenc aesenclast aesdec aesdeclast aesimc aeskeygenassist vaesenc vaesenclast vaesdec vaesdeclast vaesimc vaeskeygenassist vaddpd vaddps vaddsd vaddss vaddsubpd vaddsubps vandpd vandps vandnpd vandnps vblendpd vblendps vblendvpd vblendvps vbroadcastss vbroadcastsd vbroadcastf128 vcmpeq_ospd vcmpeqpd vcmplt_ospd vcmpltpd vcmple_ospd vcmplepd vcmpunord_qpd vcmpunordpd vcmpneq_uqpd vcmpneqpd vcmpnlt_uspd vcmpnltpd vcmpnle_uspd vcmpnlepd vcmpord_qpd vcmpordpd vcmpeq_uqpd vcmpnge_uspd vcmpngepd vcmpngt_uspd vcmpngtpd vcmpfalse_oqpd vcmpfalsepd vcmpneq_oqpd vcmpge_ospd vcmpgepd vcmpgt_ospd vcmpgtpd vcmptrue_uqpd vcmptruepd vcmplt_oqpd vcmple_oqpd vcmpunord_spd vcmpneq_uspd vcmpnlt_uqpd vcmpnle_uqpd vcmpord_spd vcmpeq_uspd vcmpnge_uqpd vcmpngt_uqpd vcmpfalse_ospd vcmpneq_ospd vcmpge_oqpd vcmpgt_oqpd vcmptrue_uspd vcmppd vcmpeq_osps vcmpeqps vcmplt_osps vcmpltps vcmple_osps vcmpleps vcmpunord_qps vcmpunordps vcmpneq_uqps vcmpneqps vcmpnlt_usps vcmpnltps vcmpnle_usps vcmpnleps vcmpord_qps vcmpordps vcmpeq_uqps vcmpnge_usps vcmpngeps vcmpngt_usps vcmpngtps vcmpfalse_oqps vcmpfalseps vcmpneq_oqps vcmpge_osps vcmpgeps vcmpgt_osps vcmpgtps vcmptrue_uqps vcmptrueps vcmplt_oqps vcmple_oqps vcmpunord_sps vcmpneq_usps vcmpnlt_uqps vcmpnle_uqps vcmpord_sps vcmpeq_usps vcmpnge_uqps vcmpngt_uqps vcmpfalse_osps vcmpneq_osps vcmpge_oqps vcmpgt_oqps vcmptrue_usps vcmpps vcmpeq_ossd vcmpeqsd vcmplt_ossd vcmpltsd vcmple_ossd vcmplesd vcmpunord_qsd vcmpunordsd vcmpneq_uqsd vcmpneqsd vcmpnlt_ussd vcmpnltsd vcmpnle_ussd vcmpnlesd vcmpord_qsd vcmpordsd vcmpeq_uqsd vcmpnge_ussd vcmpngesd vcmpngt_ussd vcmpngtsd vcmpfalse_oqsd vcmpfalsesd vcmpneq_oqsd vcmpge_ossd vcmpgesd vcmpgt_ossd vcmpgtsd vcmptrue_uqsd vcmptruesd vcmplt_oqsd vcmple_oqsd vcmpunord_ssd vcmpneq_ussd vcmpnlt_uqsd vcmpnle_uqsd vcmpord_ssd vcmpeq_ussd vcmpnge_uqsd vcmpngt_uqsd vcmpfalse_ossd vcmpneq_ossd vcmpge_oqsd vcmpgt_oqsd vcmptrue_ussd vcmpsd vcmpeq_osss vcmpeqss vcmplt_osss vcmpltss vcmple_osss vcmpless vcmpunord_qss vcmpunordss vcmpneq_uqss vcmpneqss vcmpnlt_usss vcmpnltss vcmpnle_usss vcmpnless vcmpord_qss vcmpordss vcmpeq_uqss vcmpnge_usss vcmpngess vcmpngt_usss vcmpngtss vcmpfalse_oqss vcmpfalsess vcmpneq_oqss vcmpge_osss vcmpgess vcmpgt_osss vcmpgtss vcmptrue_uqss vcmptruess vcmplt_oqss vcmple_oqss vcmpunord_sss vcmpneq_usss vcmpnlt_uqss vcmpnle_uqss vcmpord_sss vcmpeq_usss vcmpnge_uqss vcmpngt_uqss vcmpfalse_osss vcmpneq_osss vcmpge_oqss vcmpgt_oqss vcmptrue_usss vcmpss vcomisd vcomiss vcvtdq2pd vcvtdq2ps vcvtpd2dq vcvtpd2ps vcvtps2dq vcvtps2pd vcvtsd2si vcvtsd2ss vcvtsi2sd vcvtsi2ss vcvtss2sd vcvtss2si vcvttpd2dq vcvttps2dq vcvttsd2si vcvttss2si vdivpd vdivps vdivsd vdivss vdppd vdpps vextractf128 vextractps vhaddpd vhaddps vhsubpd vhsubps vinsertf128 vinsertps vlddqu vldqqu vldmxcsr vmaskmovdqu vmaskmovps vmaskmovpd vmaxpd vmaxps vmaxsd vmaxss vminpd vminps vminsd vminss vmovapd vmovaps vmovd vmovq vmovddup vmovdqa vmovqqa vmovdqu vmovqqu vmovhlps vmovhpd vmovhps vmovlhps vmovlpd vmovlps vmovmskpd vmovmskps vmovntdq vmovntqq vmovntdqa vmovntpd vmovntps vmovsd vmovshdup vmovsldup vmovss vmovupd vmovups vmpsadbw vmulpd vmulps vmulsd vmulss vorpd vorps vpabsb vpabsw vpabsd vpacksswb vpackssdw vpackuswb vpackusdw vpaddb vpaddw vpaddd vpaddq vpaddsb vpaddsw vpaddusb vpaddusw vpalignr vpand vpandn vpavgb vpavgw vpblendvb vpblendw vpcmpestri vpcmpestrm vpcmpistri vpcmpistrm vpcmpeqb vpcmpeqw vpcmpeqd vpcmpeqq vpcmpgtb vpcmpgtw vpcmpgtd vpcmpgtq vpermilpd vpermilps vperm2f128 vpextrb vpextrw vpextrd vpextrq vphaddw vphaddd vphaddsw vphminposuw vphsubw vphsubd vphsubsw vpinsrb vpinsrw vpinsrd vpinsrq vpmaddwd vpmaddubsw vpmaxsb vpmaxsw vpmaxsd vpmaxub vpmaxuw vpmaxud vpminsb vpminsw vpminsd vpminub vpminuw vpminud vpmovmskb vpmovsxbw vpmovsxbd vpmovsxbq vpmovsxwd vpmovsxwq vpmovsxdq vpmovzxbw vpmovzxbd vpmovzxbq vpmovzxwd vpmovzxwq vpmovzxdq vpmulhuw vpmulhrsw vpmulhw vpmullw vpmulld vpmuludq vpmuldq vpor vpsadbw vpshufb vpshufd vpshufhw vpshuflw vpsignb vpsignw vpsignd vpslldq vpsrldq vpsllw vpslld vpsllq vpsraw vpsrad vpsrlw vpsrld vpsrlq vptest vpsubb vpsubw vpsubd vpsubq vpsubsb vpsubsw vpsubusb vpsubusw vpunpckhbw vpunpckhwd vpunpckhdq vpunpckhqdq vpunpcklbw vpunpcklwd vpunpckldq vpunpcklqdq vpxor vrcpps vrcpss vrsqrtps vrsqrtss vroundpd vroundps vroundsd vroundss vshufpd vshufps vsqrtpd vsqrtps vsqrtsd vsqrtss vstmxcsr vsubpd vsubps vsubsd vsubss vtestps vtestpd vucomisd vucomiss vunpckhpd vunpckhps vunpcklpd vunpcklps vxorpd vxorps vzeroall vzeroupper pclmullqlqdq pclmulhqlqdq pclmullqhqdq pclmulhqhqdq pclmulqdq vpclmullqlqdq vpclmulhqlqdq vpclmullqhqdq vpclmulhqhqdq vpclmulqdq vfmadd132ps vfmadd132pd vfmadd312ps vfmadd312pd vfmadd213ps vfmadd213pd vfmadd123ps vfmadd123pd vfmadd231ps vfmadd231pd vfmadd321ps vfmadd321pd vfmaddsub132ps vfmaddsub132pd vfmaddsub312ps vfmaddsub312pd vfmaddsub213ps vfmaddsub213pd vfmaddsub123ps vfmaddsub123pd vfmaddsub231ps vfmaddsub231pd vfmaddsub321ps vfmaddsub321pd vfmsub132ps vfmsub132pd vfmsub312ps vfmsub312pd vfmsub213ps vfmsub213pd vfmsub123ps vfmsub123pd vfmsub231ps vfmsub231pd vfmsub321ps vfmsub321pd vfmsubadd132ps vfmsubadd132pd vfmsubadd312ps vfmsubadd312pd vfmsubadd213ps vfmsubadd213pd vfmsubadd123ps vfmsubadd123pd vfmsubadd231ps vfmsubadd231pd vfmsubadd321ps vfmsubadd321pd vfnmadd132ps vfnmadd132pd vfnmadd312ps vfnmadd312pd vfnmadd213ps vfnmadd213pd vfnmadd123ps vfnmadd123pd vfnmadd231ps vfnmadd231pd vfnmadd321ps vfnmadd321pd vfnmsub132ps vfnmsub132pd vfnmsub312ps vfnmsub312pd vfnmsub213ps vfnmsub213pd vfnmsub123ps vfnmsub123pd vfnmsub231ps vfnmsub231pd vfnmsub321ps vfnmsub321pd vfmadd132ss vfmadd132sd vfmadd312ss vfmadd312sd vfmadd213ss vfmadd213sd vfmadd123ss vfmadd123sd vfmadd231ss vfmadd231sd vfmadd321ss vfmadd321sd vfmsub132ss vfmsub132sd vfmsub312ss vfmsub312sd vfmsub213ss vfmsub213sd vfmsub123ss vfmsub123sd vfmsub231ss vfmsub231sd vfmsub321ss vfmsub321sd vfnmadd132ss vfnmadd132sd vfnmadd312ss vfnmadd312sd vfnmadd213ss vfnmadd213sd vfnmadd123ss vfnmadd123sd vfnmadd231ss vfnmadd231sd vfnmadd321ss vfnmadd321sd vfnmsub132ss vfnmsub132sd vfnmsub312ss vfnmsub312sd vfnmsub213ss vfnmsub213sd vfnmsub123ss vfnmsub123sd vfnmsub231ss vfnmsub231sd vfnmsub321ss vfnmsub321sd rdfsbase rdgsbase rdrand wrfsbase wrgsbase vcvtph2ps vcvtps2ph adcx adox rdseed clac stac xstore xcryptecb xcryptcbc xcryptctr xcryptcfb xcryptofb montmul xsha1 xsha256 llwpcb slwpcb lwpval lwpins vfmaddpd vfmaddps vfmaddsd vfmaddss vfmaddsubpd vfmaddsubps vfmsubaddpd vfmsubaddps vfmsubpd vfmsubps vfmsubsd vfmsubss vfnmaddpd vfnmaddps vfnmaddsd vfnmaddss vfnmsubpd vfnmsubps vfnmsubsd vfnmsubss vfrczpd vfrczps vfrczsd vfrczss vpcmov vpcomb vpcomd vpcomq vpcomub vpcomud vpcomuq vpcomuw vpcomw vphaddbd vphaddbq vphaddbw vphadddq vphaddubd vphaddubq vphaddubw vphaddudq vphadduwd vphadduwq vphaddwd vphaddwq vphsubbw vphsubdq vphsubwd vpmacsdd vpmacsdqh vpmacsdql vpmacssdd vpmacssdqh vpmacssdql vpmacsswd vpmacssww vpmacswd vpmacsww vpmadcsswd vpmadcswd vpperm vprotb vprotd vprotq vprotw vpshab vpshad vpshaq vpshaw vpshlb vpshld vpshlq vpshlw vbroadcasti128 vpblendd vpbroadcastb vpbroadcastw vpbroadcastd vpbroadcastq vpermd vpermpd vpermps vpermq vperm2i128 vextracti128 vinserti128 vpmaskmovd vpmaskmovq vpsllvd vpsllvq vpsravd vpsrlvd vpsrlvq vgatherdpd vgatherqpd vgatherdps vgatherqps vpgatherdd vpgatherqd vpgatherdq vpgatherqq xabort xbegin xend xtest andn bextr blci blcic blsi blsic blcfill blsfill blcmsk blsmsk blsr blcs bzhi mulx pdep pext rorx sarx shlx shrx tzcnt tzmsk t1mskc valignd valignq vblendmpd vblendmps vbroadcastf32x4 vbroadcastf64x4 vbroadcasti32x4 vbroadcasti64x4 vcompresspd vcompressps vcvtpd2udq vcvtps2udq vcvtsd2usi vcvtss2usi vcvttpd2udq vcvttps2udq vcvttsd2usi vcvttss2usi vcvtudq2pd vcvtudq2ps vcvtusi2sd vcvtusi2ss vexpandpd vexpandps vextractf32x4 vextractf64x4 vextracti32x4 vextracti64x4 vfixupimmpd vfixupimmps vfixupimmsd vfixupimmss vgetexppd vgetexpps vgetexpsd vgetexpss vgetmantpd vgetmantps vgetmantsd vgetmantss vinsertf32x4 vinsertf64x4 vinserti32x4 vinserti64x4 vmovdqa32 vmovdqa64 vmovdqu32 vmovdqu64 vpabsq vpandd vpandnd vpandnq vpandq vpblendmd vpblendmq vpcmpltd vpcmpled vpcmpneqd vpcmpnltd vpcmpnled vpcmpd vpcmpltq vpcmpleq vpcmpneqq vpcmpnltq vpcmpnleq vpcmpq vpcmpequd vpcmpltud vpcmpleud vpcmpnequd vpcmpnltud vpcmpnleud vpcmpud vpcmpequq vpcmpltuq vpcmpleuq vpcmpnequq vpcmpnltuq vpcmpnleuq vpcmpuq vpcompressd vpcompressq vpermi2d vpermi2pd vpermi2ps vpermi2q vpermt2d vpermt2pd vpermt2ps vpermt2q vpexpandd vpexpandq vpmaxsq vpmaxuq vpminsq vpminuq vpmovdb vpmovdw vpmovqb vpmovqd vpmovqw vpmovsdb vpmovsdw vpmovsqb vpmovsqd vpmovsqw vpmovusdb vpmovusdw vpmovusqb vpmovusqd vpmovusqw vpord vporq vprold vprolq vprolvd vprolvq vprord vprorq vprorvd vprorvq vpscatterdd vpscatterdq vpscatterqd vpscatterqq vpsraq vpsravq vpternlogd vpternlogq vptestmd vptestmq vptestnmd vptestnmq vpxord vpxorq vrcp14pd vrcp14ps vrcp14sd vrcp14ss vrndscalepd vrndscaleps vrndscalesd vrndscaless vrsqrt14pd vrsqrt14ps vrsqrt14sd vrsqrt14ss vscalefpd vscalefps vscalefsd vscalefss vscatterdpd vscatterdps vscatterqpd vscatterqps vshuff32x4 vshuff64x2 vshufi32x4 vshufi64x2 kandnw kandw kmovw knotw kortestw korw kshiftlw kshiftrw kunpckbw kxnorw kxorw vpbroadcastmb2q vpbroadcastmw2d vpconflictd vpconflictq vplzcntd vplzcntq vexp2pd vexp2ps vrcp28pd vrcp28ps vrcp28sd vrcp28ss vrsqrt28pd vrsqrt28ps vrsqrt28sd vrsqrt28ss vgatherpf0dpd vgatherpf0dps vgatherpf0qpd vgatherpf0qps vgatherpf1dpd vgatherpf1dps vgatherpf1qpd vgatherpf1qps vscatterpf0dpd vscatterpf0dps vscatterpf0qpd vscatterpf0qps vscatterpf1dpd vscatterpf1dps vscatterpf1qpd vscatterpf1qps prefetchwt1 bndmk bndcl bndcu bndcn bndmov bndldx bndstx sha1rnds4 sha1nexte sha1msg1 sha1msg2 sha256rnds2 sha256msg1 sha256msg2 hint_nop0 hint_nop1 hint_nop2 hint_nop3 hint_nop4 hint_nop5 hint_nop6 hint_nop7 hint_nop8 hint_nop9 hint_nop10 hint_nop11 hint_nop12 hint_nop13 hint_nop14 hint_nop15 hint_nop16 hint_nop17 hint_nop18 hint_nop19 hint_nop20 hint_nop21 hint_nop22 hint_nop23 hint_nop24 hint_nop25 hint_nop26 hint_nop27 hint_nop28 hint_nop29 hint_nop30 hint_nop31 hint_nop32 hint_nop33 hint_nop34 hint_nop35 hint_nop36 hint_nop37 hint_nop38 hint_nop39 hint_nop40 hint_nop41 hint_nop42 hint_nop43 hint_nop44 hint_nop45 hint_nop46 hint_nop47 hint_nop48 hint_nop49 hint_nop50 hint_nop51 hint_nop52 hint_nop53 hint_nop54 hint_nop55 hint_nop56 hint_nop57 hint_nop58 hint_nop59 hint_nop60 hint_nop61 hint_nop62 hint_nop63",built_in:"ip eip rip al ah bl bh cl ch dl dh sil dil bpl spl r8b r9b r10b r11b r12b r13b r14b r15b ax bx cx dx si di bp sp r8w r9w r10w r11w r12w r13w r14w r15w eax ebx ecx edx esi edi ebp esp eip r8d r9d r10d r11d r12d r13d r14d r15d rax rbx rcx rdx rsi rdi rbp rsp r8 r9 r10 r11 r12 r13 r14 r15 cs ds es fs gs ss st st0 st1 st2 st3 st4 st5 st6 st7 mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 xmm0  xmm1  xmm2  xmm3  xmm4  xmm5  xmm6  xmm7  xmm8  xmm9 xmm10  xmm11 xmm12 xmm13 xmm14 xmm15 xmm16 xmm17 xmm18 xmm19 xmm20 xmm21 xmm22 xmm23 xmm24 xmm25 xmm26 xmm27 xmm28 xmm29 xmm30 xmm31 ymm0  ymm1  ymm2  ymm3  ymm4  ymm5  ymm6  ymm7  ymm8  ymm9 ymm10  ymm11 ymm12 ymm13 ymm14 ymm15 ymm16 ymm17 ymm18 ymm19 ymm20 ymm21 ymm22 ymm23 ymm24 ymm25 ymm26 ymm27 ymm28 ymm29 ymm30 ymm31 zmm0  zmm1  zmm2  zmm3  zmm4  zmm5  zmm6  zmm7  zmm8  zmm9 zmm10  zmm11 zmm12 zmm13 zmm14 zmm15 zmm16 zmm17 zmm18 zmm19 zmm20 zmm21 zmm22 zmm23 zmm24 zmm25 zmm26 zmm27 zmm28 zmm29 zmm30 zmm31 k0 k1 k2 k3 k4 k5 k6 k7 bnd0 bnd1 bnd2 bnd3 cr0 cr1 cr2 cr3 cr4 cr8 dr0 dr1 dr2 dr3 dr8 tr3 tr4 tr5 tr6 tr7 r0 r1 r2 r3 r4 r5 r6 r7 r0b r1b r2b r3b r4b r5b r6b r7b r0w r1w r2w r3w r4w r5w r6w r7w r0d r1d r2d r3d r4d r5d r6d r7d r0h r1h r2h r3h r0l r1l r2l r3l r4l r5l r6l r7l r8l r9l r10l r11l r12l r13l r14l r15l db dw dd dq dt ddq do dy dz resb resw resd resq rest resdq reso resy resz incbin equ times byte word dword qword nosplit rel abs seg wrt strict near far a32 ptr",meta:"%define %xdefine %+ %undef %defstr %deftok %assign %strcat %strlen %substr %rotate %elif %else %endif %if %ifmacro %ifctx %ifidn %ifidni %ifid %ifnum %ifstr %iftoken %ifempty %ifenv %error %warning %fatal %rep %endrep %include %push %pop %repl %pathsearch %depend %use %arg %stacksize %local %line %comment %endcomment .nolist __FILE__ __LINE__ __SECT__  __BITS__ __OUTPUT_FORMAT__ __DATE__ __TIME__ __DATE_NUM__ __TIME_NUM__ __UTC_DATE__ __UTC_TIME__ __UTC_DATE_NUM__ __UTC_TIME_NUM__  __PASS__ struc endstruc istruc at iend align alignb sectalign daz nodaz up down zero default option assume public bits use16 use32 use64 default section segment absolute extern global common cpu float __utf16__ __utf16le__ __utf16be__ __utf32__ __utf32le__ __utf32be__ __float8__ __float16__ __float32__ __float64__ __float80m__ __float80e__ __float128l__ __float128h__ __Infinity__ __QNaN__ __SNaN__ Inf NaN QNaN SNaN float8 float16 float32 float64 float80m float80e float128l float128h __FLOAT_DAZ__ __FLOAT_ROUND__ __FLOAT__"},c:[s.C(";","$",{r:0}),{cN:"number",v:[{b:"\\b(?:([0-9][0-9_]*)?\\.[0-9_]*(?:[eE][+-]?[0-9_]+)?|(0[Xx])?[0-9][0-9_]*\\.?[0-9_]*(?:[pP](?:[+-]?[0-9_]+)?)?)\\b",r:0},{b:"\\$[0-9][0-9A-Fa-f]*",r:0},{b:"\\b(?:[0-9A-Fa-f][0-9A-Fa-f_]*[Hh]|[0-9][0-9_]*[DdTt]?|[0-7][0-7_]*[QqOo]|[0-1][0-1_]*[BbYy])\\b"},{b:"\\b(?:0[Xx][0-9A-Fa-f_]+|0[DdTt][0-9_]+|0[QqOo][0-7_]+|0[BbYy][0-1_]+)\\b"}]},s.QSM,{cN:"string",v:[{b:"'",e:"[^\\\\]'"},{b:"`",e:"[^\\\\]`"}],r:0},{cN:"symbol",v:[{b:"^\\s*[A-Za-z._?][A-Za-z0-9_$#@~.?]*(:|\\s+label)"},{b:"^\\s*%%[A-Za-z0-9_$#@~.?]*:"}],r:0},{cN:"subst",b:"%[0-9]+",r:0},{cN:"subst",b:"%!S+",r:0},{cN:"meta",b:/^\s*\.[\w_-]+/}]}});hljs.registerLanguage("powershell",function(e){var t={b:"`[\\s\\S]",r:0},o={cN:"variable",v:[{b:/\$[\w\d][\w\d_:]*/}]},r={cN:"string",v:[{b:/"/,e:/"/},{b:/@"/,e:/^"@/}],c:[t,o,{cN:"variable",b:/\$[A-z]/,e:/[^A-z]/}]},n=e.inherit(e.C(null,null),{v:[{b:/#/,e:/$/},{b:/<#/,e:/#>/}],c:[{cN:"doctag",v:[{b:/\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/},{b:/\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/}]}]});return{aliases:["ps"],l:/-?[A-z\.\-]+/,cI:!0,k:{keyword:"if else foreach return function do while until elseif begin for trap data dynamicparam end break throw param continue finally in switch exit filter try process catch",built_in:"Add-Computer Add-Content Add-History Add-JobTrigger Add-Member Add-PSSnapin Add-Type Checkpoint-Computer Clear-Content Clear-EventLog Clear-History Clear-Host Clear-Item Clear-ItemProperty Clear-Variable Compare-Object Complete-Transaction Connect-PSSession Connect-WSMan Convert-Path ConvertFrom-Csv ConvertFrom-Json ConvertFrom-SecureString ConvertFrom-StringData ConvertTo-Csv ConvertTo-Html ConvertTo-Json ConvertTo-SecureString ConvertTo-Xml Copy-Item Copy-ItemProperty Debug-Process Disable-ComputerRestore Disable-JobTrigger Disable-PSBreakpoint Disable-PSRemoting Disable-PSSessionConfiguration Disable-WSManCredSSP Disconnect-PSSession Disconnect-WSMan Disable-ScheduledJob Enable-ComputerRestore Enable-JobTrigger Enable-PSBreakpoint Enable-PSRemoting Enable-PSSessionConfiguration Enable-ScheduledJob Enable-WSManCredSSP Enter-PSSession Exit-PSSession Export-Alias Export-Clixml Export-Console Export-Counter Export-Csv Export-FormatData Export-ModuleMember Export-PSSession ForEach-Object Format-Custom Format-List Format-Table Format-Wide Get-Acl Get-Alias Get-AuthenticodeSignature Get-ChildItem Get-Command Get-ComputerRestorePoint Get-Content Get-ControlPanelItem Get-Counter Get-Credential Get-Culture Get-Date Get-Event Get-EventLog Get-EventSubscriber Get-ExecutionPolicy Get-FormatData Get-Host Get-HotFix Get-Help Get-History Get-IseSnippet Get-Item Get-ItemProperty Get-Job Get-JobTrigger Get-Location Get-Member Get-Module Get-PfxCertificate Get-Process Get-PSBreakpoint Get-PSCallStack Get-PSDrive Get-PSProvider Get-PSSession Get-PSSessionConfiguration Get-PSSnapin Get-Random Get-ScheduledJob Get-ScheduledJobOption Get-Service Get-TraceSource Get-Transaction Get-TypeData Get-UICulture Get-Unique Get-Variable Get-Verb Get-WinEvent Get-WmiObject Get-WSManCredSSP Get-WSManInstance Group-Object Import-Alias Import-Clixml Import-Counter Import-Csv Import-IseSnippet Import-LocalizedData Import-PSSession Import-Module Invoke-AsWorkflow Invoke-Command Invoke-Expression Invoke-History Invoke-Item Invoke-RestMethod Invoke-WebRequest Invoke-WmiMethod Invoke-WSManAction Join-Path Limit-EventLog Measure-Command Measure-Object Move-Item Move-ItemProperty New-Alias New-Event New-EventLog New-IseSnippet New-Item New-ItemProperty New-JobTrigger New-Object New-Module New-ModuleManifest New-PSDrive New-PSSession New-PSSessionConfigurationFile New-PSSessionOption New-PSTransportOption New-PSWorkflowExecutionOption New-PSWorkflowSession New-ScheduledJobOption New-Service New-TimeSpan New-Variable New-WebServiceProxy New-WinEvent New-WSManInstance New-WSManSessionOption Out-Default Out-File Out-GridView Out-Host Out-Null Out-Printer Out-String Pop-Location Push-Location Read-Host Receive-Job Register-EngineEvent Register-ObjectEvent Register-PSSessionConfiguration Register-ScheduledJob Register-WmiEvent Remove-Computer Remove-Event Remove-EventLog Remove-Item Remove-ItemProperty Remove-Job Remove-JobTrigger Remove-Module Remove-PSBreakpoint Remove-PSDrive Remove-PSSession Remove-PSSnapin Remove-TypeData Remove-Variable Remove-WmiObject Remove-WSManInstance Rename-Computer Rename-Item Rename-ItemProperty Reset-ComputerMachinePassword Resolve-Path Restart-Computer Restart-Service Restore-Computer Resume-Job Resume-Service Save-Help Select-Object Select-String Select-Xml Send-MailMessage Set-Acl Set-Alias Set-AuthenticodeSignature Set-Content Set-Date Set-ExecutionPolicy Set-Item Set-ItemProperty Set-JobTrigger Set-Location Set-PSBreakpoint Set-PSDebug Set-PSSessionConfiguration Set-ScheduledJob Set-ScheduledJobOption Set-Service Set-StrictMode Set-TraceSource Set-Variable Set-WmiInstance Set-WSManInstance Set-WSManQuickConfig Show-Command Show-ControlPanelItem Show-EventLog Sort-Object Split-Path Start-Job Start-Process Start-Service Start-Sleep Start-Transaction Start-Transcript Stop-Computer Stop-Job Stop-Process Stop-Service Stop-Transcript Suspend-Job Suspend-Service Tee-Object Test-ComputerSecureChannel Test-Connection Test-ModuleManifest Test-Path Test-PSSessionConfigurationFile Trace-Command Unblock-File Undo-Transaction Unregister-Event Unregister-PSSessionConfiguration Unregister-ScheduledJob Update-FormatData Update-Help Update-List Update-TypeData Use-Transaction Wait-Event Wait-Job Wait-Process Where-Object Write-Debug Write-Error Write-EventLog Write-Host Write-Output Write-Progress Write-Verbose Write-Warning Add-MDTPersistentDrive Disable-MDTMonitorService Enable-MDTMonitorService Get-MDTDeploymentShareStatistics Get-MDTMonitorData Get-MDTOperatingSystemCatalog Get-MDTPersistentDrive Import-MDTApplication Import-MDTDriver Import-MDTOperatingSystem Import-MDTPackage Import-MDTTaskSequence New-MDTDatabase Remove-MDTMonitorData Remove-MDTPersistentDrive Restore-MDTPersistentDrive Set-MDTMonitorData Test-MDTDeploymentShare Test-MDTMonitorData Update-MDTDatabaseSchema Update-MDTDeploymentShare Update-MDTLinkedDS Update-MDTMedia Update-MDTMedia Add-VamtProductKey Export-VamtData Find-VamtManagedMachine Get-VamtConfirmationId Get-VamtProduct Get-VamtProductKey Import-VamtData Initialize-VamtData Install-VamtConfirmationId Install-VamtProductActivation Install-VamtProductKey Update-VamtProduct",nomarkup:"-ne -eq -lt -gt -ge -le -not -like -notlike -match -notmatch -contains -notcontains -in -notin -replace"},c:[t,e.NM,r,{cN:"string",v:[{b:/'/,e:/'/},{b:/@'/,e:/^'@/}]},{cN:"literal",b:/\$(null|true|false)\b/},o,n]}});hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},s={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]};return{aliases:["sh","zsh"],l:/\b-?[a-z\._]+\b/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"meta",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,s,{cN:"string",b:/'/,e:/'/},t]}});hljs.registerLanguage("shell",function(s){return{aliases:["console"],c:[{cN:"meta",b:"^\\s{0,3}[\\w\\d\\[\\]()@-]*[>%$#]",starts:{e:"$",sL:"bash"}}]}});hljs.registerLanguage("css",function(e){var c={b:/[A-Z\_\.\-]+\s*:/,rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:/\S/,e:":",eE:!0,starts:{eW:!0,eE:!0,c:[{b:/[\w-]+\(/,rB:!0,c:[{cN:"built_in",b:/[\w-]+/},{b:/\(/,e:/\)/,c:[e.ASM,e.QSM]}]},e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"number",b:"#[0-9A-Fa-f]+"},{cN:"meta",b:"!important"}]}}]};return{cI:!0,i:/[=\/|'\$]/,c:[e.CBCM,{cN:"selector-id",b:/#[A-Za-z0-9_-]+/},{cN:"selector-class",b:/\.[A-Za-z0-9_-]+/},{cN:"selector-attr",b:/\[/,e:/\]/,i:"$"},{cN:"selector-pseudo",b:/:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/},{b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{b:"@",e:"[{;]",i:/:/,c:[{cN:"keyword",b:/\w+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[e.ASM,e.QSM,e.CSSNM]}]},{cN:"selector-tag",b:"[a-zA-Z-][a-zA-Z0-9_-]*",r:0},{b:"{",e:"}",i:/\S/,c:[e.CBCM,c]}]}});hljs.registerLanguage("vim",function(e){return{l:/[!#@\w]+/,k:{keyword:"N|0 P|0 X|0 a|0 ab abc abo al am an|0 ar arga argd arge argdo argg argl argu as au aug aun b|0 bN ba bad bd be bel bf bl bm bn bo bp br brea breaka breakd breakl bro bufdo buffers bun bw c|0 cN cNf ca cabc caddb cad caddf cal cat cb cc ccl cd ce cex cf cfir cgetb cgete cg changes chd che checkt cl cla clo cm cmapc cme cn cnew cnf cno cnorea cnoreme co col colo com comc comp con conf cope cp cpf cq cr cs cst cu cuna cunme cw delm deb debugg delc delf dif diffg diffo diffp diffpu diffs diffthis dig di dl dell dj dli do doautoa dp dr ds dsp e|0 ea ec echoe echoh echom echon el elsei em en endfo endf endt endw ene ex exe exi exu f|0 files filet fin fina fini fir fix fo foldc foldd folddoc foldo for fu go gr grepa gu gv ha helpf helpg helpt hi hid his ia iabc if ij il im imapc ime ino inorea inoreme int is isp iu iuna iunme j|0 ju k|0 keepa kee keepj lN lNf l|0 lad laddb laddf la lan lat lb lc lch lcl lcs le lefta let lex lf lfir lgetb lgete lg lgr lgrepa lh ll lla lli lmak lm lmapc lne lnew lnf ln loadk lo loc lockv lol lope lp lpf lr ls lt lu lua luad luaf lv lvimgrepa lw m|0 ma mak map mapc marks mat me menut mes mk mks mksp mkv mkvie mod mz mzf nbc nb nbs new nm nmapc nme nn nnoreme noa no noh norea noreme norm nu nun nunme ol o|0 om omapc ome on ono onoreme opt ou ounme ow p|0 profd prof pro promptr pc ped pe perld po popu pp pre prev ps pt ptN ptf ptj ptl ptn ptp ptr pts pu pw py3 python3 py3d py3f py pyd pyf quita qa rec red redi redr redraws reg res ret retu rew ri rightb rub rubyd rubyf rund ru rv sN san sa sal sav sb sbN sba sbf sbl sbm sbn sbp sbr scrip scripte scs se setf setg setl sf sfir sh sim sig sil sl sla sm smap smapc sme sn sni sno snor snoreme sor so spelld spe spelli spellr spellu spellw sp spr sre st sta startg startr star stopi stj sts sun sunm sunme sus sv sw sy synti sync tN tabN tabc tabdo tabe tabf tabfir tabl tabm tabnew tabn tabo tabp tabr tabs tab ta tags tc tcld tclf te tf th tj tl tm tn to tp tr try ts tu u|0 undoj undol una unh unl unlo unm unme uns up ve verb vert vim vimgrepa vi viu vie vm vmapc vme vne vn vnoreme vs vu vunme windo w|0 wN wa wh wi winc winp wn wp wq wqa ws wu wv x|0 xa xmapc xm xme xn xnoreme xu xunme y|0 z|0 ~ Next Print append abbreviate abclear aboveleft all amenu anoremenu args argadd argdelete argedit argglobal arglocal argument ascii autocmd augroup aunmenu buffer bNext ball badd bdelete behave belowright bfirst blast bmodified bnext botright bprevious brewind break breakadd breakdel breaklist browse bunload bwipeout change cNext cNfile cabbrev cabclear caddbuffer caddexpr caddfile call catch cbuffer cclose center cexpr cfile cfirst cgetbuffer cgetexpr cgetfile chdir checkpath checktime clist clast close cmap cmapclear cmenu cnext cnewer cnfile cnoremap cnoreabbrev cnoremenu copy colder colorscheme command comclear compiler continue confirm copen cprevious cpfile cquit crewind cscope cstag cunmap cunabbrev cunmenu cwindow delete delmarks debug debuggreedy delcommand delfunction diffupdate diffget diffoff diffpatch diffput diffsplit digraphs display deletel djump dlist doautocmd doautoall deletep drop dsearch dsplit edit earlier echo echoerr echohl echomsg else elseif emenu endif endfor endfunction endtry endwhile enew execute exit exusage file filetype find finally finish first fixdel fold foldclose folddoopen folddoclosed foldopen function global goto grep grepadd gui gvim hardcopy help helpfind helpgrep helptags highlight hide history insert iabbrev iabclear ijump ilist imap imapclear imenu inoremap inoreabbrev inoremenu intro isearch isplit iunmap iunabbrev iunmenu join jumps keepalt keepmarks keepjumps lNext lNfile list laddexpr laddbuffer laddfile last language later lbuffer lcd lchdir lclose lcscope left leftabove lexpr lfile lfirst lgetbuffer lgetexpr lgetfile lgrep lgrepadd lhelpgrep llast llist lmake lmap lmapclear lnext lnewer lnfile lnoremap loadkeymap loadview lockmarks lockvar lolder lopen lprevious lpfile lrewind ltag lunmap luado luafile lvimgrep lvimgrepadd lwindow move mark make mapclear match menu menutranslate messages mkexrc mksession mkspell mkvimrc mkview mode mzscheme mzfile nbclose nbkey nbsart next nmap nmapclear nmenu nnoremap nnoremenu noautocmd noremap nohlsearch noreabbrev noremenu normal number nunmap nunmenu oldfiles open omap omapclear omenu only onoremap onoremenu options ounmap ounmenu ownsyntax print profdel profile promptfind promptrepl pclose pedit perl perldo pop popup ppop preserve previous psearch ptag ptNext ptfirst ptjump ptlast ptnext ptprevious ptrewind ptselect put pwd py3do py3file python pydo pyfile quit quitall qall read recover redo redir redraw redrawstatus registers resize retab return rewind right rightbelow ruby rubydo rubyfile rundo runtime rviminfo substitute sNext sandbox sargument sall saveas sbuffer sbNext sball sbfirst sblast sbmodified sbnext sbprevious sbrewind scriptnames scriptencoding scscope set setfiletype setglobal setlocal sfind sfirst shell simalt sign silent sleep slast smagic smapclear smenu snext sniff snomagic snoremap snoremenu sort source spelldump spellgood spellinfo spellrepall spellundo spellwrong split sprevious srewind stop stag startgreplace startreplace startinsert stopinsert stjump stselect sunhide sunmap sunmenu suspend sview swapname syntax syntime syncbind tNext tabNext tabclose tabedit tabfind tabfirst tablast tabmove tabnext tabonly tabprevious tabrewind tag tcl tcldo tclfile tearoff tfirst throw tjump tlast tmenu tnext topleft tprevious trewind tselect tunmenu undo undojoin undolist unabbreviate unhide unlet unlockvar unmap unmenu unsilent update vglobal version verbose vertical vimgrep vimgrepadd visual viusage view vmap vmapclear vmenu vnew vnoremap vnoremenu vsplit vunmap vunmenu write wNext wall while winsize wincmd winpos wnext wprevious wqall wsverb wundo wviminfo xit xall xmapclear xmap xmenu xnoremap xnoremenu xunmap xunmenu yank",built_in:"synIDtrans atan2 range matcharg did_filetype asin feedkeys xor argv complete_check add getwinposx getqflist getwinposy screencol clearmatches empty extend getcmdpos mzeval garbagecollect setreg ceil sqrt diff_hlID inputsecret get getfperm getpid filewritable shiftwidth max sinh isdirectory synID system inputrestore winline atan visualmode inputlist tabpagewinnr round getregtype mapcheck hasmapto histdel argidx findfile sha256 exists toupper getcmdline taglist string getmatches bufnr strftime winwidth bufexists strtrans tabpagebuflist setcmdpos remote_read printf setloclist getpos getline bufwinnr float2nr len getcmdtype diff_filler luaeval resolve libcallnr foldclosedend reverse filter has_key bufname str2float strlen setline getcharmod setbufvar index searchpos shellescape undofile foldclosed setqflist buflisted strchars str2nr virtcol floor remove undotree remote_expr winheight gettabwinvar reltime cursor tabpagenr finddir localtime acos getloclist search tanh matchend rename gettabvar strdisplaywidth type abs py3eval setwinvar tolower wildmenumode log10 spellsuggest bufloaded synconcealed nextnonblank server2client complete settabwinvar executable input wincol setmatches getftype hlID inputsave searchpair or screenrow line settabvar histadd deepcopy strpart remote_peek and eval getftime submatch screenchar winsaveview matchadd mkdir screenattr getfontname libcall reltimestr getfsize winnr invert pow getbufline byte2line soundfold repeat fnameescape tagfiles sin strwidth spellbadword trunc maparg log lispindent hostname setpos globpath remote_foreground getchar synIDattr fnamemodify cscope_connection stridx winbufnr indent min complete_add nr2char searchpairpos inputdialog values matchlist items hlexists strridx browsedir expand fmod pathshorten line2byte argc count getwinvar glob foldtextresult getreg foreground cosh matchdelete has char2nr simplify histget searchdecl iconv winrestcmd pumvisible writefile foldlevel haslocaldir keys cos matchstr foldtext histnr tan tempname getcwd byteidx getbufvar islocked escape eventhandler remote_send serverlist winrestview synstack pyeval prevnonblank readfile cindent filereadable changenr exp"},i:/;/,c:[e.NM,{cN:"string",b:"'",e:"'",i:"\\n"},{cN:"string",b:/"(\\"|\n\\|[^"\n])*"/},e.C('"',"$"),{cN:"variable",b:/[bwtglsav]:[\w\d_]*/},{cN:"function",bK:"function function!",e:"$",r:0,c:[e.TM,{cN:"params",b:"\\(",e:"\\)"}]},{cN:"symbol",b:/<[\w-]+>/}]}});hljs.registerLanguage("ruby",function(e){var b="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?",r={keyword:"and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",literal:"true false nil"},c={cN:"doctag",b:"@[A-Za-z]+"},a={b:"#<",e:">"},s=[e.C("#","$",{c:[c]}),e.C("^\\=begin","^\\=end",{c:[c],r:10}),e.C("^__END__","\\n$")],n={cN:"subst",b:"#\\{",e:"}",k:r},t={cN:"string",c:[e.BE,n],v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/`/,e:/`/},{b:"%[qQwWx]?\\(",e:"\\)"},{b:"%[qQwWx]?\\[",e:"\\]"},{b:"%[qQwWx]?{",e:"}"},{b:"%[qQwWx]?<",e:">"},{b:"%[qQwWx]?/",e:"/"},{b:"%[qQwWx]?%",e:"%"},{b:"%[qQwWx]?-",e:"-"},{b:"%[qQwWx]?\\|",e:"\\|"},{b:/\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/},{b:/<<(-?)\w+$/,e:/^\s*\w+$/}]},i={cN:"params",b:"\\(",e:"\\)",endsParent:!0,k:r},d=[t,a,{cN:"class",bK:"class module",e:"$|;",i:/=/,c:[e.inherit(e.TM,{b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?"}),{b:"<\\s*",c:[{b:"("+e.IR+"::)?"+e.IR}]}].concat(s)},{cN:"function",bK:"def",e:"$|;",c:[e.inherit(e.TM,{b:b}),i].concat(s)},{b:e.IR+"::"},{cN:"symbol",b:e.UIR+"(\\!|\\?)?:",r:0},{cN:"symbol",b:":(?!\\s)",c:[t,{b:b}],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{cN:"params",b:/\|/,e:/\|/,k:r},{b:"("+e.RSR+"|unless)\\s*",k:"unless",c:[a,{cN:"regexp",c:[e.BE,n],i:/\n/,v:[{b:"/",e:"/[a-z]*"},{b:"%r{",e:"}[a-z]*"},{b:"%r\\(",e:"\\)[a-z]*"},{b:"%r!",e:"![a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}].concat(s),r:0}].concat(s);n.c=d;var l=[{b:/^\s*=>/,starts:{e:"$",c:i.c=d}},{cN:"meta",b:"^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+>|(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>)",starts:{e:"$",c:d}}];return{aliases:["rb","gemspec","podspec","thor","irb"],k:r,i:/\/\*/,c:s.concat(l).concat(d)}});hljs.registerLanguage("yaml",function(e){var b="true false yes no null",a="^[ \\-]*",r="[a-zA-Z_][\\w\\-]*",t={cN:"attr",v:[{b:a+r+":"},{b:a+'"'+r+'":'},{b:a+"'"+r+"':"}]},c={cN:"string",r:0,v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/\S+/}],c:[e.BE,{cN:"template-variable",v:[{b:"{{",e:"}}"},{b:"%{",e:"}"}]}]};return{cI:!0,aliases:["yml","YAML","yaml"],c:[t,{cN:"meta",b:"^---s*$",r:10},{cN:"string",b:"[\\|>] *$",rE:!0,c:c.c,e:t.v[0].b},{b:"<%[%=-]?",e:"[%-]?%>",sL:"ruby",eB:!0,eE:!0,r:0},{cN:"type",b:"!"+e.UIR},{cN:"type",b:"!!"+e.UIR},{cN:"meta",b:"&"+e.UIR+"$"},{cN:"meta",b:"\\*"+e.UIR+"$"},{cN:"bullet",b:"^ *-",r:0},e.HCM,{bK:b,k:{literal:b}},e.CNM,c]}});hljs.registerLanguage("fortran",function(e){return{cI:!0,aliases:["f90","f95"],k:{literal:".False. .True.",keyword:"kind do while private call intrinsic where elsewhere type endtype endmodule endselect endinterface end enddo endif if forall endforall only contains default return stop then public subroutine|10 function program .and. .or. .not. .le. .eq. .ge. .gt. .lt. goto save else use module select case access blank direct exist file fmt form formatted iostat name named nextrec number opened rec recl sequential status unformatted unit continue format pause cycle exit c_null_char c_alert c_backspace c_form_feed flush wait decimal round iomsg synchronous nopass non_overridable pass protected volatile abstract extends import non_intrinsic value deferred generic final enumerator class associate bind enum c_int c_short c_long c_long_long c_signed_char c_size_t c_int8_t c_int16_t c_int32_t c_int64_t c_int_least8_t c_int_least16_t c_int_least32_t c_int_least64_t c_int_fast8_t c_int_fast16_t c_int_fast32_t c_int_fast64_t c_intmax_t C_intptr_t c_float c_double c_long_double c_float_complex c_double_complex c_long_double_complex c_bool c_char c_null_ptr c_null_funptr c_new_line c_carriage_return c_horizontal_tab c_vertical_tab iso_c_binding c_loc c_funloc c_associated  c_f_pointer c_ptr c_funptr iso_fortran_env character_storage_size error_unit file_storage_size input_unit iostat_end iostat_eor numeric_storage_size output_unit c_f_procpointer ieee_arithmetic ieee_support_underflow_control ieee_get_underflow_mode ieee_set_underflow_mode newunit contiguous recursive pad position action delim readwrite eor advance nml interface procedure namelist include sequence elemental pure integer real character complex logical dimension allocatable|10 parameter external implicit|10 none double precision assign intent optional pointer target in out common equivalence data",built_in:"alog alog10 amax0 amax1 amin0 amin1 amod cabs ccos cexp clog csin csqrt dabs dacos dasin datan datan2 dcos dcosh ddim dexp dint dlog dlog10 dmax1 dmin1 dmod dnint dsign dsin dsinh dsqrt dtan dtanh float iabs idim idint idnint ifix isign max0 max1 min0 min1 sngl algama cdabs cdcos cdexp cdlog cdsin cdsqrt cqabs cqcos cqexp cqlog cqsin cqsqrt dcmplx dconjg derf derfc dfloat dgamma dimag dlgama iqint qabs qacos qasin qatan qatan2 qcmplx qconjg qcos qcosh qdim qerf qerfc qexp qgamma qimag qlgama qlog qlog10 qmax1 qmin1 qmod qnint qsign qsin qsinh qsqrt qtan qtanh abs acos aimag aint anint asin atan atan2 char cmplx conjg cos cosh exp ichar index int log log10 max min nint sign sin sinh sqrt tan tanh print write dim lge lgt lle llt mod nullify allocate deallocate adjustl adjustr all allocated any associated bit_size btest ceiling count cshift date_and_time digits dot_product eoshift epsilon exponent floor fraction huge iand ibclr ibits ibset ieor ior ishft ishftc lbound len_trim matmul maxexponent maxloc maxval merge minexponent minloc minval modulo mvbits nearest pack present product radix random_number random_seed range repeat reshape rrspacing scale scan selected_int_kind selected_real_kind set_exponent shape size spacing spread sum system_clock tiny transpose trim ubound unpack verify achar iachar transfer dble entry dprod cpu_time command_argument_count get_command get_command_argument get_environment_variable is_iostat_end ieee_arithmetic ieee_support_underflow_control ieee_get_underflow_mode ieee_set_underflow_mode is_iostat_eor move_alloc new_line selected_char_kind same_type_as extends_type_ofacosh asinh atanh bessel_j0 bessel_j1 bessel_jn bessel_y0 bessel_y1 bessel_yn erf erfc erfc_scaled gamma log_gamma hypot norm2 atomic_define atomic_ref execute_command_line leadz trailz storage_size merge_bits bge bgt ble blt dshiftl dshiftr findloc iall iany iparity image_index lcobound ucobound maskl maskr num_images parity popcnt poppar shifta shiftl shiftr this_image"},i:/\/\*/,c:[e.inherit(e.ASM,{cN:"string",r:0}),e.inherit(e.QSM,{cN:"string",r:0}),{cN:"function",bK:"subroutine function program",i:"[${=\\n]",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)"}]},e.C("!","$",{r:0}),{cN:"number",b:"(?=\\b|\\+|\\-|\\.)(?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*)(?:[de][+-]?\\d+)?\\b\\.?",r:0}]}});hljs.registerLanguage("erlang",function(e){var r="[a-z'][a-zA-Z0-9_']*",c="("+r+":"+r+"|"+r+")",b={keyword:"after and andalso|10 band begin bnot bor bsl bzr bxor case catch cond div end fun if let not of orelse|10 query receive rem try when xor",literal:"false true"},i=e.C("%","$"),n={cN:"number",b:"\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)",r:0},a={b:"fun\\s+"+r+"/\\d+"},d={b:c+"\\(",e:"\\)",rB:!0,r:0,c:[{b:c,r:0},{b:"\\(",e:"\\)",eW:!0,rE:!0,r:0}]},o={b:"{",e:"}",r:0},t={b:"\\b_([A-Z][A-Za-z0-9_]*)?",r:0},f={b:"[A-Z][a-zA-Z0-9_]*",r:0},l={b:"#"+e.UIR,r:0,rB:!0,c:[{b:"#"+e.UIR,r:0},{b:"{",e:"}",r:0}]},s={bK:"fun receive if try case",e:"end",k:b};s.c=[i,a,e.inherit(e.ASM,{cN:""}),s,d,e.QSM,n,o,t,f,l];var u=[i,a,s,d,e.QSM,n,o,t,f,l];d.c[1].c=u,o.c=u;var h={cN:"params",b:"\\(",e:"\\)",c:l.c[1].c=u};return{aliases:["erl"],k:b,i:"(</|\\*=|\\+=|-=|/\\*|\\*/|\\(\\*|\\*\\))",c:[{cN:"function",b:"^"+r+"\\s*\\(",e:"->",rB:!0,i:"\\(|#|//|/\\*|\\\\|:|;",c:[h,e.inherit(e.TM,{b:r})],starts:{e:";|\\.",k:b,c:u}},i,{b:"^-",e:"\\.",r:0,eE:!0,rB:!0,l:"-"+e.IR,k:"-module -record -undef -export -ifdef -ifndef -author -copyright -doc -vsn -import -include -include_lib -compile -define -else -endif -file -behaviour -behavior -spec",c:[h]},n,e.QSM,l,t,f,o,{b:/\.$/}]}});hljs.registerLanguage("nginx",function(e){var r={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},b={eW:!0,l:"[a-z/_]+",k:{literal:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,r],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0,c:[r]},{cN:"regexp",c:[e.BE,r],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},r]};return{aliases:["nginxconf"],c:[e.HCM,{b:e.UIR+"\\s+{",rB:!0,e:"{",c:[{cN:"section",b:e.UIR}],r:0},{b:e.UIR+"\\s",e:";|{",rB:!0,c:[{cN:"attribute",b:e.UIR,starts:b}],r:0}],i:"[^\\s\\}]"}});hljs.registerLanguage("makefile",function(e){var i={cN:"variable",v:[{b:"\\$\\("+e.UIR+"\\)",c:[e.BE]},{b:/\$[@%<?\^\+\*]/}]},r={cN:"string",b:/"/,e:/"/,c:[e.BE,i]},a={cN:"variable",b:/\$\([\w-]+\s/,e:/\)/,k:{built_in:"subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"},c:[i]},n={b:"^"+e.UIR+"\\s*[:+?]?=",i:"\\n",rB:!0,c:[{b:"^"+e.UIR,e:"[:+?]?=",eE:!0}]},t={cN:"section",b:/^[^\s]+:/,e:/$/,c:[i]};return{aliases:["mk","mak"],k:"define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath",l:/[\w-]+/,c:[e.HCM,i,r,a,n,{cN:"meta",b:/^\.PHONY:/,e:/$/,k:{"meta-keyword":".PHONY"},l:/[\.\w]+/},t]}});hljs.registerLanguage("ini",function(e){var b={cN:"string",c:[e.BE],v:[{b:"'''",e:"'''",r:10},{b:'"""',e:'"""',r:10},{b:'"',e:'"'},{b:"'",e:"'"}]};return{aliases:["toml"],cI:!0,i:/\S/,c:[e.C(";","$"),e.HCM,{cN:"section",b:/^\s*\[+/,e:/\]+/},{b:/^[a-z0-9\[\]_\.-]+\s*=\s*/,e:"$",rB:!0,c:[{cN:"attr",b:/[a-z0-9\[\]_\.-]+/},{b:/=/,eW:!0,r:0,c:[{cN:"literal",b:/\bon|off|true|false|yes|no\b/},{cN:"variable",v:[{b:/\$[\w\d"][\w\d_]*/},{b:/\$\{(.*?)}/}]},b,{cN:"number",b:/([\+\-]+)?[\d]+_[\d_]+/},e.NM]}]}]}});hljs.registerLanguage("matlab",function(e){var a="('|\\.')+",s={r:0,c:[{b:a}]};return{k:{keyword:"break case catch classdef continue else elseif end enumerated events for function global if methods otherwise parfor persistent properties return spmd switch try while",built_in:"sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i inf nan isnan isinf isfinite j why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson max min nanmax nanmin mean nanmean type table readtable writetable sortrows sort figure plot plot3 scatter scatter3 cellfun legend intersect ismember procrustes hold num2cell "},i:'(//|"|#|/\\*|\\s+/\\w+)',c:[{cN:"function",bK:"function",e:"$",c:[e.UTM,{cN:"params",v:[{b:"\\(",e:"\\)"},{b:"\\[",e:"\\]"}]}]},{cN:"built_in",b:/true|false/,r:0,starts:s},{b:"[a-zA-Z][a-zA-Z_0-9]*"+a,r:0},{cN:"number",b:e.CNR,r:0,starts:s},{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{b:/\]|}|\)/,r:0,starts:s},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}],starts:s},e.C("^\\s*\\%\\{\\s*$","^\\s*\\%\\}\\s*$"),e.C("\\%","$")]}});hljs.registerLanguage("elixir",function(e){var r="[a-zA-Z_][a-zA-Z0-9_.]*(\\!|\\?)?",b="and false then defined module in return redo retry end for true self when next until do begin unless nil break not case cond alias while ensure or include use alias fn quote require import with|0",n={cN:"subst",b:"#\\{",e:"}",l:r,k:b},c={cN:"string",c:[e.BE,n],v:[{b:/'/,e:/'/},{b:/"/,e:/"/}]},i={cN:"function",bK:"def defp defmacro",e:/\B\b/,c:[e.inherit(e.TM,{b:r,endsParent:!0})]},a=e.inherit(i,{cN:"class",bK:"defimpl defmodule defprotocol defrecord",e:/\bdo\b|$|;/}),l=[c,e.HCM,a,i,{b:"::"},{cN:"symbol",b:":(?![\\s:])",c:[c,{b:"[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?"}],r:0},{cN:"symbol",b:r+":(?!:)",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{b:"->"},{b:"("+e.RSR+")\\s*",c:[e.HCM,{cN:"regexp",i:"\\n",c:[e.BE,n],v:[{b:"/",e:"/[a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}],r:0}];return{l:r,k:b,c:n.c=l}});hljs.registerLanguage("objectivec",function(e){var t=/[a-zA-Z@][a-zA-Z0-9_]*/,_="@interface @class @protocol @implementation";return{aliases:["mm","objc","obj-c"],k:{keyword:"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required @encode @package @import @defs @compatibility_alias __bridge __bridge_transfer __bridge_retained __bridge_retain __covariant __contravariant __kindof _Nonnull _Nullable _Null_unspecified __FUNCTION__ __PRETTY_FUNCTION__ __attribute__ getter setter retain unsafe_unretained nonnull nullable null_unspecified null_resettable class instancetype NS_DESIGNATED_INITIALIZER NS_UNAVAILABLE NS_REQUIRES_SUPER NS_RETURNS_INNER_POINTER NS_INLINE NS_AVAILABLE NS_DEPRECATED NS_ENUM NS_OPTIONS NS_SWIFT_UNAVAILABLE NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_REFINED_FOR_SWIFT NS_SWIFT_NAME NS_SWIFT_NOTHROW NS_DURING NS_HANDLER NS_ENDHANDLER NS_VALUERETURN NS_VOIDRETURN",literal:"false true FALSE TRUE nil YES NO NULL",built_in:"BOOL dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once"},l:t,i:"</",c:[{cN:"built_in",b:"\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"},e.CLCM,e.CBCM,e.CNM,e.QSM,{cN:"string",v:[{b:'@"',e:'"',i:"\\n",c:[e.BE]},{b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"}]},{cN:"meta",b:"#",e:"$",c:[{cN:"meta-string",v:[{b:'"',e:'"'},{b:"<",e:">"}]}]},{cN:"class",b:"("+_.split(" ").join("|")+")\\b",e:"({|$)",eE:!0,k:_,l:t,c:[e.UTM]},{b:"\\."+e.UIR,r:0}]}});hljs.registerLanguage("cs",function(e){var i={keyword:"abstract as base bool break byte case catch char checked const continue decimal default delegate do double enum event explicit extern finally fixed float for foreach goto if implicit in int interface internal is lock long nameof object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this try typeof uint ulong unchecked unsafe ushort using virtual void volatile while add alias ascending async await by descending dynamic equals from get global group into join let on orderby partial remove select set value var where yield",literal:"null false true"},r={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},t={cN:"string",b:'@"',e:'"',c:[{b:'""'}]},a=e.inherit(t,{i:/\n/}),c={cN:"subst",b:"{",e:"}",k:i},n=e.inherit(c,{i:/\n/}),s={cN:"string",b:/\$"/,e:'"',i:/\n/,c:[{b:"{{"},{b:"}}"},e.BE,n]},b={cN:"string",b:/\$@"/,e:'"',c:[{b:"{{"},{b:"}}"},{b:'""'},c]},l=e.inherit(b,{i:/\n/,c:[{b:"{{"},{b:"}}"},{b:'""'},n]});c.c=[b,s,t,e.ASM,e.QSM,r,e.CBCM],n.c=[l,s,a,e.ASM,e.QSM,r,e.inherit(e.CBCM,{i:/\n/})];var o={v:[b,s,t,e.ASM,e.QSM]},d=e.IR+"(<"+e.IR+"(\\s*,\\s*"+e.IR+")*>)?(\\[\\])?";return{aliases:["csharp","c#"],k:i,i:/::/,c:[e.C("///","$",{rB:!0,c:[{cN:"doctag",v:[{b:"///",r:0},{b:"\x3c!--|--\x3e"},{b:"</?",e:">"}]}]}),e.CLCM,e.CBCM,{cN:"meta",b:"#",e:"$",k:{"meta-keyword":"if else elif endif define undef warning error line region endregion pragma checksum"}},o,r,{bK:"class interface",e:/[{;=]/,i:/[^\s:,]/,c:[e.TM,e.CLCM,e.CBCM]},{bK:"namespace",e:/[{;=]/,i:/[^\s:]/,c:[e.inherit(e.TM,{b:"[a-zA-Z](\\.?\\w)*"}),e.CLCM,e.CBCM]},{cN:"meta",b:"^\\s*\\[",eB:!0,e:"\\]",eE:!0,c:[{cN:"meta-string",b:/"/,e:/"/}]},{bK:"new return throw await else",r:0},{cN:"function",b:"("+d+"\\s+)+"+e.IR+"\\s*\\(",rB:!0,e:/\s*[{;=]/,eE:!0,k:i,c:[{b:e.IR+"\\s*\\(",rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:i,r:0,c:[o,r,e.CBCM]},e.CLCM,e.CBCM]}]}});hljs.registerLanguage("python",function(e){var r={keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10",built_in:"Ellipsis NotImplemented",literal:"False None True"},b={cN:"meta",b:/^(>>>|\.\.\.) /},c={cN:"subst",b:/\{/,e:/\}/,k:r,i:/#/},a={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[e.BE,b],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[e.BE,b],r:10},{b:/(fr|rf|f)'''/,e:/'''/,c:[e.BE,b,c]},{b:/(fr|rf|f)"""/,e:/"""/,c:[e.BE,b,c]},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},{b:/(fr|rf|f)'/,e:/'/,c:[e.BE,c]},{b:/(fr|rf|f)"/,e:/"/,c:[e.BE,c]},e.ASM,e.QSM]},i={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},l={cN:"params",b:/\(/,e:/\)/,c:["self",b,i,a]};return c.c=[a,i,b],{aliases:["py","gyp","ipython"],k:r,i:/(<\/|->|\?)|=>/,c:[b,i,a,e.HCM,{v:[{cN:"function",bK:"def"},{cN:"class",bK:"class"}],e:/:/,i:/[${=;\n,]/,c:[e.UTM,l,{b:/->/,eW:!0,k:"None"}]},{cN:"meta",b:/^[\t ]*@/,e:/$/},{b:/\b(print|exec)\(/}]}});hljs.registerLanguage("javascript",function(e){var r="[A-Za-z$_][0-9A-Za-z$_]*",t={keyword:"in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await static import from as",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"},a={cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},n={cN:"subst",b:"\\$\\{",e:"\\}",k:t,c:[]},c={cN:"string",b:"`",e:"`",c:[e.BE,n]};n.c=[e.ASM,e.QSM,c,a,e.RM];var s=n.c.concat([e.CBCM,e.CLCM]);return{aliases:["js","jsx"],k:t,c:[{cN:"meta",r:10,b:/^\s*['"]use (strict|asm)['"]/},{cN:"meta",b:/^#!/,e:/$/},e.ASM,e.QSM,c,e.CLCM,e.CBCM,a,{b:/[{,]\s*/,r:0,c:[{b:r+"\\s*:",rB:!0,r:0,c:[{cN:"attr",b:r,r:0}]}]},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{cN:"function",b:"(\\(.*?\\)|"+r+")\\s*=>",rB:!0,e:"\\s*=>",c:[{cN:"params",v:[{b:r},{b:/\(\s*\)/},{b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,c:s}]}]},{b:/</,e:/(\/\w+|\w+\/)>/,sL:"xml",c:[{b:/<\w+\s*\/>/,skip:!0},{b:/<\w+/,e:/(\/\w+|\w+\/)>/,skip:!0,c:[{b:/<\w+\s*\/>/,skip:!0},"self"]}]}],r:0},{cN:"function",bK:"function",e:/\{/,eE:!0,c:[e.inherit(e.TM,{b:r}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,c:s}],i:/\[|%/},{b:/\$[(.]/},e.METHOD_GUARD,{cN:"class",bK:"class",e:/[{;=]/,eE:!0,i:/[:"\[\]]/,c:[{bK:"extends"},e.UTM]},{bK:"constructor get set",e:/\{/,eE:!0}],i:/#(?!!)/}});hljs.registerLanguage("dockerfile",function(e){return{aliases:["docker"],cI:!0,k:"from maintainer expose env arg user onbuild stopsignal",c:[e.HCM,e.ASM,e.QSM,e.NM,{bK:"run cmd entrypoint volume add copy workdir label healthcheck shell",starts:{e:/[^\\]$/,sL:"bash"}}],i:"</"}});hljs.registerLanguage("r",function(e){var r="([a-zA-Z]|\\.[a-zA-Z.])[a-zA-Z0-9._]*";return{c:[e.HCM,{b:r,l:r,k:{keyword:"function if in break next repeat else for return switch while try tryCatch stop warning require library attach detach source setMethod setGeneric setGroupGeneric setClass ...",literal:"NULL NA TRUE FALSE T F Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10"},r:0},{cN:"number",b:"0[xX][0-9a-fA-F]+[Li]?\\b",r:0},{cN:"number",b:"\\d+(?:[eE][+\\-]?\\d*)?L\\b",r:0},{cN:"number",b:"\\d+\\.(?!\\d)(?:i\\b)?",r:0},{cN:"number",b:"\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{b:"`",e:"`",r:0},{cN:"string",c:[e.BE],v:[{b:'"',e:'"'},{b:"'",e:"'"}]}]}});hljs.registerLanguage("awk",function(e){return{k:{keyword:"BEGIN END if else while do for in break continue delete next nextfile function func exit|10"},c:[{cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},{cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,r:10},{b:/(u|b)?r?"""/,e:/"""/,r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},e.ASM,e.QSM]},e.RM,e.HCM,e.NM]}});

exports.hljs = hljs;

;})();
return exports;
}));
_define("$:/plugins/tiddlywiki/highlight/highlightblock.js","widget",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/plugins/tiddlywiki/highlight/highlightblock.js
type: application/javascript
module-type: widget

Wraps up the fenced code blocks parser for highlight and use in TiddlyWiki5

\*/
(function() {

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var TYPE_MAPPINGS_BASE = "$:/config/HighlightPlugin/TypeMappings/";

var CodeBlockWidget = require("$:/core/modules/widgets/codeblock.js").codeblock;

var hljs = require("$:/plugins/tiddlywiki/highlight/highlight.js");

hljs.configure({tabReplace: "    "});	

CodeBlockWidget.prototype.postRender = function() {
	var domNode = this.domNodes[0],
		language = this.language,
		tiddler = this.wiki.getTiddler(TYPE_MAPPINGS_BASE + language);
	if(tiddler) {
		language = tiddler.fields.text || "";
	}
	if(language && hljs.getLanguage(language)) {
		domNode.className = language.toLowerCase() + " hljs";
		if($tw.browser && !domNode.isTiddlyWikiFakeDom) {
			hljs.highlightBlock(domNode);			
		} else {
			var text = domNode.textContent;
			domNode.children[0].innerHTML = hljs.fixMarkup(hljs.highlight(language,text).value);
			// If we're using the fakedom then specially save the original raw text
			if(domNode.isTiddlyWikiFakeDom) {
				domNode.children[0].textInnerHTML = text;
			}
		}
	}	
};

})();

;})();
return exports;
}));
_define("$:/plugins/tiddlywiki/tiddlyweb/tiddlywebadaptor.js","syncadaptor",(function(module,exports,console,setInterval,clearInterval,setTimeout,clearTimeout,Buffer,$tw,require) {(function(){
/*\
title: $:/plugins/tiddlywiki/tiddlyweb/tiddlywebadaptor.js
type: application/javascript
module-type: syncadaptor

A sync adaptor module for synchronising with TiddlyWeb compatible servers

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var CONFIG_HOST_TIDDLER = "$:/config/tiddlyweb/host",
	DEFAULT_HOST_TIDDLER = "$protocol$//$host$/";

function TiddlyWebAdaptor(options) {
	this.wiki = options.wiki;
	this.host = this.getHost();
	this.recipe = undefined;
	this.hasStatus = false;
	this.logger = new $tw.utils.Logger("TiddlyWebAdaptor");
	this.isLoggedIn = false;
	this.isReadOnly = false;
}

TiddlyWebAdaptor.prototype.name = "tiddlyweb";

TiddlyWebAdaptor.prototype.isReady = function() {
	return this.hasStatus;
};

TiddlyWebAdaptor.prototype.getHost = function() {
	var text = this.wiki.getTiddlerText(CONFIG_HOST_TIDDLER,DEFAULT_HOST_TIDDLER),
		substitutions = [
			{name: "protocol", value: document.location.protocol},
			{name: "host", value: document.location.host}
		];
	for(var t=0; t<substitutions.length; t++) {
		var s = substitutions[t];
		text = $tw.utils.replaceString(text,new RegExp("\\$" + s.name + "\\$","mg"),s.value);
	}
	return text;
};

TiddlyWebAdaptor.prototype.getTiddlerInfo = function(tiddler) {
	return {
		bag: tiddler.fields.bag
	};
};

/*
Get the current status of the TiddlyWeb connection
*/
TiddlyWebAdaptor.prototype.getStatus = function(callback) {
	// Get status
	var self = this;
	this.logger.log("Getting status");
	$tw.utils.httpRequest({
		url: this.host + "status",
		callback: function(err,data) {
			self.hasStatus = true;
			if(err) {
				return callback(err);
			}
			// Decode the status JSON
			var json = null;
			try {
				json = JSON.parse(data);
			} catch (e) {
			}
			if(json) {
				self.logger.log("Status:",data);
				// Record the recipe
				if(json.space) {
					self.recipe = json.space.recipe;
				}
				// Check if we're logged in
				self.isLoggedIn = json.username !== "GUEST";
				self.isReadOnly = !!json["read_only"];
				self.isAnonymous = !!json.anonymous;
			}
			// Invoke the callback if present
			if(callback) {
				callback(null,self.isLoggedIn,json.username,self.isReadOnly,self.isAnonymous);
			}
		}
	});
};

/*
Attempt to login and invoke the callback(err)
*/
TiddlyWebAdaptor.prototype.login = function(username,password,callback) {
	var options = {
		url: this.host + "challenge/tiddlywebplugins.tiddlyspace.cookie_form",
		type: "POST",
		data: {
			user: username,
			password: password,
			tiddlyweb_redirect: "/status" // workaround to marginalize automatic subsequent GET
		},
		callback: function(err) {
			callback(err);
		}
	};
	this.logger.log("Logging in:",options);
	$tw.utils.httpRequest(options);
};

/*
*/
TiddlyWebAdaptor.prototype.logout = function(callback) {
	var options = {
		url: this.host + "logout",
		type: "POST",
		data: {
			csrf_token: this.getCsrfToken(),
			tiddlyweb_redirect: "/status" // workaround to marginalize automatic subsequent GET
		},
		callback: function(err,data) {
			callback(err);
		}
	};
	this.logger.log("Logging out:",options);
	$tw.utils.httpRequest(options);
};

/*
Retrieve the CSRF token from its cookie
*/
TiddlyWebAdaptor.prototype.getCsrfToken = function() {
	var regex = /^(?:.*; )?csrf_token=([^(;|$)]*)(?:;|$)/,
		match = regex.exec(document.cookie),
		csrf = null;
	if (match && (match.length === 2)) {
		csrf = match[1];
	}
	return csrf;
};

/*
Get an array of skinny tiddler fields from the server
*/
TiddlyWebAdaptor.prototype.getSkinnyTiddlers = function(callback) {
	var self = this;
	$tw.utils.httpRequest({
		url: this.host + "recipes/" + this.recipe + "/tiddlers.json",
		callback: function(err,data) {
			// Check for errors
			if(err) {
				return callback(err);
			}
			// Process the tiddlers to make sure the revision is a string
			var tiddlers = JSON.parse(data);
			for(var t=0; t<tiddlers.length; t++) {
				tiddlers[t] = self.convertTiddlerFromTiddlyWebFormat(tiddlers[t]);
			}
			// Invoke the callback with the skinny tiddlers
			callback(null,tiddlers);
		}
	});
};

/*
Save a tiddler and invoke the callback with (err,adaptorInfo,revision)
*/
TiddlyWebAdaptor.prototype.saveTiddler = function(tiddler,callback) {
	var self = this;
	if(this.isReadOnly) {
		return callback(null);
	}
	$tw.utils.httpRequest({
		url: this.host + "recipes/" + encodeURIComponent(this.recipe) + "/tiddlers/" + encodeURIComponent(tiddler.fields.title),
		type: "PUT",
		headers: {
			"Content-type": "application/json"
		},
		data: this.convertTiddlerToTiddlyWebFormat(tiddler),
		callback: function(err,data,request) {
			if(err) {
				return callback(err);
			}
			// Save the details of the new revision of the tiddler
			var etagInfo = self.parseEtag(request.getResponseHeader("Etag"));
			// Invoke the callback
			callback(null,{
				bag: etagInfo.bag
			}, etagInfo.revision);
		}
	});
};

/*
Load a tiddler and invoke the callback with (err,tiddlerFields)
*/
TiddlyWebAdaptor.prototype.loadTiddler = function(title,callback) {
	var self = this;
	$tw.utils.httpRequest({
		url: this.host + "recipes/" + encodeURIComponent(this.recipe) + "/tiddlers/" + encodeURIComponent(title),
		callback: function(err,data,request) {
			if(err) {
				return callback(err);
			}
			// Invoke the callback
			callback(null,self.convertTiddlerFromTiddlyWebFormat(JSON.parse(data)));
		}
	});
};

/*
Delete a tiddler and invoke the callback with (err)
options include:
tiddlerInfo: the syncer's tiddlerInfo for this tiddler
*/
TiddlyWebAdaptor.prototype.deleteTiddler = function(title,callback,options) {
	var self = this;
	if(this.isReadOnly) {
		return callback(null);
	}
	// If we don't have a bag it means that the tiddler hasn't been seen by the server, so we don't need to delete it
	var bag = options.tiddlerInfo.adaptorInfo.bag;
	if(!bag) {
		return callback(null);
	}
	// Issue HTTP request to delete the tiddler
	$tw.utils.httpRequest({
		url: this.host + "bags/" + encodeURIComponent(bag) + "/tiddlers/" + encodeURIComponent(title),
		type: "DELETE",
		callback: function(err,data,request) {
			if(err) {
				return callback(err);
			}
			// Invoke the callback
			callback(null);
		}
	});
};

/*
Convert a tiddler to a field set suitable for PUTting to TiddlyWeb
*/
TiddlyWebAdaptor.prototype.convertTiddlerToTiddlyWebFormat = function(tiddler) {
	var result = {},
		knownFields = [
			"bag", "created", "creator", "modified", "modifier", "permissions", "recipe", "revision", "tags", "text", "title", "type", "uri"
		];
	if(tiddler) {
		$tw.utils.each(tiddler.fields,function(fieldValue,fieldName) {
			var fieldString = fieldName === "tags" ?
								tiddler.fields.tags :
								tiddler.getFieldString(fieldName); // Tags must be passed as an array, not a string

			if(knownFields.indexOf(fieldName) !== -1) {
				// If it's a known field, just copy it across
				result[fieldName] = fieldString;
			} else {
				// If it's unknown, put it in the "fields" field
				result.fields = result.fields || {};
				result.fields[fieldName] = fieldString;
			}
		});
	}
	// Default the content type
	result.type = result.type || "text/vnd.tiddlywiki";
	return JSON.stringify(result,null,$tw.config.preferences.jsonSpaces);
};

/*
Convert a field set in TiddlyWeb format into ordinary TiddlyWiki5 format
*/
TiddlyWebAdaptor.prototype.convertTiddlerFromTiddlyWebFormat = function(tiddlerFields) {
	var self = this,
		result = {};
	// Transfer the fields, pulling down the `fields` hashmap
	$tw.utils.each(tiddlerFields,function(element,title,object) {
		if(title === "fields") {
			$tw.utils.each(element,function(element,subTitle,object) {
				result[subTitle] = element;
			});
		} else {
			result[title] = tiddlerFields[title];
		}
	});
	// Make sure the revision is expressed as a string
	if(typeof result.revision === "number") {
		result.revision = result.revision.toString();
	}
	// Some unholy freaking of content types
	if(result.type === "text/javascript") {
		result.type = "application/javascript";
	} else if(!result.type || result.type === "None") {
		result.type = "text/x-tiddlywiki";
	}
	return result;
};

/*
Split a TiddlyWeb Etag into its constituent parts. For example:

```
"system-images_public/unsyncedIcon/946151:9f11c278ccde3a3149f339f4a1db80dd4369fc04"
```

Note that the value includes the opening and closing double quotes.

The parts are:

```
<bag>/<title>/<revision>:<hash>
```
*/
TiddlyWebAdaptor.prototype.parseEtag = function(etag) {
	var firstSlash = etag.indexOf("/"),
		lastSlash = etag.lastIndexOf("/"),
		colon = etag.lastIndexOf(":");
	if(firstSlash === -1 || lastSlash === -1 || colon === -1) {
		return null;
	} else {
		return {
			bag: decodeURIComponent(etag.substring(1,firstSlash)),
			title: decodeURIComponent(etag.substring(firstSlash + 1,lastSlash)),
			revision: etag.substring(lastSlash + 1,colon)
		};
	}
};

if($tw.browser && document.location.protocol.substr(0,4) === "http" ) {
	exports.adaptorClass = TiddlyWebAdaptor;
}

})();

;})();
return exports;
}));}